/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/tsickle", ["require", "exports", "path", "source-map", "tsickle/src/class_decorator_downlevel_transformer", "tsickle/src/decorator-annotator", "tsickle/src/decorators", "tsickle/src/es5processor", "tsickle/src/fileoverview_comment_transformer", "tsickle/src/jsdoc", "tsickle/src/modules_manifest", "tsickle/src/rewriter", "tsickle/src/source_map_utils", "tsickle/src/transformer_sourcemap", "tsickle/src/transformer_util", "tsickle/src/type-translator", "tsickle/src/typescript", "tsickle/src/util", "tsickle/src/modules_manifest"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = require("path");
    var source_map_1 = require("source-map");
    var class_decorator_downlevel_transformer_1 = require("tsickle/src/class_decorator_downlevel_transformer");
    var decorator = require("tsickle/src/decorator-annotator");
    var decorators_1 = require("tsickle/src/decorators");
    var es5processor = require("tsickle/src/es5processor");
    var fileoverview_comment_transformer_1 = require("tsickle/src/fileoverview_comment_transformer");
    var jsdoc = require("tsickle/src/jsdoc");
    var modules_manifest_1 = require("tsickle/src/modules_manifest");
    var rewriter_1 = require("tsickle/src/rewriter");
    var source_map_utils_1 = require("tsickle/src/source_map_utils");
    var transformer_sourcemap_1 = require("tsickle/src/transformer_sourcemap");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    var typeTranslator = require("tsickle/src/type-translator");
    var ts = require("tsickle/src/typescript");
    var util_1 = require("tsickle/src/util");
    var modules_manifest_2 = require("tsickle/src/modules_manifest");
    exports.ModulesManifest = modules_manifest_2.ModulesManifest;
    /**
     * The header to be used in generated externs.  This is not included in the
     * output of annotate() because annotate() works one file at a time, and
     * typically you create one externs file from the entire compilation unit.
     */
    exports.EXTERNS_HEADER = "/**\n * @externs\n * @suppress {duplicate,checkTypes}\n */\n// NOTE: generated by tsickle, do not edit.\n";
    /**
     * Symbols that are already declared as externs in Closure, that should
     * be avoided by tsickle's "declare ..." => externs.js conversion.
     */
    exports.closureExternsBlacklist = [
        'exports',
        'global',
        'module',
        // ErrorConstructor is the interface of the Error object itself.
        // tsickle detects that this is part of the TypeScript standard library
        // and assumes it's part of the Closure standard library, but this
        // assumption is wrong for ErrorConstructor.  To properly handle this
        // we'd somehow need to map methods defined on the ErrorConstructor
        // interface into properties on Closure's Error object, but for now it's
        // simpler to just blacklist it.
        'ErrorConstructor',
        'Symbol',
        'WorkerGlobalScope',
    ];
    function formatDiagnostics(diags) {
        return diags
            .map(function (d) {
            var res = ts.DiagnosticCategory[d.category];
            if (d.file) {
                res += ' at ' + formatLocation(d.file, d.start) + ':';
            }
            res += ' ' + ts.flattenDiagnosticMessageText(d.messageText, '\n');
            return res;
        })
            .join('\n');
    }
    exports.formatDiagnostics = formatDiagnostics;
    /** Returns a fileName:line:column string for the given position in the file. */
    function formatLocation(sf, start) {
        var res = sf.fileName;
        if (start !== undefined) {
            var _a = sf.getLineAndCharacterOfPosition(start), line = _a.line, character = _a.character;
            res += ':' + (line + 1) + ':' + (character + 1);
        }
        return res;
    }
    exports.formatLocation = formatLocation;
    /** @return true if node has the specified modifier flag set. */
    function isAmbient(node) {
        var current = node;
        while (current) {
            if (util_1.hasModifierFlag(current, ts.ModifierFlags.Ambient))
                return true;
            current = current.parent;
        }
        return false;
    }
    /**
     * TypeScript allows you to write identifiers quoted, like:
     *   interface Foo {
     *     'bar': string;
     *     'complex name': string;
     *   }
     *   Foo.bar;  // ok
     *   Foo['bar']  // ok
     *   Foo['complex name']  // ok
     *
     * In Closure-land, we want identify that the legal name 'bar' can become an
     * ordinary field, but we need to skip strings like 'complex name'.
     */
    function isValidClosurePropertyName(name) {
        // In local experimentation, it appears that reserved words like 'var' and
        // 'if' are legal JS and still accepted by Closure.
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
    }
    /** Returns the Closure name of a function parameter, special-casing destructuring. */
    function getParameterName(param, index) {
        switch (param.name.kind) {
            case ts.SyntaxKind.Identifier:
                var name_1 = rewriter_1.getIdentifierText(param.name);
                // TypeScript allows parameters named "arguments", but Closure
                // disallows this, even in externs.
                if (name_1 === 'arguments')
                    name_1 = 'tsickle_arguments';
                return name_1;
            case ts.SyntaxKind.ArrayBindingPattern:
            case ts.SyntaxKind.ObjectBindingPattern:
                // Closure crashes if you put a binding pattern in the externs.
                // Avoid this by just generating an unused name; the name is
                // ignored anyway.
                return "__" + index;
            default:
                // The above list of kinds is exhaustive.  param.name is 'never' at this point.
                var paramName = param.name;
                throw new Error("unhandled function parameter kind: " + ts.SyntaxKind[paramName.kind]);
        }
    }
    /** Flags that declare a field of the same name if set on a ctor parameter. */
    var FIELD_DECLARATION_MODIFIERS = ts.ModifierFlags.Private |
        ts.ModifierFlags.Protected | ts.ModifierFlags.Public | ts.ModifierFlags.Readonly;
    /**
     * A Rewriter subclass that adds Tsickle-specific (Closure translation) functionality.
     *
     * One Rewriter subclass manages .ts => .ts+Closure translation.
     * Another Rewriter subclass manages .ts => externs translation.
     */
    var ClosureRewriter = /** @class */ (function (_super) {
        __extends(ClosureRewriter, _super);
        function ClosureRewriter(typeChecker, file, host, sourceMapper) {
            var _this = _super.call(this, file, sourceMapper) || this;
            _this.typeChecker = typeChecker;
            _this.host = host;
            /**
             * A mapping of aliases for symbols in the current file, used when emitting types.
             * TypeScript emits imported symbols with unpredictable prefixes. To generate correct type
             * annotations, tsickle creates its own aliases for types, and registers them in this map (see
             * `emitImportDeclaration` and `forwardDeclare()` below). The aliases are then used when emitting
             * types.
             */
            _this.symbolsToAliasedNames = new Map();
            return _this;
        }
        /** Finds an exported (i.e. not global) declaration for the given symbol. */
        ClosureRewriter.prototype.findExportedDeclaration = function (sym) {
            var _this = this;
            // TODO(martinprobst): it's unclear when a symbol wouldn't have a declaration, maybe just for
            // some builtins (e.g. Symbol)?
            if (!sym.declarations || sym.declarations.length === 0)
                return undefined;
            // A symbol declared in this file does not need to be imported.
            if (sym.declarations.some(function (d) { return d.getSourceFile() === _this.file; }))
                return undefined;
            // Find an exported declaration.
            // Because tsickle runs with the --declaration flag, all types referenced from exported types
            // must be exported, too, so there must either be some declaration that is exported, or the
            // symbol is actually a global declaration (declared in a script file, not a module).
            var decl = sym.declarations.find(function (d) {
                // Check for Export | Default (default being a default export).
                if (!util_1.hasModifierFlag(d, ts.ModifierFlags.ExportDefault))
                    return false;
                // Exclude symbols declared in `declare global {...}` blocks, they are global and don't need
                // imports.
                var current = d;
                while (current) {
                    if (current.flags & ts.NodeFlags.GlobalAugmentation)
                        return false;
                    current = current.parent;
                }
                return true;
            });
            return decl;
        };
        /**
         * Get the ts.Symbol at a location or throw.
         * The TypeScript API can return undefined when fetching a symbol, but
         * in many contexts we know it won't (e.g. our input is already type-checked).
         */
        ClosureRewriter.prototype.mustGetSymbolAtLocation = function (node) {
            var sym = this.typeChecker.getSymbolAtLocation(node);
            if (!sym)
                throw new Error('no symbol');
            return sym;
        };
        /**
         * Handles emittng the jsdoc for methods, including overloads.
         * If overloaded, merges the signatures in the list of SignatureDeclarations into a single jsdoc.
         * - Total number of parameters will be the maximum count found across all variants.
         * - Different names at the same parameter index will be joined with "_or_"
         * - Variable args (...type[] in TypeScript) will be output as "...type",
         *    except if found at the same index as another argument.
         * @param  fnDecls Pass > 1 declaration for overloads of same name
         * @return The list of parameter names that should be used to emit the actual
         *    function statement; for overloads, name will have been merged.
         */
        ClosureRewriter.prototype.emitFunctionType = function (fnDecls, extraTags) {
            if (extraTags === void 0) { extraTags = []; }
            var typeChecker = this.typeChecker;
            var newDoc = extraTags;
            var lens = fnDecls.map(function (fnDecl) { return fnDecl.parameters.length; });
            var minArgsCount = Math.min.apply(Math, __spread(lens));
            var maxArgsCount = Math.max.apply(Math, __spread(lens));
            var isConstructor = fnDecls.find(function (d) { return d.kind === ts.SyntaxKind.Constructor; }) !== undefined;
            // For each parameter index i, paramTags[i] is an array of parameters
            // that can be found at index i.  E.g.
            //    function foo(x: string)
            //    function foo(y: number, z: string)
            // then paramTags[0] = [info about x, info about y].
            var paramTags = [];
            var returnTags = [];
            var typeParameterNames = new Set();
            try {
                for (var fnDecls_1 = __values(fnDecls), fnDecls_1_1 = fnDecls_1.next(); !fnDecls_1_1.done; fnDecls_1_1 = fnDecls_1.next()) {
                    var fnDecl = fnDecls_1_1.value;
                    // Construct the JSDoc comment by reading the existing JSDoc, if
                    // any, and merging it with the known types of the function
                    // parameters and return type.
                    var docTags = this.getJSDoc(fnDecl) || [];
                    try {
                        // Copy all the tags other than @param/@return into the new
                        // JSDoc without any change; @param/@return are handled specially.
                        // TODO: there may be problems if an annotation doesn't apply to all overloads;
                        // is it worth checking for this and erroring?
                        for (var docTags_1 = __values(docTags), docTags_1_1 = docTags_1.next(); !docTags_1_1.done; docTags_1_1 = docTags_1.next()) {
                            var tag = docTags_1_1.value;
                            if (tag.tagName === 'param' || tag.tagName === 'return')
                                continue;
                            newDoc.push(tag);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (docTags_1_1 && !docTags_1_1.done && (_a = docTags_1.return)) _a.call(docTags_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    // Add @abstract on "abstract" declarations.
                    if (util_1.hasModifierFlag(fnDecl, ts.ModifierFlags.Abstract)) {
                        newDoc.push({ tagName: 'abstract' });
                    }
                    // Add any @template tags.
                    // Multiple declarations with the same template variable names should work:
                    // the declarations get turned into union types, and Closure Compiler will need
                    // to find a union where all type arguments are satisfied.
                    if (fnDecl.typeParameters) {
                        try {
                            for (var _b = __values(fnDecl.typeParameters), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var tp = _c.value;
                                typeParameterNames.add(rewriter_1.getIdentifierText(tp.name));
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    // Merge the parameters into a single list of merged names and list of types
                    var sig = typeChecker.getSignatureFromDeclaration(fnDecl);
                    if (!sig)
                        throw new Error("invalid signature " + fnDecl.name);
                    for (var i = 0; i < sig.declaration.parameters.length; i++) {
                        var paramNode = sig.declaration.parameters[i];
                        var name_2 = getParameterName(paramNode, i);
                        var isThisParam = name_2 === 'this';
                        var newTag = {
                            tagName: isThisParam ? 'this' : 'param',
                            optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,
                            parameterName: isThisParam ? undefined : name_2,
                        };
                        var type = typeChecker.getTypeAtLocation(paramNode);
                        if (paramNode.dotDotDotToken !== undefined) {
                            newTag.restParam = true;
                            // In TypeScript you write "...x: number[]", but in Closure
                            // you don't write the array: "@param {...number} x".  Unwrap
                            // the Array<> wrapper.
                            var typeRef = type;
                            if (!typeRef.typeArguments)
                                throw new Error('invalid rest param');
                            type = typeRef.typeArguments[0];
                        }
                        newTag.type = this.typeToClosure(fnDecl, type);
                        try {
                            for (var docTags_2 = __values(docTags), docTags_2_1 = docTags_2.next(); !docTags_2_1.done; docTags_2_1 = docTags_2.next()) {
                                var _e = docTags_2_1.value, tagName = _e.tagName, parameterName = _e.parameterName, text = _e.text;
                                if (tagName === 'param' && parameterName === newTag.parameterName) {
                                    newTag.text = text;
                                    break;
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (docTags_2_1 && !docTags_2_1.done && (_f = docTags_2.return)) _f.call(docTags_2);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                        if (!paramTags[i])
                            paramTags.push([]);
                        paramTags[i].push(newTag);
                    }
                    // Return type.
                    if (!isConstructor) {
                        var retType = typeChecker.getReturnTypeOfSignature(sig);
                        var retTypeString = this.typeToClosure(fnDecl, retType);
                        var returnDoc = void 0;
                        try {
                            for (var docTags_3 = __values(docTags), docTags_3_1 = docTags_3.next(); !docTags_3_1.done; docTags_3_1 = docTags_3.next()) {
                                var _g = docTags_3_1.value, tagName = _g.tagName, text = _g.text;
                                if (tagName === 'return') {
                                    returnDoc = text;
                                    break;
                                }
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (docTags_3_1 && !docTags_3_1.done && (_h = docTags_3.return)) _h.call(docTags_3);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        returnTags.push({
                            tagName: 'return',
                            type: retTypeString,
                            text: returnDoc,
                        });
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (fnDecls_1_1 && !fnDecls_1_1.done && (_j = fnDecls_1.return)) _j.call(fnDecls_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
            if (typeParameterNames.size > 0) {
                newDoc.push({ tagName: 'template', text: Array.from(typeParameterNames.values()).join(', ') });
            }
            // Merge the JSDoc tags for each overloaded parameter.
            // Ensure each parameter has a unique name; the merging process can otherwise
            // accidentally generate the same parameter name twice.
            var paramNames = new Set();
            var foundOptional = false;
            for (var i = 0; i < maxArgsCount; i++) {
                var paramTag = jsdoc.merge(paramTags[i]);
                if (paramNames.has(paramTag.parameterName)) {
                    paramTag.parameterName += i.toString();
                }
                paramNames.add(paramTag.parameterName);
                // If the tag is optional, mark parameters following optional as optional,
                // even if they are not, since Closure restricts this, see
                // https://github.com/google/closure-compiler/issues/2314
                if (!paramTag.restParam && (paramTag.optional || foundOptional || i >= minArgsCount)) {
                    foundOptional = true;
                    paramTag.optional = true;
                }
                newDoc.push(paramTag);
                if (paramTag.restParam) {
                    // Cannot have any parameters after a rest param.
                    // Just dump the remaining parameters.
                    break;
                }
            }
            // Merge the JSDoc tags for each overloaded return.
            if (!isConstructor) {
                newDoc.push(jsdoc.merge(returnTags));
            }
            this.emit('\n' + jsdoc.toString(newDoc));
            return newDoc.filter(function (t) { return t.tagName === 'param'; }).map(function (t) { return t.parameterName; });
            var e_5, _j, e_1, _a, e_2, _d, e_3, _f, e_4, _h;
        };
        /**
         * Returns null if there is no existing comment.
         */
        ClosureRewriter.prototype.getJSDoc = function (node) {
            var text = node.getFullText();
            var comments = ts.getLeadingCommentRanges(text, 0);
            if (!comments || comments.length === 0)
                return null;
            // We need to search backwards for the first JSDoc comment to avoid ignoring such when another
            // code-level comment is between that comment and the function declaration (see
            // testfiles/doc_params for an example).
            var docRelativePos = 0;
            var parsed = null;
            for (var i = comments.length - 1; i >= 0; i--) {
                var _a = comments[i], pos = _a.pos, end = _a.end;
                // end is relative within node.getFullText(), add getFullStart to obtain coordinates that are
                // comparable to node positions.
                var docRelativeEnd = end + node.getFullStart();
                if (docRelativeEnd <= this.file.getStart() &&
                    this.file.text.substring(docRelativeEnd).startsWith('\n\n')) {
                    // This comment is at the very beginning of the file and there's an empty line between the
                    // comment and this node, it's a "detached comment". That means we should treat it as a
                    // file-level comment, not attached to this code node.
                    return null;
                }
                var comment = text.substring(pos, end);
                parsed = jsdoc.parse(comment);
                if (parsed) {
                    docRelativePos = node.getFullStart() + pos;
                    break;
                }
            }
            if (!parsed)
                return null;
            if (parsed.warnings) {
                var start = docRelativePos;
                this.diagnostics.push({
                    file: this.file,
                    start: start,
                    length: node.getStart() - start,
                    messageText: parsed.warnings.join('\n'),
                    category: ts.DiagnosticCategory.Warning,
                    code: 0,
                });
            }
            return parsed.tags;
        };
        ClosureRewriter.prototype.maybeAddTemplateClause = function (docTags, decl) {
            var _this = this;
            if (!decl.typeParameters)
                return;
            // Closure does not support template constraints (T extends X).
            docTags.push({
                tagName: 'template',
                text: decl.typeParameters
                    .map(function (tp) {
                    if (tp.constraint) {
                        _this.emit('\n// unsupported: template constraints.');
                    }
                    return rewriter_1.getIdentifierText(tp.name);
                })
                    .join(', ')
            });
        };
        ClosureRewriter.prototype.maybeAddHeritageClauses = function (docTags, decl) {
            if (!decl.heritageClauses)
                return;
            try {
                for (var _a = __values(decl.heritageClauses), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var heritage = _b.value;
                    if (!heritage.types)
                        continue;
                    var isClass = decl.kind === ts.SyntaxKind.ClassDeclaration;
                    if (isClass && heritage.token !== ts.SyntaxKind.ImplementsKeyword && !isAmbient(decl)) {
                        // If a class has "extends Foo", that is preserved in the ES6 output
                        // and we don't need to do anything.  But if it has "implements Foo",
                        // that is a TS-specific thing and we need to translate it to the
                        // the Closure "@implements {Foo}".
                        // However for ambient declarations, we only emit externs, and in those we do need to
                        // add "@extends {Foo}" as they use ES5 syntax.
                        continue;
                    }
                    try {
                        for (var _c = __values(heritage.types), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var impl = _d.value;
                            var tagName = decl.kind === ts.SyntaxKind.InterfaceDeclaration ? 'extends' : 'implements';
                            // We can only @implements an interface, not a class.
                            // But it's fine to translate TS "implements Class" into Closure
                            // "@extends {Class}" because this is just a type hint.
                            var typeChecker = this.typeChecker;
                            var sym = this.mustGetSymbolAtLocation(impl.expression);
                            var alias = sym;
                            if (sym.flags & ts.SymbolFlags.TypeAlias) {
                                // It's implementing a type alias.  Follow the type alias back
                                // to the original symbol to check whether it's a type or a value.
                                var type = this.typeChecker.getDeclaredTypeOfSymbol(sym);
                                if (!type.symbol) {
                                    // It's not clear when this can happen, but if it does all we
                                    // do is fail to emit the @implements, which isn't so harmful.
                                    continue;
                                }
                                alias = type.symbol;
                            }
                            if (alias.flags & ts.SymbolFlags.Alias) {
                                alias = typeChecker.getAliasedSymbol(alias);
                            }
                            var typeTranslator_1 = this.newTypeTranslator(impl.expression);
                            if (typeTranslator_1.isBlackListed(alias)) {
                                continue;
                            }
                            if (alias.flags & ts.SymbolFlags.Class) {
                                if (!isClass) {
                                    // Only classes can extend classes in TS. Ignoring the heritage clause should be safe,
                                    // as interfaces are @record anyway, so should prevent property disambiguation.
                                    // Problem: validate that methods are there?
                                    continue;
                                }
                                tagName = 'extends';
                            }
                            else if (alias.flags & ts.SymbolFlags.Value) {
                                // If the symbol was already in the value namespace, then it will
                                // not be a type in the Closure output (because Closure collapses
                                // the type and value namespaces).  Just ignore the implements.
                                continue;
                            }
                            // typeToClosure includes nullability modifiers, so call symbolToString directly here.
                            docTags.push({ tagName: tagName, type: typeTranslator_1.symbolToString(sym, true) });
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_e = _c.return)) _e.call(_c);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
                }
                finally { if (e_7) throw e_7.error; }
            }
            var e_7, _f, e_6, _e;
        };
        /** Emits a type annotation in JSDoc, or {?} if the type is unavailable. */
        ClosureRewriter.prototype.emitJSDocType = function (node, additionalDocTag, type) {
            this.emit(' /**');
            if (additionalDocTag) {
                this.emit(' ' + additionalDocTag);
            }
            this.emit(" @type {" + this.typeToClosure(node, type) + "} */");
        };
        /**
         * Convert a TypeScript ts.Type into the equivalent Closure type.
         *
         * @param context The ts.Node containing the type reference; used for resolving symbols
         *     in context.
         * @param type The type to translate; if not provided, the Node's type will be used.
         * @param resolveAlias If true, do not emit aliases as their symbol, but rather as the resolved
         *     type underlying the alias. This should be true only when emitting the typedef itself.
         */
        ClosureRewriter.prototype.typeToClosure = function (context, type, resolveAlias) {
            if (this.host.untyped) {
                return '?';
            }
            var typeChecker = this.typeChecker;
            if (!type) {
                type = typeChecker.getTypeAtLocation(context);
            }
            return this.newTypeTranslator(context).translate(type, resolveAlias);
        };
        ClosureRewriter.prototype.newTypeTranslator = function (context) {
            var _this = this;
            var translator = new typeTranslator.TypeTranslator(this.typeChecker, context, this.host.typeBlackListPaths, this.symbolsToAliasedNames, function (sym) { return _this.ensureSymbolDeclared(sym); });
            translator.warn = function (msg) { return _this.debugWarn(context, msg); };
            return translator;
        };
        /**
         * debug logs a debug warning.  These should only be used for cases
         * where tsickle is making a questionable judgement about what to do.
         * By default, tsickle does not report any warnings to the caller,
         * and warnings are hidden behind a debug flag, as warnings are only
         * for tsickle to debug itself.
         */
        ClosureRewriter.prototype.debugWarn = function (node, messageText) {
            if (!this.host.logWarning)
                return;
            // Use a ts.Diagnosic so that the warning includes context and file offets.
            var diagnostic = {
                file: this.file,
                start: node.getStart(),
                length: node.getEnd() - node.getStart(),
                messageText: messageText,
                category: ts.DiagnosticCategory.Warning,
                code: 0,
            };
            this.host.logWarning(diagnostic);
        };
        return ClosureRewriter;
    }(rewriter_1.Rewriter));
    // Matches common extensions of TypeScript input filenames
    var extension = /(\.ts|\.d\.ts|\.js|\.jsx|\.tsx)$/;
    var FILEOVERVIEW_COMMENTS = new Set(['fileoverview', 'externs', 'modName', 'mods', 'pintomodule']);
    /** Annotator translates a .ts to a .ts with Closure annotations. */
    var Annotator = /** @class */ (function (_super) {
        __extends(Annotator, _super);
        function Annotator(typeChecker, file, host, tsHost, tsOpts, sourceMapper) {
            var _this = _super.call(this, typeChecker, file, host, sourceMapper) || this;
            _this.tsHost = tsHost;
            _this.tsOpts = tsOpts;
            /** Exported symbol names that have been generated by expanding an "export * from ...". */
            _this.generatedExports = new Set();
            /** Collection of Identifiers used in an `import {foo}` declaration with their Symbol */
            _this.importedNames = [];
            _this.templateSpanStackCount = 0;
            _this.polymerBehaviorStackCount = 0;
            /**
             * The set of module symbols forward declared in the local namespace (with goog.forwarDeclare).
             *
             * Symbols not imported must be declared, which is done by adding forward declares to
             * `extraImports` below.
             */
            _this.forwardDeclaredModules = new Set();
            _this.extraDeclares = '';
            _this.forwardDeclareCounter = 0;
            return _this;
        }
        Annotator.prototype.annotate = function () {
            this.visit(this.file);
            return this.getOutput(this.extraDeclares);
        };
        Annotator.prototype.ensureSymbolDeclared = function (sym) {
            var decl = this.findExportedDeclaration(sym);
            if (!decl)
                return;
            // Actually import the symbol.
            var sf = decl.getSourceFile();
            var moduleSymbol = this.typeChecker.getSymbolAtLocation(sf);
            if (!moduleSymbol) {
                return; // A source file might not have a symbol if it's not a module (no ES6 im/exports).
            }
            // Already imported?
            if (this.forwardDeclaredModules.has(moduleSymbol))
                return;
            // TODO(martinprobst): this should possibly use fileNameToModuleId.
            var text = this.getForwardDeclareText(sf.fileName, moduleSymbol);
            this.extraDeclares += text;
        };
        Annotator.prototype.getExportDeclarationNames = function (node) {
            var _this = this;
            switch (node.kind) {
                case ts.SyntaxKind.VariableStatement:
                    var varDecl = node;
                    return varDecl.declarationList.declarations.map(function (d) { return _this.getExportDeclarationNames(d)[0]; });
                case ts.SyntaxKind.VariableDeclaration:
                case ts.SyntaxKind.FunctionDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.ModuleDeclaration:
                    var decl = node;
                    if (!decl.name || decl.name.kind !== ts.SyntaxKind.Identifier) {
                        break;
                    }
                    return [decl.name];
                case ts.SyntaxKind.TypeAliasDeclaration:
                    var typeAlias = node;
                    return [typeAlias.name];
                default:
                    break;
            }
            this.error(node, "unsupported export declaration " + ts.SyntaxKind[node.kind] + ": " + node.getText());
            return [];
        };
        /**
         * Emits an ES6 export for the ambient declaration behind node, if it is indeed exported.
         */
        Annotator.prototype.maybeEmitAmbientDeclarationExport = function (node) {
            // In TypeScript, `export declare` simply generates no code in the exporting module, but does
            // generate a regular import in the importing module.
            // For Closure Compiler, such declarations must still be exported, so that importing code in
            // other modules can reference them. Because tsickle generates global symbols for such types,
            // the appropriate semantics are referencing the global name.
            if (this.host.untyped || !util_1.hasModifierFlag(node, ts.ModifierFlags.Export)) {
                return;
            }
            var declNames = this.getExportDeclarationNames(node);
            try {
                for (var declNames_1 = __values(declNames), declNames_1_1 = declNames_1.next(); !declNames_1_1.done; declNames_1_1 = declNames_1.next()) {
                    var decl = declNames_1_1.value;
                    var sym = this.mustGetSymbolAtLocation(decl);
                    var isValue = sym.flags & ts.SymbolFlags.Value;
                    var declName = rewriter_1.getIdentifierText(decl);
                    if (node.kind === ts.SyntaxKind.VariableStatement) {
                        // For variables, TypeScript rewrites every reference to the variable name as an
                        // "exports." access, to maintain mutable ES6 exports semantics. Indirecting through the
                        // window object means we reference the correct global symbol. Closure Compiler does
                        // understand that "var foo" in externs corresponds to "window.foo".
                        this.emit("\nexports." + declName + " = window." + declName + ";\n");
                    }
                    else if (!isValue) {
                        // Do not emit re-exports for ModuleDeclarations.
                        // Ambient ModuleDeclarations are always referenced as global symbols, so they don't need to
                        // be exported.
                        if (node.kind === ts.SyntaxKind.ModuleDeclaration)
                            continue;
                        // Non-value objects do not exist at runtime, so we cannot access the symbol (it only
                        // exists in externs). Export them as a typedef, which forwards to the type in externs.
                        this.emit("\n/** @typedef {" + declName + "} */\nexports." + declName + ";\n");
                    }
                    else {
                        this.emit("\nexports." + declName + " = " + declName + ";\n");
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (declNames_1_1 && !declNames_1_1.done && (_a = declNames_1.return)) _a.call(declNames_1);
                }
                finally { if (e_8) throw e_8.error; }
            }
            var e_8, _a;
        };
        /**
         * Examines a ts.Node and decides whether to do special processing of it for output.
         *
         * @return True if the ts.Node has been handled, false if we should
         *     emit it as is and visit its children.
         */
        Annotator.prototype.maybeProcess = function (node) {
            var _this = this;
            if (util_1.hasModifierFlag(node, ts.ModifierFlags.Ambient) || util_1.isDtsFileName(this.file.fileName)) {
                // An ambient declaration declares types for TypeScript's benefit, so we want to skip Tsickle
                // conversion of its contents.
                this.writeRange(node, node.getFullStart(), node.getEnd());
                // ... but it might need to be exported for downstream importing code.
                this.maybeEmitAmbientDeclarationExport(node);
                return true;
            }
            if (this.currentDecoratorConverter) {
                this.currentDecoratorConverter.beforeProcessNode(node);
            }
            switch (node.kind) {
                case ts.SyntaxKind.SourceFile:
                    this.handleSourceFile(node);
                    return true;
                case ts.SyntaxKind.ImportDeclaration:
                    (_a = this.importedNames).push.apply(_a, __spread(decorator.collectImportedNames(this.typeChecker, node)));
                    return this.emitImportDeclaration(node);
                case ts.SyntaxKind.ExportDeclaration:
                    var exportDecl = node;
                    this.writeLeadingTrivia(node);
                    this.emit('export');
                    var exportedSymbols = [];
                    if (!exportDecl.exportClause && exportDecl.moduleSpecifier) {
                        // It's an "export * from ..." statement.
                        // Rewrite it to re-export each exported symbol directly.
                        exportedSymbols = this.expandSymbolsFromExportStar(exportDecl);
                        var exportSymbolsToEmit = exportedSymbols.filter(function (s) { return _this.shouldEmitExportSymbol(s.sym); });
                        this.emit(" {" + exportSymbolsToEmit.map(function (e) { return rewriter_1.unescapeName(e.name); }).join(',') + "}");
                    }
                    else {
                        if (exportDecl.exportClause) {
                            exportedSymbols = this.getNamedSymbols(exportDecl.exportClause.elements);
                            this.visit(exportDecl.exportClause);
                        }
                    }
                    if (exportDecl.moduleSpecifier) {
                        this.emit(" from '" + this.resolveModuleSpecifier(exportDecl.moduleSpecifier) + "';");
                    }
                    else {
                        // export {...};
                        this.emit(';');
                    }
                    this.addSourceMapping(node);
                    if (exportDecl.moduleSpecifier) {
                        this.forwardDeclare(exportDecl.moduleSpecifier);
                    }
                    if (exportedSymbols.length) {
                        this.emitTypeDefExports(exportedSymbols);
                    }
                    return true;
                case ts.SyntaxKind.InterfaceDeclaration:
                    this.emitInterface(node);
                    // Emit the TS interface verbatim, with no tsickle processing of properties.
                    this.writeRange(node, node.getFullStart(), node.getEnd());
                    return true;
                case ts.SyntaxKind.VariableDeclaration:
                    var varDecl = node;
                    // Only emit a type annotation when it's a plain variable and
                    // not a binding pattern, as Closure doesn't(?) have a syntax
                    // for annotating binding patterns.  See issue #128.
                    // Don't emit type annotation when the variable statement is a @polymerBehavior,
                    // as otherwise the polymer closure checker will fail.
                    // See b/64389806
                    if (this.polymerBehaviorStackCount === 0 &&
                        varDecl.name.kind === ts.SyntaxKind.Identifier) {
                        this.emitJSDocType(varDecl);
                    }
                    return false;
                case ts.SyntaxKind.ClassDeclaration:
                    var classNode = node;
                    this.visitClassDeclaration(classNode);
                    return true;
                case ts.SyntaxKind.PublicKeyword:
                case ts.SyntaxKind.PrivateKeyword:
                    // The "public"/"private" keywords are encountered in two places:
                    // 1) In class fields (which don't appear in the transformed output).
                    // 2) In "parameter properties", e.g.
                    //      constructor(/** @export */ public foo: string).
                    // In case 2 it's important to not emit that JSDoc in the generated
                    // constructor, as this is illegal for Closure.  It's safe to just
                    // always skip comments preceding the 'public' keyword.
                    // See test_files/parameter_properties.ts.
                    this.writeNode(node, /* skipComments */ true);
                    return true;
                case ts.SyntaxKind.Constructor:
                    var ctor = node;
                    this.emitFunctionType([ctor]);
                    // Write the "constructor(...) {" bit, but iterate through any
                    // parameters if given so that we can examine them more closely.
                    this.writeNodeFrom(ctor, ctor.getStart());
                    return true;
                case ts.SyntaxKind.ArrowFunction:
                    // It's difficult to annotate arrow functions due to a bug in
                    // TypeScript (see tsickle issue 57).  For now, just pass them
                    // through unannotated.
                    return false;
                case ts.SyntaxKind.FunctionDeclaration:
                case ts.SyntaxKind.MethodDeclaration:
                case ts.SyntaxKind.GetAccessor:
                case ts.SyntaxKind.SetAccessor:
                    var fnDecl = node;
                    var tags = decorators_1.hasExportingDecorator(node, this.typeChecker) ? [{ tagName: 'export' }] : [];
                    if (!fnDecl.body) {
                        // Two cases: abstract methods and overloaded methods/functions.
                        // Abstract methods are handled in emitTypeAnnotationsHandler.
                        // Overloads are union-ized into the shared type in emitFunctionType.
                        return false;
                    }
                    this.emitFunctionType([fnDecl], tags);
                    this.newTypeTranslator(fnDecl).blacklistTypeParameters(this.symbolsToAliasedNames, fnDecl.typeParameters);
                    this.writeNodeFrom(fnDecl, fnDecl.getStart());
                    return true;
                case ts.SyntaxKind.TypeAliasDeclaration:
                    this.writeNode(node);
                    this.visitTypeAlias(node);
                    return true;
                case ts.SyntaxKind.EnumDeclaration:
                    this.processEnum(node);
                    return true;
                case ts.SyntaxKind.TemplateSpan:
                    this.templateSpanStackCount++;
                    this.writeNode(node);
                    this.templateSpanStackCount--;
                    return true;
                case ts.SyntaxKind.TypeAssertionExpression:
                case ts.SyntaxKind.AsExpression:
                    // Both of these cases are AssertionExpressions.
                    var typeAssertion = node;
                    if (this.polymerBehaviorStackCount > 0) {
                        // Don't emit type casts for Polymer behaviors that are declared
                        // by calling the Polymer function
                        // as the Polymer closure plugin does not work when emitting them.
                        // See b/64389806.
                        // Note: This only matters in the transformer version of tsickle,
                        // as the non transformer version never emitted type casts due to
                        // https://github.com/Microsoft/TypeScript/issues/9873 (see below).
                        return false;
                    }
                    // When using a type casts in template expressions,
                    // closure requires another pair of parens, otherwise it will
                    // complain with "Misplaced type annotation. Type annotations are not allowed here."
                    if (this.templateSpanStackCount > 0) {
                        this.emit('(');
                    }
                    this.emitJSDocType(typeAssertion);
                    // When TypeScript emits JS, it removes one layer of "redundant"
                    // parens, but we need them for the Closure type assertion.  Work
                    // around this by using two parens.  See test_files/coerce.*.
                    // This is needed in both, the transformer and non transformer version.
                    // TODO: in the non transformer version, the comment is currently dropped
                    //  alltegether from pure assignments due to
                    //  https://github.com/Microsoft/TypeScript/issues/9873.
                    this.emit('((');
                    this.writeNode(node);
                    this.emit('))');
                    if (this.templateSpanStackCount > 0) {
                        this.emit(')');
                    }
                    return true;
                case ts.SyntaxKind.NonNullExpression:
                    var nnexpr = node;
                    var type = this.typeChecker.getTypeAtLocation(nnexpr.expression);
                    if (type.flags & ts.TypeFlags.Union) {
                        var nonNullUnion = type
                            .types.filter(function (t) { return (t.flags & (ts.TypeFlags.Null | ts.TypeFlags.Undefined)) === 0; });
                        var typeCopy = Object.assign({}, type);
                        typeCopy.types = nonNullUnion;
                        type = typeCopy;
                    }
                    // See comment above.
                    if (this.templateSpanStackCount > 0) {
                        this.emit('(');
                    }
                    this.emitJSDocType(nnexpr, undefined, type);
                    // See comment above.
                    this.emit('((');
                    this.writeNode(nnexpr.expression);
                    this.emit('))');
                    if (this.templateSpanStackCount > 0) {
                        this.emit(')');
                    }
                    return true;
                case ts.SyntaxKind.PropertyDeclaration:
                case ts.SyntaxKind.VariableStatement:
                    var docTags = this.getJSDoc(node) || [];
                    if (decorators_1.hasExportingDecorator(node, this.typeChecker)) {
                        docTags.push({ tagName: 'export' });
                    }
                    if (docTags.length > 0 && node.getFirstToken()) {
                        this.emit('\n');
                        this.emit(jsdoc.toString(docTags));
                        var isPolymerBehavior = docTags.some(function (t) { return t.tagName === 'polymerBehavior'; });
                        if (isPolymerBehavior) {
                            this.polymerBehaviorStackCount++;
                        }
                        this.writeNodeFrom(node, node.getStart());
                        if (isPolymerBehavior) {
                            this.polymerBehaviorStackCount--;
                        }
                        return true;
                    }
                    break;
                case ts.SyntaxKind.PropertyAssignment:
                    var pa = node;
                    if (isPolymerBehaviorPropertyInCallExpression(pa)) {
                        this.polymerBehaviorStackCount++;
                        this.writeNodeFrom(node, node.getStart());
                        this.polymerBehaviorStackCount--;
                        return true;
                    }
                    return false;
                case ts.SyntaxKind.ElementAccessExpression:
                    // Warn for quoted accesses to properties that have a symbol declared.
                    // Mixing quoted and non-quoted access to a symbol (x['foo'] and x.foo) risks breaking
                    // Closure Compiler renaming. Quoted access is more cumbersome to write than dotted access
                    // though, so chances are users did intend to avoid renaming. The better fix is to use
                    // `declare interface` though.
                    var eae = node;
                    if (!eae.argumentExpression ||
                        eae.argumentExpression.kind !== ts.SyntaxKind.StringLiteral) {
                        return false;
                    }
                    var quotedPropSym = this.typeChecker.getSymbolAtLocation(eae.argumentExpression);
                    // If it has a symbol, it's actually a regular declared property.
                    if (!quotedPropSym)
                        return false;
                    var declarationHasQuotes = !quotedPropSym.declarations || quotedPropSym.declarations.some(function (d) {
                        var decl = d;
                        if (!decl.name)
                            return false;
                        return decl.name.kind === ts.SyntaxKind.StringLiteral;
                    });
                    // If the property is declared with quotes, it should also be accessed with them.
                    if (declarationHasQuotes)
                        return false;
                    var propName = eae.argumentExpression.text;
                    // Properties containing non-JS identifier names can only be accessed with quotes.
                    if (!isValidClosurePropertyName(propName))
                        return false;
                    var symName = this.typeChecker.symbolToString(quotedPropSym);
                    this.debugWarn(eae, "Declared property " + symName + " accessed with quotes. " +
                        "This can lead to renaming bugs. A better fix is to use 'declare interface' " +
                        "on the declaration.");
                    // Previously, the code below changed the quoted into a non-quoted access.
                    // this.writeNode(eae.expression);
                    // this.emit(`.${propName}`);
                    return false;
                case ts.SyntaxKind.PropertyAccessExpression:
                    // Convert dotted accesses to types that have an index type declared to quoted accesses, to
                    // avoid Closure renaming one access but not the other.
                    // This can happen because TS allows dotted access to string index types.
                    var pae = node;
                    var t = this.typeChecker.getTypeAtLocation(pae.expression);
                    if (!t.getStringIndexType())
                        return false;
                    // Types can have string index signatures and declared properties (of the matching type).
                    // These properties have a symbol, as opposed to pure string index types.
                    var propSym = this.typeChecker.getSymbolAtLocation(pae.name);
                    // The decision to return below is a judgement call. Presumably, in most situations, dotted
                    // access to a property is correct, and should not be turned into quoted access even if
                    // there is a string index on the type. However it is possible to construct programs where
                    // this is incorrect, e.g. where user code assigns into a property through the index access
                    // in another location.
                    if (propSym)
                        return false;
                    this.debugWarn(pae, this.typeChecker.typeToString(t) +
                        " has a string index type but is accessed using dotted access. " +
                        "Quoting the access.");
                    this.writeNode(pae.expression);
                    this.emit('["');
                    this.writeNode(pae.name);
                    this.emit('"]');
                    return true;
                case ts.SyntaxKind.Decorator:
                    if (this.currentDecoratorConverter) {
                        return this.currentDecoratorConverter.maybeProcessDecorator(node);
                    }
                    return false;
                default:
                    break;
            }
            return false;
            var _a;
        };
        Annotator.prototype.shouldEmitExportSymbol = function (sym) {
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = this.typeChecker.getAliasedSymbol(sym);
            }
            if ((sym.flags & ts.SymbolFlags.Value) === 0) {
                // Note: We create explicit reexports via closure at another place in
                return false;
            }
            if (sym.flags & ts.SymbolFlags.ConstEnum) {
                return false;
            }
            return true;
        };
        Annotator.prototype.handleSourceFile = function (sf) {
            // Emit leading detached comments: comments separated by a \n\n from the document.
            // While handlers below generally emit comments preceding them, not all of them do in all
            // situations (e.g. JSDoc preceding a class).
            // This is symmetric with `getJSDoc` below not returning detached file level comments.
            var comments = ts.getLeadingCommentRanges(sf.text, 0) || [];
            var start = sf.getFullStart();
            for (var i = comments.length - 1; i >= 0; i--) {
                if (sf.text.substring(comments[i].end, comments[i].end + 2) === '\n\n') {
                    this.emit(sf.text.substring(0, comments[i].end + 2));
                    start = comments[i].end + 2;
                    break;
                }
            }
            this.writeNodeFrom(sf, start);
        };
        /**
         * Given a "export * from ..." statement, gathers the symbol names it actually
         * exports to be used in a statement like "export {foo, bar, baz} from ...".
         *
         * This is necessary because TS transpiles "export *" by just doing a runtime loop
         * over the target module's exports, which means Closure won't see the declarations/types
         * that are exported.
         */
        Annotator.prototype.expandSymbolsFromExportStar = function (exportDecl) {
            // You can't have an "export *" without a module specifier.
            var moduleSpecifier = exportDecl.moduleSpecifier;
            // Gather the names of local exports, to avoid reexporting any
            // names that are already locally exported.
            var moduleSymbol = this.typeChecker.getSymbolAtLocation(this.file);
            var moduleExports = moduleSymbol && moduleSymbol.exports || new Map();
            // Expand the export list, then filter it to the symbols we want to reexport.
            var exports = this.typeChecker.getExportsOfModule(this.mustGetSymbolAtLocation(moduleSpecifier));
            var reexports = new Set();
            try {
                for (var exports_1 = __values(exports), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {
                    var sym = exports_1_1.value;
                    var name_3 = rewriter_1.unescapeName(sym.name);
                    if (moduleExports instanceof Map) {
                        if (moduleExports.has(name_3)) {
                            // This name is shadowed by a local definition, such as:
                            // - export var foo ...
                            // - export {foo} from ...
                            // - export {bar as foo} from ...
                            continue;
                        }
                    }
                    else {
                        // TODO(#634): check if this is a safe cast.
                        if (moduleExports.has(name_3))
                            continue;
                    }
                    if (this.generatedExports.has(name_3)) {
                        // Already exported via an earlier expansion of an "export * from ...".
                        continue;
                    }
                    this.generatedExports.add(name_3);
                    reexports.add(sym);
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);
                }
                finally { if (e_9) throw e_9.error; }
            }
            return Array.from(reexports.keys()).map(function (sym) {
                return { name: sym.name, sym: sym };
            });
            var e_9, _a;
        };
        /**
         * Write an `exports.` assignment for each type alias exported in the given `exports`.
         * TypeScript by itself does not export non-value symbols (e.g. interfaces, typedefs), as it
         * expects to remove those entirely for runtime. For Closure, types must be
         * exported as downstream code will import the type.
         *
         * The tsickle pass turns interfaces into values by generating a `function MyInterface() {}` for
         * them, so in the second conversion pass, TypeScript does export a value for them. However for
         * pure typedefs, tsickle only generates a property access with a JSDoc comment, so they need to
         * be exported explicitly here.
         */
        Annotator.prototype.emitTypeDefExports = function (exports) {
            if (this.host.untyped)
                return;
            try {
                for (var exports_2 = __values(exports), exports_2_1 = exports_2.next(); !exports_2_1.done; exports_2_1 = exports_2.next()) {
                    var exp = exports_2_1.value;
                    if (exp.sym.flags & ts.SymbolFlags.Alias)
                        exp.sym = this.typeChecker.getAliasedSymbol(exp.sym);
                    var isTypeAlias = ((exp.sym.flags & ts.SymbolFlags.TypeAlias) !== 0 &&
                        (exp.sym.flags & ts.SymbolFlags.Value) === 0) ||
                        (exp.sym.flags & ts.SymbolFlags.Interface) !== 0 &&
                            (exp.sym.flags & ts.SymbolFlags.Value) === 0;
                    if (!isTypeAlias)
                        continue;
                    var typeName = this.symbolsToAliasedNames.get(exp.sym) || exp.sym.name;
                    this.emit("\n/** @typedef {" + typeName + "} */\nexports." + exp.name + "; // re-export typedef");
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (exports_2_1 && !exports_2_1.done && (_a = exports_2.return)) _a.call(exports_2);
                }
                finally { if (e_10) throw e_10.error; }
            }
            var e_10, _a;
        };
        /**
         * Convert from implicit `import {} from 'pkg'` to `import {} from 'pkg/index'.
         * TypeScript supports the shorthand, but not all ES6 module loaders do.
         * Workaround for https://github.com/Microsoft/TypeScript/issues/12597
         */
        Annotator.prototype.resolveModuleSpecifier = function (moduleSpecifier) {
            if (moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {
                throw new Error("unhandled moduleSpecifier kind: " + ts.SyntaxKind[moduleSpecifier.kind]);
            }
            var moduleId = moduleSpecifier.text;
            if (this.host.convertIndexImportShorthand) {
                if (!this.tsOpts || !this.tsHost) {
                    throw new Error('option convertIndexImportShorthand requires that annotate be called with a TypeScript host and options.');
                }
                var resolved = ts.resolveModuleName(moduleId, this.file.fileName, this.tsOpts, this.tsHost);
                if (resolved && resolved.resolvedModule) {
                    var requestedModule = moduleId.replace(extension, '');
                    var resolvedModule = resolved.resolvedModule.resolvedFileName.replace(extension, '');
                    if (resolvedModule.indexOf('node_modules') === -1 &&
                        requestedModule.substr(requestedModule.lastIndexOf('/')) !==
                            resolvedModule.substr(resolvedModule.lastIndexOf('/'))) {
                        moduleId = './' +
                            path.relative(path.dirname(this.file.fileName), resolvedModule)
                                .replace(path.sep, '/');
                    }
                }
            }
            return moduleId;
        };
        /**
         * Handles emit of an "import ..." statement.
         * We need to do a bit of rewriting so that imported types show up under the
         * correct name in JSDoc.
         * @return true if the decl was handled, false to allow default processing.
         */
        Annotator.prototype.emitImportDeclaration = function (decl) {
            this.writeLeadingTrivia(decl);
            this.emit('import');
            var importPath = this.resolveModuleSpecifier(decl.moduleSpecifier);
            var importClause = decl.importClause;
            if (!importClause) {
                // import './foo';
                this.emit("'" + importPath + "';");
                this.addSourceMapping(decl);
                return true;
            }
            else if (importClause.name ||
                (importClause.namedBindings &&
                    importClause.namedBindings.kind === ts.SyntaxKind.NamedImports)) {
                this.visit(importClause);
                this.emit(" from '" + importPath + "';");
                this.addSourceMapping(decl);
                // importClause.name implies
                //   import defaultName from ...;
                // namedBindings being NamedImports implies
                //   import {a, b as c} from ...;
                //
                // Both of these forms create a local name "a", which after TypeScript CommonJS compilation
                // will become some renamed variable like "module_1.default" or "module_1.a" or "module_1.c"
                // (for default vs named vs renamed bindings, respectively).
                // tsickle references types in JSDoc. Because the module prefixes are not predictable, and
                // because TypeScript might remove imports entirely if they are only for types, the code below
                // inserts an artificial `const prefix = goog.forwardDeclare` call for the module, and then
                // registers all symbols from this import to be prefixed.
                this.forwardDeclare(decl.moduleSpecifier, /** default import? */ !!importClause.name);
                return true;
            }
            else if (importClause.namedBindings &&
                importClause.namedBindings.kind === ts.SyntaxKind.NamespaceImport) {
                // import * as foo from ...;
                this.visit(importClause);
                this.emit(" from '" + importPath + "';");
                this.addSourceMapping(decl);
                // Introduce a goog.forwardDeclare for the module, so that if TypeScript does not emit the
                // module because it's only used in type positions, the JSDoc comments still reference a valid
                // Closure level symbol.
                var sym = this.typeChecker.getSymbolAtLocation(decl.moduleSpecifier);
                if (!sym) {
                    return true; // modules might not have a symbol if they are unused.
                }
                this.forwardDeclare(decl.moduleSpecifier, false);
                return true;
            }
            else {
                this.errorUnimplementedKind(decl, 'unexpected kind of import');
                return false; // Use default processing.
            }
        };
        Annotator.prototype.getNamedSymbols = function (specifiers) {
            var _this = this;
            return specifiers.map(function (e) {
                return {
                    // e.name might be renaming symbol as in `export {Foo as Bar}`, where e.name would be 'Bar'
                    // and != sym.name. Store away the name so forwardDeclare below can emit the right name.
                    name: rewriter_1.getIdentifierText(e.name),
                    sym: _this.mustGetSymbolAtLocation(e.name),
                };
            });
        };
        /**
         * Emits a `goog.forwardDeclare` alias for each symbol from the given list.
         * @param specifier the import specifier, i.e. module path ("from '...'").
         */
        Annotator.prototype.forwardDeclare = function (specifier, isDefaultImport) {
            if (isDefaultImport === void 0) { isDefaultImport = false; }
            var importPath = this.resolveModuleSpecifier(specifier);
            var moduleSymbol = this.typeChecker.getSymbolAtLocation(specifier);
            this.emit(this.getForwardDeclareText(importPath, moduleSymbol, isDefaultImport));
        };
        /**
         * Returns the `const x = goog.forwardDeclare...` text for an import of the given `importPath`.
         * This also registers aliases for symbols from the module that map to this forward declare.
         */
        Annotator.prototype.getForwardDeclareText = function (importPath, moduleSymbol, isDefaultImport) {
            if (isDefaultImport === void 0) { isDefaultImport = false; }
            if (this.host.untyped)
                return '';
            var nsImport = es5processor.extractGoogNamespaceImport(importPath);
            var forwardDeclarePrefix = "tsickle_forward_declare_" + ++this.forwardDeclareCounter;
            var moduleNamespace = nsImport !== null ? nsImport : this.host.pathToModuleName(this.file.fileName, importPath);
            // In TypeScript, importing a module for use in a type annotation does not cause a runtime load.
            // In Closure Compiler, goog.require'ing a module causes a runtime load, so emitting requires
            // here would cause a change in load order, which is observable (and can lead to errors).
            // Instead, goog.forwardDeclare types, which allows using them in type annotations without
            // causing a load. See below for the exception to the rule.
            var emitText = "const " + forwardDeclarePrefix + " = goog.forwardDeclare(\"" + moduleNamespace + "\");\n";
            // Scripts do not have a symbol. Scripts can still be imported, either as side effect imports or
            // with an empty import set ("{}"). TypeScript does not emit a runtime load for an import with
            // an empty list of symbols, but the import forces any global declarations from the library to
            // be visible, which is what users use this for. No symbols from the script need forward
            // declaration, so just return.
            if (!moduleSymbol)
                return '';
            this.forwardDeclaredModules.add(moduleSymbol);
            var exports = this.typeChecker.getExportsOfModule(moduleSymbol);
            var hasValues = exports.some(function (e) {
                var isValue = (e.flags & ts.SymbolFlags.Value) !== 0;
                var isConstEnum = (e.flags & ts.SymbolFlags.ConstEnum) !== 0;
                // const enums are inlined by TypeScript (if preserveConstEnums=false), so there is never a
                // value import generated for them. That means for the purpose of force-importing modules,
                // they do not count as values. If preserveConstEnums=true, this shouldn't hurt.
                return isValue && !isConstEnum;
            });
            if (!hasValues) {
                // Closure Compiler's toolchain will drop files that are never goog.require'd *before* type
                // checking (e.g. when using --closure_entry_point or similar tools). This causes errors
                // complaining about values not matching 'NoResolvedType', or modules not having a certain
                // member.
                // To fix, explicitly goog.require() modules that only export types. This should usually not
                // cause breakages due to load order (as no symbols are accessible from the module - though
                // contrived code could observe changes in side effects).
                // This is a heuristic - if the module exports some values, but those are never imported,
                // the file will still end up not being imported. Hopefully modules that export values are
                // imported for their value in some place.
                emitText += "goog.require(\"" + moduleNamespace + "\"); // force type-only module to be loaded\n";
            }
            try {
                for (var exports_3 = __values(exports), exports_3_1 = exports_3.next(); !exports_3_1.done; exports_3_1 = exports_3.next()) {
                    var sym = exports_3_1.value;
                    if (sym.flags & ts.SymbolFlags.Alias) {
                        sym = this.typeChecker.getAliasedSymbol(sym);
                    }
                    // goog: imports don't actually use the .default property that TS thinks they have.
                    var qualifiedName = nsImport && isDefaultImport ? forwardDeclarePrefix :
                        forwardDeclarePrefix + '.' + sym.name;
                    this.symbolsToAliasedNames.set(sym, qualifiedName);
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (exports_3_1 && !exports_3_1.done && (_a = exports_3.return)) _a.call(exports_3);
                }
                finally { if (e_11) throw e_11.error; }
            }
            return emitText;
            var e_11, _a;
        };
        Annotator.prototype.visitClassDeclaration = function (classDecl) {
            this.addSourceMapping(classDecl);
            var oldDecoratorConverter = this.currentDecoratorConverter;
            this.currentDecoratorConverter =
                new decorator.DecoratorClassVisitor(this.typeChecker, this, classDecl, this.importedNames);
            var docTags = this.getJSDoc(classDecl) || [];
            if (util_1.hasModifierFlag(classDecl, ts.ModifierFlags.Abstract)) {
                docTags.push({ tagName: 'abstract' });
            }
            if (!this.host.untyped) {
                this.maybeAddTemplateClause(docTags, classDecl);
                this.maybeAddHeritageClauses(docTags, classDecl);
            }
            this.emit('\n');
            if (docTags.length > 0)
                this.emit(jsdoc.toString(docTags));
            decorator.visitClassContentIncludingDecorators(classDecl, this, this.currentDecoratorConverter);
            this.emitTypeAnnotationsHelper(classDecl);
            this.currentDecoratorConverter = oldDecoratorConverter;
            return true;
        };
        Annotator.prototype.emitInterface = function (iface) {
            // If this symbol is both a type and a value, we cannot emit both into Closure's
            // single namespace.
            var sym = this.mustGetSymbolAtLocation(iface.name);
            if (sym.flags & ts.SymbolFlags.Value)
                return;
            var docTags = this.getJSDoc(iface) || [];
            docTags.push({ tagName: 'record' });
            if (!this.host.untyped) {
                this.maybeAddTemplateClause(docTags, iface);
                this.maybeAddHeritageClauses(docTags, iface);
            }
            this.emit('\n');
            this.emit(jsdoc.toString(docTags));
            if (util_1.hasModifierFlag(iface, ts.ModifierFlags.Export))
                this.emit('export ');
            var name = rewriter_1.getIdentifierText(iface.name);
            this.emit("function " + name + "() {}\n");
            this.emit("\n\nfunction " + name + "_tsickle_Closure_declarations() {\n");
            var memberNamespace = [name, 'prototype'];
            try {
                for (var _a = __values(iface.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var elem = _b.value;
                    var isOptional = elem.questionToken != null;
                    this.visitProperty(memberNamespace, elem, isOptional);
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_12) throw e_12.error; }
            }
            this.emit("}\n");
            var e_12, _c;
        };
        /**
         * emitTypeAnnotationsHelper produces a _tsickle_typeAnnotationsHelper() where
         * none existed in the original source. It's necessary in the case where
         * TypeScript syntax specifies there are additional properties on the class,
         * because to declare these in Closure you must declare these in a method
         * somewhere.
         */
        Annotator.prototype.emitTypeAnnotationsHelper = function (classDecl) {
            var _this = this;
            // Gather parameter properties from the constructor, if it exists.
            var ctors = [];
            var paramProps = [];
            var nonStaticProps = [];
            var staticProps = [];
            var abstractMethods = [];
            try {
                for (var _a = __values(classDecl.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    if (member.kind === ts.SyntaxKind.Constructor) {
                        ctors.push(member);
                    }
                    else if (member.kind === ts.SyntaxKind.PropertyDeclaration) {
                        var prop = member;
                        var isStatic = util_1.hasModifierFlag(prop, ts.ModifierFlags.Static);
                        if (isStatic) {
                            staticProps.push(prop);
                        }
                        else {
                            nonStaticProps.push(prop);
                        }
                    }
                    else if (util_1.hasModifierFlag(member, ts.ModifierFlags.Abstract) &&
                        (member.kind === ts.SyntaxKind.MethodDeclaration ||
                            member.kind === ts.SyntaxKind.GetAccessor ||
                            member.kind === ts.SyntaxKind.SetAccessor)) {
                        abstractMethods.push(member);
                    }
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_13) throw e_13.error; }
            }
            if (ctors.length > 0) {
                var ctor = ctors[0];
                paramProps = ctor.parameters.filter(function (p) { return util_1.hasModifierFlag(p, FIELD_DECLARATION_MODIFIERS); });
            }
            if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0 &&
                abstractMethods.length === 0 &&
                !(this.currentDecoratorConverter && this.currentDecoratorConverter.foundDecorators())) {
                // There are no members so we don't need to emit any type
                // annotations helper.
                return;
            }
            if (!classDecl.name)
                return;
            var className = rewriter_1.getIdentifierText(classDecl.name);
            this.emit("\n\nfunction " + className + "_tsickle_Closure_declarations() {\n");
            if (this.currentDecoratorConverter) {
                this.currentDecoratorConverter.emitMetadataTypeAnnotationsHelpers();
            }
            staticProps.forEach(function (p) { return _this.visitProperty([className], p); });
            var memberNamespace = [className, 'prototype'];
            nonStaticProps.forEach(function (p) { return _this.visitProperty(memberNamespace, p); });
            paramProps.forEach(function (p) { return _this.visitProperty(memberNamespace, p); });
            try {
                for (var abstractMethods_1 = __values(abstractMethods), abstractMethods_1_1 = abstractMethods_1.next(); !abstractMethods_1_1.done; abstractMethods_1_1 = abstractMethods_1.next()) {
                    var fnDecl = abstractMethods_1_1.value;
                    var name_4 = this.propertyName(fnDecl);
                    if (!name_4) {
                        this.error(fnDecl, 'anonymous abstract function');
                        continue;
                    }
                    var tags = decorators_1.hasExportingDecorator(fnDecl, this.typeChecker) ? [{ tagName: 'export' }] : [];
                    var paramNames = this.emitFunctionType([fnDecl], tags);
                    // memberNamespace because abstract methods cannot be static in TypeScript.
                    this.emit(memberNamespace.join('.') + "." + name_4 + " = function(" + paramNames.join(', ') + ") {};\n");
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (abstractMethods_1_1 && !abstractMethods_1_1.done && (_d = abstractMethods_1.return)) _d.call(abstractMethods_1);
                }
                finally { if (e_14) throw e_14.error; }
            }
            this.emit("}\n");
            var e_13, _c, e_14, _d;
        };
        Annotator.prototype.propertyName = function (prop) {
            if (!prop.name)
                return null;
            switch (prop.name.kind) {
                case ts.SyntaxKind.Identifier:
                    return rewriter_1.getIdentifierText(prop.name);
                case ts.SyntaxKind.StringLiteral:
                    // E.g. interface Foo { 'bar': number; }
                    // If 'bar' is a name that is not valid in Closure then there's nothing we can do.
                    var text = prop.name.text;
                    if (!isValidClosurePropertyName(text))
                        return null;
                    return text;
                default:
                    return null;
            }
        };
        /**
         * @param optional If true, property is optional (e.g. written "foo?: string").
         */
        Annotator.prototype.visitProperty = function (namespace, prop, optional) {
            if (optional === void 0) { optional = false; }
            var name = this.propertyName(prop);
            if (!name) {
                this.emit("/* TODO: handle strange member:\n" + this.escapeForComment(prop.getText()) + "\n*/\n");
                return;
            }
            var type = this.typeToClosure(prop);
            // When a property is optional, e.g.
            //   foo?: string;
            // Then the TypeScript type of the property is string|undefined, the
            // typeToClosure translation handles it correctly, and string|undefined is
            // how you write an optional property in Closure.
            //
            // But in the special case of an optional property with type any:
            //   foo?: any;
            // The TypeScript type of the property is just "any" (because any includes
            // undefined as well) so our default translation of the type is just "?".
            // To mark the property as optional in Closure it must have "|undefined",
            // so the Closure type must be ?|undefined.
            if (optional && type === '?')
                type += '|undefined';
            var tags = this.getJSDoc(prop) || [];
            tags.push({ tagName: 'type', type: type });
            if (decorators_1.hasExportingDecorator(prop, this.typeChecker)) {
                tags.push({ tagName: 'export' });
            }
            // Avoid printing annotations that can conflict with @type
            // This avoids Closure's error "type annotation incompatible with other annotations"
            this.emit(jsdoc.toString(tags, new Set(['param', 'return'])));
            namespace = namespace.concat([name]);
            this.emit(namespace.join('.') + ";\n");
        };
        Annotator.prototype.visitTypeAlias = function (node) {
            if (this.host.untyped)
                return;
            // If the type is also defined as a value, skip emitting it. Closure collapses type & value
            // namespaces, the two emits would conflict if tsickle emitted both.
            var sym = this.mustGetSymbolAtLocation(node.name);
            if (sym.flags & ts.SymbolFlags.Value)
                return;
            // Write a Closure typedef, which involves an unused "var" declaration.
            // Note: in the case of an export, we cannot emit a literal "var" because
            // TypeScript drops exports that are never assigned to (and Closure
            // requires us to not assign to typedef exports).  Instead, emit the
            // "exports.foo;" line directly in that case.
            this.newTypeTranslator(node).blacklistTypeParameters(this.symbolsToAliasedNames, node.typeParameters);
            var typeStr = this.typeToClosure(node, undefined, true /* resolveAlias */);
            this.emit("\n/** @typedef {" + typeStr + "} */\n");
            if (util_1.hasModifierFlag(node, ts.ModifierFlags.Export)) {
                this.emit('exports.');
            }
            else {
                this.emit('var ');
            }
            this.emit(node.name.getText() + ";\n");
        };
        /**
         * getEnumType computes the Closure type of an enum, by iterating through the members
         * and gathering their types.
         */
        Annotator.prototype.getEnumType = function (enumDecl) {
            var hasNumber = false;
            var hasString = false;
            try {
                for (var _a = __values(enumDecl.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    if (member.initializer) {
                        var type = this.typeChecker.getTypeAtLocation(member.initializer);
                        // Note: checking against 'NumberLike' instead of just 'Number' means this code
                        // handles both
                        //   MEMBER = 3,  // TypeFlags.NumberLiteral
                        // and
                        //   MEMBER = someFunction(),  // TypeFlags.Number
                        if (type.flags & ts.TypeFlags.NumberLike) {
                            hasNumber = true;
                        }
                        else if (type.flags & ts.TypeFlags.StringLike) {
                            hasString = true;
                        }
                        else {
                            // Enum contains something other than a string or a number; bail.
                            return '?';
                        }
                    }
                    else {
                        // Members without initializers default to numeric.
                        hasNumber = true;
                    }
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_15) throw e_15.error; }
            }
            if (hasNumber && hasString) {
                return '?'; // Closure's new type inference doesn't support enums of unions.
            }
            else if (hasNumber) {
                return 'number';
            }
            else if (hasString) {
                return 'string';
            }
            else {
                // Perhaps an empty enum?
                return '?';
            }
            var e_15, _c;
        };
        /**
         * Processes an EnumDeclaration into a Closure type. Always emits a Closure type, even in untyped
         * mode, as that should be harmless (it only ever uses the number type).
         */
        Annotator.prototype.processEnum = function (node) {
            // Emit the enum declaration, which looks like:
            //   /** @enum {number} */
            //   const Foo = {BAR: 0, BAZ: 1, ...};
            //   export {Foo};  // even if originally exported on one line.
            // This declares an enum type for Closure Compiler (and Closure JS users of this TS code).
            // Splitting the enum into declaration and export is required so that local references to the
            // type resolve ("@type {Foo}").
            this.emit('\n');
            var name = node.name.getText();
            var enumType = this.getEnumType(node);
            this.emit("/** @enum {" + enumType + "} */\n");
            this.emit("const " + name + ": DontTypeCheckMe = {");
            // Emit enum values ('BAR: 0,').
            var enumIndex = 0;
            try {
                for (var _a = __values(node.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    var memberName = member.name.getText();
                    // Emit any comments and leading whitespace on the enum value definition.
                    this.writeLeadingTrivia(member);
                    this.emit(memberName + ": ");
                    if (member.initializer) {
                        var enumConstValue = this.typeChecker.getConstantValue(member);
                        if (typeof enumConstValue === 'number') {
                            enumIndex = enumConstValue + 1;
                            this.emit(enumConstValue.toString());
                        }
                        else {
                            // Non-numeric enum value (string or an expression).
                            // Emit this initializer expression as-is.
                            // Note: if the member's initializer expression refers to another
                            // value within the enum (e.g. something like
                            //   enum Foo {
                            //     Field1,
                            //     Field2 = Field1 + something(),
                            //   }
                            // Then when we emit the initializer we produce invalid code because
                            // on the Closure side the reference to Field1 has to be namespaced,
                            // e.g. written "Foo.Field1 + something()".
                            // Hopefully this doesn't come up often -- if the enum instead has
                            // something like
                            //     Field2 = Field1 + 3,
                            // then it's still a constant expression and we inline the constant
                            // value in the above branch of this "if" statement.
                            this.visit(member.initializer);
                        }
                    }
                    else {
                        this.emit(enumIndex.toString());
                        enumIndex++;
                    }
                    this.emit(',');
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_16) throw e_16.error; }
            }
            this.emit('};\n');
            var isExported = util_1.hasModifierFlag(node, ts.ModifierFlags.Export);
            if (isExported)
                this.emit("export {" + name + "};\n");
            if (util_1.hasModifierFlag(node, ts.ModifierFlags.Const)) {
                // By TypeScript semantics, const enums disappear after TS compilation.
                // We still need to generate the runtime value above to make Closure Compiler's type system
                // happy and allow refering to enums from JS code, but we should at least not emit string
                // value mappings.
                return;
            }
            // Emit the reverse mapping of foo[foo.BAR] = 'BAR'; lines for number enums.
            if (enumType === 'number') {
                try {
                    for (var _d = __values(node.members), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var member = _e.value;
                        var memberName = member.name.getText();
                        this.emit(name + "[" + name + "." + memberName + "] = \"" + memberName + "\";\n");
                    }
                }
                catch (e_17_1) { e_17 = { error: e_17_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                    }
                    finally { if (e_17) throw e_17.error; }
                }
            }
            var e_16, _c, e_17, _f;
        };
        return Annotator;
    }(ClosureRewriter));
    /** ExternsWriter generates Closure externs from TypeScript source. */
    var ExternsWriter = /** @class */ (function (_super) {
        __extends(ExternsWriter, _super);
        function ExternsWriter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ExternsWriter.prototype.process = function () {
            var _this = this;
            this.findExternRoots().forEach(function (node) { return _this.visit(node); });
            return this.getOutput();
        };
        ExternsWriter.prototype.ensureSymbolDeclared = function (sym) {
            var decl = this.findExportedDeclaration(sym);
            if (!decl)
                return; // symbol does not need declaring.
            this.error(this.file, "Cannot reference a non-global symbol from an externs: " + sym.name + " declared at " + formatLocation(decl.getSourceFile(), decl.getStart()));
        };
        ExternsWriter.prototype.newTypeTranslator = function (context) {
            var tt = _super.prototype.newTypeTranslator.call(this, context);
            tt.isForExterns = true;
            return tt;
        };
        ExternsWriter.prototype.findExternRoots = function () {
            if (util_1.isDtsFileName(this.file.fileName)) {
                return [this.file];
            }
            return this.file.statements.filter(function (stmt) { return util_1.hasModifierFlag(stmt, ts.ModifierFlags.Ambient); });
        };
        /** visit is the main entry point.  It generates externs from a ts.Node. */
        ExternsWriter.prototype.visit = function (node, namespace) {
            if (namespace === void 0) { namespace = []; }
            switch (node.kind) {
                case ts.SyntaxKind.SourceFile:
                    var sourceFile = node;
                    try {
                        for (var _a = __values(sourceFile.statements), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var stmt = _b.value;
                            this.visit(stmt, namespace);
                        }
                    }
                    catch (e_18_1) { e_18 = { error: e_18_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_18) throw e_18.error; }
                    }
                    break;
                case ts.SyntaxKind.ModuleDeclaration:
                    var decl = node;
                    switch (decl.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            // E.g. "declare namespace foo {"
                            var name_5 = rewriter_1.getIdentifierText(decl.name);
                            if (name_5 === 'global') {
                                // E.g. "declare global { ... }".  Reset to the outer namespace.
                                namespace = [];
                            }
                            else {
                                if (this.isFirstDeclaration(decl)) {
                                    this.emit('/** @const */\n');
                                    this.writeExternsVariable(name_5, namespace, '{}');
                                }
                                namespace = namespace.concat(name_5);
                            }
                            if (decl.body)
                                this.visit(decl.body, namespace);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            // E.g. "declare module 'foo' {" (note the quotes).
                            // We still want to emit externs for this module, but
                            // Closure doesn't really provide a mechanism for
                            // module-scoped externs.  For now, ignore the enclosing
                            // namespace (because this is declaring a top-level module)
                            // and emit into a fake namespace.
                            // Declare the top-level "tsickle_declare_module".
                            this.emit('/** @const */\n');
                            this.writeExternsVariable('tsickle_declare_module', [], '{}');
                            namespace = ['tsickle_declare_module'];
                            // Declare the inner "tsickle_declare_module.foo", if it's not
                            // declared already elsewhere.
                            var importName = decl.name.text;
                            this.emit("// Derived from: declare module \"" + importName + "\"\n");
                            // We also don't care about the actual name of the module ("foo"
                            // in the above example), except that we want it to not conflict.
                            importName = importName.replace(/_/, '__').replace(/[^A-Za-z]/g, '_');
                            if (this.isFirstDeclaration(decl)) {
                                this.emit('/** @const */\n');
                                this.writeExternsVariable(importName, namespace, '{}');
                            }
                            // Declare the contents inside the "tsickle_declare_module.foo".
                            if (decl.body)
                                this.visit(decl.body, namespace.concat(importName));
                            break;
                        default:
                            this.errorUnimplementedKind(decl.name, 'externs generation of namespace');
                    }
                    break;
                case ts.SyntaxKind.ModuleBlock:
                    var block = node;
                    try {
                        for (var _d = __values(block.statements), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var stmt = _e.value;
                            this.visit(stmt, namespace);
                        }
                    }
                    catch (e_19_1) { e_19 = { error: e_19_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                        }
                        finally { if (e_19) throw e_19.error; }
                    }
                    break;
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    var importEquals = node;
                    var localName = rewriter_1.getIdentifierText(importEquals.name);
                    if (localName === 'ng') {
                        this.emit("\n/* Skipping problematic import ng = ...; */\n");
                        break;
                    }
                    if (importEquals.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) {
                        this.emit("\n/* TODO: import " + localName + " = require(...) */\n");
                        break;
                    }
                    var qn = rewriter_1.getEntityNameText(importEquals.moduleReference);
                    // @const so that Closure Compiler understands this is an alias.
                    if (namespace.length === 0)
                        this.emit('/** @const */\n');
                    this.writeExternsVariable(localName, namespace, qn);
                    break;
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                    this.writeExternsType(node, namespace);
                    break;
                case ts.SyntaxKind.FunctionDeclaration:
                    var fnDecl = node;
                    var name_6 = fnDecl.name;
                    if (!name_6) {
                        this.error(fnDecl, 'anonymous function in externs');
                        break;
                    }
                    // Gather up all overloads of this function.
                    var sym = this.mustGetSymbolAtLocation(name_6);
                    var decls = sym.declarations.filter(function (d) { return d.kind === ts.SyntaxKind.FunctionDeclaration; });
                    // Only emit the first declaration of each overloaded function.
                    if (fnDecl !== decls[0])
                        break;
                    var params = this.emitFunctionType(decls);
                    this.writeExternsFunction(name_6, params, namespace);
                    break;
                case ts.SyntaxKind.VariableStatement:
                    try {
                        for (var _g = __values(node.declarationList.declarations), _h = _g.next(); !_h.done; _h = _g.next()) {
                            var decl_1 = _h.value;
                            this.writeExternsVariableDecl(decl_1, namespace);
                        }
                    }
                    catch (e_20_1) { e_20 = { error: e_20_1 }; }
                    finally {
                        try {
                            if (_h && !_h.done && (_j = _g.return)) _j.call(_g);
                        }
                        finally { if (e_20) throw e_20.error; }
                    }
                    break;
                case ts.SyntaxKind.EnumDeclaration:
                    this.writeExternsEnum(node, namespace);
                    break;
                case ts.SyntaxKind.TypeAliasDeclaration:
                    this.writeExternsTypeAlias(node, namespace);
                    break;
                default:
                    this.emit("\n/* TODO: " + ts.SyntaxKind[node.kind] + " in " + namespace.join('.') + " */\n");
                    break;
            }
            var e_18, _c, e_19, _f, e_20, _j;
        };
        /**
         * isFirstDeclaration returns true if decl is the first declaration
         * of its symbol.  E.g. imagine
         *   interface Foo { x: number; }
         *   interface Foo { y: number; }
         * we only want to emit the "@record" for Foo on the first one.
         */
        ExternsWriter.prototype.isFirstDeclaration = function (decl) {
            if (!decl.name)
                return true;
            var sym = this.mustGetSymbolAtLocation(decl.name);
            if (!sym.declarations || sym.declarations.length < 2)
                return true;
            return decl === sym.declarations[0];
        };
        ExternsWriter.prototype.writeExternsType = function (decl, namespace) {
            var name = decl.name;
            if (!name) {
                this.error(decl, 'anonymous type in externs');
                return;
            }
            var typeName = namespace.concat([name.getText()]).join('.');
            if (exports.closureExternsBlacklist.indexOf(typeName) >= 0)
                return;
            if (this.isFirstDeclaration(decl)) {
                var paramNames = [];
                var jsdocTags = [];
                var writeJsDoc = true;
                this.maybeAddHeritageClauses(jsdocTags, decl);
                if (decl.kind === ts.SyntaxKind.ClassDeclaration) {
                    jsdocTags.push({ tagName: 'constructor' });
                    jsdocTags.push({ tagName: 'struct' });
                    var ctors = decl
                        .members.filter(function (m) { return m.kind === ts.SyntaxKind.Constructor; });
                    if (ctors.length) {
                        writeJsDoc = false;
                        var firstCtor = ctors[0];
                        var ctorTags = [{ tagName: 'constructor' }, { tagName: 'struct' }];
                        if (ctors.length > 1) {
                            paramNames = this.emitFunctionType(ctors, ctorTags);
                        }
                        else {
                            paramNames = this.emitFunctionType([firstCtor], ctorTags);
                        }
                    }
                }
                else {
                    jsdocTags.push({ tagName: 'record' });
                    jsdocTags.push({ tagName: 'struct' });
                }
                if (writeJsDoc)
                    this.emit(jsdoc.toString(jsdocTags));
                this.writeExternsFunction(name, paramNames, namespace);
            }
            // Process everything except (MethodSignature|MethodDeclaration|Constructor)
            var methods = new Map();
            try {
                for (var _a = __values(decl.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    switch (member.kind) {
                        case ts.SyntaxKind.PropertySignature:
                        case ts.SyntaxKind.PropertyDeclaration:
                            var prop = member;
                            if (prop.name.kind === ts.SyntaxKind.Identifier) {
                                this.emitJSDocType(prop);
                                if (util_1.hasModifierFlag(prop, ts.ModifierFlags.Static)) {
                                    this.emit("\n" + typeName + "." + prop.name.getText() + ";\n");
                                }
                                else {
                                    this.emit("\n" + typeName + ".prototype." + prop.name.getText() + ";\n");
                                }
                                continue;
                            }
                            // TODO: For now property names other than Identifiers are not handled; e.g.
                            //    interface Foo { "123bar": number }
                            break;
                        case ts.SyntaxKind.MethodSignature:
                        case ts.SyntaxKind.MethodDeclaration:
                            var method = member;
                            var isStatic = util_1.hasModifierFlag(method, ts.ModifierFlags.Static);
                            var methodSignature = method.name.getText() + "$$$" + (isStatic ? 'static' : 'instance');
                            if (methods.has(methodSignature)) {
                                methods.get(methodSignature).push(method);
                            }
                            else {
                                methods.set(methodSignature, [method]);
                            }
                            continue;
                        case ts.SyntaxKind.Constructor:
                            continue; // Handled above.
                        default:
                            // Members can include things like index signatures, for e.g.
                            //   interface Foo { [key: string]: number; }
                            // For now, just skip it.
                            break;
                    }
                    // If we get here, the member wasn't handled in the switch statement.
                    var memberName = namespace;
                    if (member.name) {
                        memberName = memberName.concat([member.name.getText()]);
                    }
                    this.emit("\n/* TODO: " + ts.SyntaxKind[member.kind] + ": " + memberName.join('.') + " */\n");
                }
            }
            catch (e_21_1) { e_21 = { error: e_21_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_21) throw e_21.error; }
            }
            try {
                // Handle method declarations/signatures separately, since we need to deal with overloads.
                for (var _d = __values(Array.from(methods.values())), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var methodVariants = _e.value;
                    var firstMethodVariant = methodVariants[0];
                    var parameterNames = void 0;
                    if (methodVariants.length > 1) {
                        parameterNames = this.emitFunctionType(methodVariants);
                    }
                    else {
                        parameterNames = this.emitFunctionType([firstMethodVariant]);
                    }
                    var methodNamespace = namespace.concat([name.getText()]);
                    // If the method is static, don't add the prototype.
                    if (!util_1.hasModifierFlag(firstMethodVariant, ts.ModifierFlags.Static)) {
                        methodNamespace.push('prototype');
                    }
                    this.writeExternsFunction(firstMethodVariant.name, parameterNames, methodNamespace);
                }
            }
            catch (e_22_1) { e_22 = { error: e_22_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                }
                finally { if (e_22) throw e_22.error; }
            }
            var e_21, _c, e_22, _f;
        };
        ExternsWriter.prototype.writeExternsVariableDecl = function (decl, namespace) {
            if (decl.name.kind === ts.SyntaxKind.Identifier) {
                var name_7 = rewriter_1.getIdentifierText(decl.name);
                if (exports.closureExternsBlacklist.indexOf(name_7) >= 0)
                    return;
                this.emitJSDocType(decl);
                this.emit('\n');
                this.writeExternsVariable(name_7, namespace);
            }
            else {
                this.errorUnimplementedKind(decl.name, 'externs for variable');
            }
        };
        ExternsWriter.prototype.writeExternsVariable = function (name, namespace, value) {
            var qualifiedName = namespace.concat([name]).join('.');
            if (namespace.length === 0)
                this.emit("var ");
            this.emit(qualifiedName);
            if (value)
                this.emit(" = " + value);
            this.emit(';\n');
        };
        ExternsWriter.prototype.writeExternsFunction = function (name, params, namespace) {
            var paramsStr = params.join(', ');
            if (namespace.length > 0) {
                var fqn = namespace.join('.');
                if (name.kind === ts.SyntaxKind.Identifier) {
                    fqn += '.'; // computed names include [ ] in their getText() representation.
                }
                fqn += name.getText();
                this.emit(fqn + " = function(" + paramsStr + ") {};\n");
            }
            else {
                if (name.kind !== ts.SyntaxKind.Identifier) {
                    this.error(name, 'Non-namespaced computed name in externs');
                }
                this.emit("function " + name.getText() + "(" + paramsStr + ") {}\n");
            }
        };
        ExternsWriter.prototype.writeExternsEnum = function (decl, namespace) {
            var name = rewriter_1.getIdentifierText(decl.name);
            this.emit('\n/** @const */\n');
            this.writeExternsVariable(name, namespace, '{}');
            namespace = namespace.concat([name]);
            try {
                for (var _a = __values(decl.members), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var member = _b.value;
                    var memberName = void 0;
                    switch (member.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            memberName = rewriter_1.getIdentifierText(member.name);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            var text = member.name.text;
                            if (isValidClosurePropertyName(text))
                                memberName = text;
                            break;
                        default:
                            break;
                    }
                    if (!memberName) {
                        this.emit("\n/* TODO: " + ts.SyntaxKind[member.name.kind] + ": " + member.name.getText() + " */\n");
                        continue;
                    }
                    this.emit('/** @const {number} */\n');
                    this.writeExternsVariable(memberName, namespace);
                }
            }
            catch (e_23_1) { e_23 = { error: e_23_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_23) throw e_23.error; }
            }
            var e_23, _c;
        };
        ExternsWriter.prototype.writeExternsTypeAlias = function (decl, namespace) {
            var typeStr = this.typeToClosure(decl, undefined, true /* resolveAlias */);
            this.emit("\n/** @typedef {" + typeStr + "} */\n");
            this.writeExternsVariable(rewriter_1.getIdentifierText(decl.name), namespace);
        };
        return ExternsWriter;
    }(ClosureRewriter));
    function isPolymerBehaviorPropertyInCallExpression(pa) {
        var parentParent = pa.parent && pa.parent.parent;
        if (pa.name.kind !== ts.SyntaxKind.Identifier ||
            pa.name.text !== 'behaviors' || !pa.parent || !pa.parent.parent ||
            pa.parent.parent.kind !== ts.SyntaxKind.CallExpression) {
            return false;
        }
        var expr = parentParent.expression;
        return expr.kind === ts.SyntaxKind.Identifier && expr.text === 'Polymer';
    }
    function annotate(typeChecker, file, host, tsHost, tsOpts, sourceMapper) {
        return new Annotator(typeChecker, file, host, tsHost, tsOpts, sourceMapper).annotate();
    }
    exports.annotate = annotate;
    function writeExterns(typeChecker, file, host) {
        return new ExternsWriter(typeChecker, file, host).process();
    }
    exports.writeExterns = writeExterns;
    /** Concatenate all generated externs definitions together into a string. */
    function getGeneratedExterns(externs) {
        var allExterns = exports.EXTERNS_HEADER;
        try {
            for (var _a = __values(Object.keys(externs)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var fileName = _b.value;
                allExterns += "// externs from " + fileName + ":\n";
                allExterns += externs[fileName];
            }
        }
        catch (e_24_1) { e_24 = { error: e_24_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_24) throw e_24.error; }
        }
        return allExterns;
        var e_24, _c;
    }
    exports.getGeneratedExterns = getGeneratedExterns;
    function mergeEmitResults(emitResults) {
        var diagnostics = [];
        var emitSkipped = true;
        var emittedFiles = [];
        var externs = {};
        var modulesManifest = new modules_manifest_1.ModulesManifest();
        try {
            for (var emitResults_1 = __values(emitResults), emitResults_1_1 = emitResults_1.next(); !emitResults_1_1.done; emitResults_1_1 = emitResults_1.next()) {
                var er = emitResults_1_1.value;
                diagnostics.push.apply(diagnostics, __spread(er.diagnostics));
                emitSkipped = emitSkipped || er.emitSkipped;
                emittedFiles.push.apply(emittedFiles, __spread(er.emittedFiles));
                Object.assign(externs, er.externs);
                modulesManifest.addManifest(er.modulesManifest);
            }
        }
        catch (e_25_1) { e_25 = { error: e_25_1 }; }
        finally {
            try {
                if (emitResults_1_1 && !emitResults_1_1.done && (_a = emitResults_1.return)) _a.call(emitResults_1);
            }
            finally { if (e_25) throw e_25.error; }
        }
        return { diagnostics: diagnostics, emitSkipped: emitSkipped, emittedFiles: emittedFiles, externs: externs, modulesManifest: modulesManifest };
        var e_25, _a;
    }
    exports.mergeEmitResults = mergeEmitResults;
    function emitWithTsickle(program, host, tsHost, tsOptions, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        if (customTransformers === void 0) { customTransformers = {}; }
        var tsickleDiagnostics = [];
        var typeChecker = program.getTypeChecker();
        var tsickleSourceTransformers = [];
        if (host.transformTypesToClosure) {
            // Note: tsickle.annotate can also lower decorators in the same run.
            tsickleSourceTransformers.push(transformer_sourcemap_1.createTransformerFromSourceMap(function (sourceFile, sourceMapper) {
                var _a = annotate(typeChecker, sourceFile, host, tsHost, tsOptions, sourceMapper), output = _a.output, diagnostics = _a.diagnostics;
                tsickleDiagnostics.push.apply(tsickleDiagnostics, __spread(diagnostics));
                return output;
            }));
            // Only add @suppress {checkTypes} comments when also adding type annotations.
            tsickleSourceTransformers.push(fileoverview_comment_transformer_1.transformFileoverviewComment);
            tsickleSourceTransformers.push(class_decorator_downlevel_transformer_1.classDecoratorDownlevelTransformer(typeChecker, tsickleDiagnostics));
        }
        else if (host.transformDecorators) {
            tsickleSourceTransformers.push(transformer_sourcemap_1.createTransformerFromSourceMap(function (sourceFile, sourceMapper) {
                var _a = decorator.convertDecorators(typeChecker, sourceFile, sourceMapper), output = _a.output, diagnostics = _a.diagnostics;
                tsickleDiagnostics.push.apply(tsickleDiagnostics, __spread(diagnostics));
                return output;
            }));
            tsickleSourceTransformers.push(class_decorator_downlevel_transformer_1.classDecoratorDownlevelTransformer(typeChecker, tsickleDiagnostics));
        }
        // // For debugging: transformer that just emits the same text.
        // beforeTsTransformers.push(createTransformer(host, typeChecker, (sourceFile, sourceMapper) => {
        //   sourceMapper.addMapping(sourceFile, {position: 0, line: 0, column: 0}, {position: 0, line: 0,
        //   column: 0}, sourceFile.text.length); return sourceFile.text;
        // }));
        var tsickleTransformers = transformer_util_1.createCustomTransformers({ before: tsickleSourceTransformers });
        var tsTransformers = {
            before: __spread((customTransformers.beforeTsickle || []), (tsickleTransformers.before || []).map(function (tf) { return skipTransformForSourceFileIfNeeded(host, tf); }), (customTransformers.beforeTs || [])),
            after: __spread((customTransformers.afterTs || []), (tsickleTransformers.after || []).map(function (tf) { return skipTransformForSourceFileIfNeeded(host, tf); }))
        };
        var writeFileDelegate = writeFile || tsHost.writeFile.bind(tsHost);
        var modulesManifest = new modules_manifest_1.ModulesManifest();
        var writeFileImpl = function (fileName, content, writeByteOrderMark, onError, sourceFiles) {
            if (path.extname(fileName) !== '.map') {
                if (tsOptions.inlineSourceMap) {
                    content = combineInlineSourceMaps(program, fileName, content);
                }
                else {
                    content = source_map_utils_1.removeInlineSourceMap(content);
                }
                content = es5processor.convertCommonJsToGoogModuleIfNeeded(host, modulesManifest, fileName, content);
            }
            else {
                content = combineSourceMaps(program, fileName, content);
            }
            if (host.addDtsClutzAliases && util_1.isDtsFileName(fileName) && sourceFiles) {
                content = addClutzAliases(fileName, content, sourceFiles, typeChecker, host);
            }
            writeFileDelegate(fileName, content, writeByteOrderMark, onError, sourceFiles);
        };
        var _a = program.emit(targetSourceFile, writeFileImpl, cancellationToken, emitOnlyDtsFiles, tsTransformers), tsDiagnostics = _a.diagnostics, emitSkipped = _a.emitSkipped, emittedFiles = _a.emittedFiles;
        var externs = {};
        if (host.transformTypesToClosure) {
            var sourceFiles = targetSourceFile ? [targetSourceFile] : program.getSourceFiles();
            sourceFiles.forEach(function (sf) {
                if (util_1.isDtsFileName(sf.fileName) && host.shouldSkipTsickleProcessing(sf.fileName)) {
                    return;
                }
                var _a = writeExterns(typeChecker, sf, host), output = _a.output, diagnostics = _a.diagnostics;
                if (output) {
                    externs[sf.fileName] = output;
                }
                if (diagnostics) {
                    tsickleDiagnostics.push.apply(tsickleDiagnostics, __spread(diagnostics));
                }
            });
        }
        // All diagnostics (including warnings) are treated as errors.
        // If the host decides to ignore warnings, just discard them.
        // Warnings include stuff like "don't use @type in your jsdoc"; tsickle
        // warns and then fixes up the code to be Closure-compatible anyway.
        tsickleDiagnostics = tsickleDiagnostics.filter(function (d) { return d.category === ts.DiagnosticCategory.Error ||
            !host.shouldIgnoreWarningsForPath(d.file.fileName); });
        return {
            modulesManifest: modulesManifest,
            emitSkipped: emitSkipped,
            emittedFiles: emittedFiles || [],
            diagnostics: __spread(tsDiagnostics, tsickleDiagnostics),
            externs: externs
        };
    }
    exports.emitWithTsickle = emitWithTsickle;
    function areAnyDeclarationsFromSourceFile(declarations, sourceFile) {
        try {
            for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
                var decl = declarations_1_1.value;
                if (decl.getSourceFile() === sourceFile) {
                    return true;
                }
            }
        }
        catch (e_26_1) { e_26 = { error: e_26_1 }; }
        finally {
            try {
                if (declarations_1_1 && !declarations_1_1.done && (_a = declarations_1.return)) _a.call(declarations_1);
            }
            finally { if (e_26) throw e_26.error; }
        }
        return false;
        var e_26, _a;
    }
    function addToMultiMap(map, key, value) {
        var array = map.get(key);
        if (array) {
            array.push(value);
        }
        else {
            map.set(key, [value]);
        }
    }
    /**
     * A tsickle produced declaration file might be consumed be referenced by Clutz
     * produced .d.ts files, which use symbol names based on Closure's internal
     * naming conventions, so we need to provide aliases for all the exported symbols
     * in the Clutz naming convention.
     */
    function addClutzAliases(fileName, dtsFileContent, sourceFiles, typeChecker, host) {
        var reexportsByNamespace = new Map();
        try {
            for (var sourceFiles_1 = __values(sourceFiles), sourceFiles_1_1 = sourceFiles_1.next(); !sourceFiles_1_1.done; sourceFiles_1_1 = sourceFiles_1.next()) {
                var sf = sourceFiles_1_1.value;
                var moduleSymbol = typeChecker.getSymbolAtLocation(sf);
                var moduleExports = moduleSymbol && typeChecker.getExportsOfModule(moduleSymbol);
                if (!moduleExports) {
                    return dtsFileContent;
                }
                // pathToModuleName expects the file name to end in .js
                var jsFileName = fileName.replace('.d.ts', '.js');
                var moduleName = host.pathToModuleName('', jsFileName);
                var clutzModuleName = moduleName.replace(/\./g, '$');
                try {
                    // moduleExports is a ts.Map<ts.Symbol> which is an es6 Map, but has a
                    // different type for no reason
                    for (var moduleExports_1 = __values(moduleExports), moduleExports_1_1 = moduleExports_1.next(); !moduleExports_1_1.done; moduleExports_1_1 = moduleExports_1.next()) {
                        var symbol = moduleExports_1_1.value;
                        // We only want to add clutz aliases in the file the symbol was originally
                        // exported from, not in any files where the symbol was reexported, since
                        // the alias will refer to a symbol that might not be present in the reexporting
                        // file.  If there are no declarations, be conservative and emit the aliases.
                        var declarations = symbol.getDeclarations();
                        if (declarations && !areAnyDeclarationsFromSourceFile(declarations, sf)) {
                            continue;
                        }
                        // Want to alias the symbol to match what clutz would produce, so clutz .d.ts's
                        // can reference symbols from typescript .d.ts's. See examples at:
                        // https://github.com/angular/clutz/tree/master/src/test/java/com/google/javascript/clutz
                        // The first symbol name is that currently produced by clutz, and the second
                        // is what incremental clutz will produce.
                        var reexports = [];
                        reexports.push({
                            namespace: '_.clutz',
                            clutzSymbolName: "module$contents$" + clutzModuleName + "_" + symbol.name,
                            aliasedSymbolName: symbol.name
                        });
                        reexports.push({
                            namespace: '_.clutz.module$exports$' + clutzModuleName,
                            clutzSymbolName: symbol.name,
                            aliasedSymbolName: "module$contents$" + clutzModuleName + "_" + symbol.name
                        });
                        var _a = getGenericTypeParameters(symbol), params = _a.params, paramsWithContraint = _a.paramsWithContraint;
                        if (symbol.flags & ts.SymbolFlags.Class) {
                            // classes need special care to match clutz, which seperates class types into a
                            // type for the static properties and a type for the instance properties
                            reexports.push({
                                namespace: '_.clutz',
                                clutzSymbolName: "module$contents$" + clutzModuleName + "_" + symbol.name + "_Instance",
                                aliasedSymbolName: symbol.name
                            });
                            reexports.push({
                                namespace: '_.clutz.module$exports$' + clutzModuleName,
                                clutzSymbolName: symbol.name + '_Instance',
                                aliasedSymbolName: "module$contents$" + clutzModuleName + "_" + symbol.name
                            });
                        }
                        if (symbol.flags & ts.SymbolFlags.Type || symbol.flags & ts.SymbolFlags.Class) {
                            try {
                                for (var reexports_1 = __values(reexports), reexports_1_1 = reexports_1.next(); !reexports_1_1.done; reexports_1_1 = reexports_1.next()) {
                                    var _b = reexports_1_1.value, namespace = _b.namespace, clutzSymbolName = _b.clutzSymbolName, aliasedSymbolName = _b.aliasedSymbolName;
                                    addToMultiMap(reexportsByNamespace, namespace, "type " + clutzSymbolName + paramsWithContraint + " = " + aliasedSymbolName + params + ";");
                                }
                            }
                            catch (e_27_1) { e_27 = { error: e_27_1 }; }
                            finally {
                                try {
                                    if (reexports_1_1 && !reexports_1_1.done && (_c = reexports_1.return)) _c.call(reexports_1);
                                }
                                finally { if (e_27) throw e_27.error; }
                            }
                        }
                        if (symbol.flags & ts.SymbolFlags.Value || symbol.flags & ts.SymbolFlags.Class) {
                            try {
                                for (var reexports_2 = __values(reexports), reexports_2_1 = reexports_2.next(); !reexports_2_1.done; reexports_2_1 = reexports_2.next()) {
                                    var _d = reexports_2_1.value, namespace = _d.namespace, clutzSymbolName = _d.clutzSymbolName, aliasedSymbolName = _d.aliasedSymbolName;
                                    addToMultiMap(reexportsByNamespace, namespace, "const " + clutzSymbolName + ": typeof " + aliasedSymbolName + ";");
                                }
                            }
                            catch (e_28_1) { e_28 = { error: e_28_1 }; }
                            finally {
                                try {
                                    if (reexports_2_1 && !reexports_2_1.done && (_e = reexports_2.return)) _e.call(reexports_2);
                                }
                                finally { if (e_28) throw e_28.error; }
                            }
                        }
                    }
                }
                catch (e_29_1) { e_29 = { error: e_29_1 }; }
                finally {
                    try {
                        if (moduleExports_1_1 && !moduleExports_1_1.done && (_f = moduleExports_1.return)) _f.call(moduleExports_1);
                    }
                    finally { if (e_29) throw e_29.error; }
                }
            }
        }
        catch (e_30_1) { e_30 = { error: e_30_1 }; }
        finally {
            try {
                if (sourceFiles_1_1 && !sourceFiles_1_1.done && (_g = sourceFiles_1.return)) _g.call(sourceFiles_1);
            }
            finally { if (e_30) throw e_30.error; }
        }
        if (reexportsByNamespace.size) {
            dtsFileContent += 'declare global {\n';
            try {
                for (var reexportsByNamespace_1 = __values(reexportsByNamespace), reexportsByNamespace_1_1 = reexportsByNamespace_1.next(); !reexportsByNamespace_1_1.done; reexportsByNamespace_1_1 = reexportsByNamespace_1.next()) {
                    var _h = __read(reexportsByNamespace_1_1.value, 2), namespace = _h[0], rexps = _h[1];
                    dtsFileContent += "\tnamespace " + namespace + " {\n";
                    try {
                        for (var rexps_1 = __values(rexps), rexps_1_1 = rexps_1.next(); !rexps_1_1.done; rexps_1_1 = rexps_1.next()) {
                            var rexp = rexps_1_1.value;
                            dtsFileContent += "\t\t" + rexp + "\n";
                        }
                    }
                    catch (e_31_1) { e_31 = { error: e_31_1 }; }
                    finally {
                        try {
                            if (rexps_1_1 && !rexps_1_1.done && (_j = rexps_1.return)) _j.call(rexps_1);
                        }
                        finally { if (e_31) throw e_31.error; }
                    }
                    dtsFileContent += '\t}\n';
                }
            }
            catch (e_32_1) { e_32 = { error: e_32_1 }; }
            finally {
                try {
                    if (reexportsByNamespace_1_1 && !reexportsByNamespace_1_1.done && (_k = reexportsByNamespace_1.return)) _k.call(reexportsByNamespace_1);
                }
                finally { if (e_32) throw e_32.error; }
            }
            dtsFileContent += '}\n';
        }
        return dtsFileContent;
        var e_30, _g, e_29, _f, e_27, _c, e_28, _e, e_32, _k, e_31, _j;
    }
    /**
     * Returns 2 strings specifying the generic type arguments for the symbol.  The constrained params
     * include any `T extends foo` arguments, the regular params are just a list of the type symbols,
     * since we need the constraints on the LHS of the alias declaration, but can't have them on the
     * RHS.
     */
    function getGenericTypeParameters(symbol) {
        if (!symbol.declarations) {
            return { params: '', paramsWithContraint: '' };
        }
        // All declarations have to have matching generic types, so we're safe just looking at
        // the first one.
        if (!symbol.declarations[0]) {
            return { params: '', paramsWithContraint: '' };
        }
        var declaration = symbol.declarations[0];
        if ([
            ts.SyntaxKind.FunctionDeclaration, ts.SyntaxKind.ConstructorKeyword,
            ts.SyntaxKind.ClassDeclaration, ts.SyntaxKind.InterfaceDeclaration,
            ts.SyntaxKind.TypeAliasDeclaration
        ].indexOf(declaration.kind) === -1) {
            return { params: '', paramsWithContraint: '' };
        }
        var declarationWithTypeParameters = declaration;
        if (!declarationWithTypeParameters.typeParameters) {
            return { params: '', paramsWithContraint: '' };
        }
        var paramList = [];
        var constrainedParamList = [];
        try {
            for (var _a = __values(declarationWithTypeParameters.typeParameters), _b = _a.next(); !_b.done; _b = _a.next()) {
                var param = _b.value;
                var constrainedParam = param.name.getText();
                if (param.constraint) {
                    constrainedParam += " extends " + param.constraint.getText();
                }
                if (param.default) {
                    constrainedParam += " = " + param.default.getText();
                }
                constrainedParamList.push(constrainedParam);
                paramList.push(param.name.getText());
            }
        }
        catch (e_33_1) { e_33 = { error: e_33_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_33) throw e_33.error; }
        }
        var params = "<" + paramList.join(',') + ">";
        var paramsWithContraint = "<" + constrainedParamList.join(',') + ">";
        return { params: params, paramsWithContraint: paramsWithContraint };
        var e_33, _c;
    }
    function skipTransformForSourceFileIfNeeded(host, delegateFactory) {
        return function (context) {
            var delegate = delegateFactory(context);
            return function (sourceFile) {
                if (host.shouldSkipTsickleProcessing(sourceFile.fileName)) {
                    return sourceFile;
                }
                return delegate(sourceFile);
            };
        };
    }
    function combineInlineSourceMaps(program, filePath, compiledJsWithInlineSourceMap) {
        if (util_1.isDtsFileName(filePath)) {
            return compiledJsWithInlineSourceMap;
        }
        var sourceMapJson = source_map_utils_1.extractInlineSourceMap(compiledJsWithInlineSourceMap);
        compiledJsWithInlineSourceMap = source_map_utils_1.removeInlineSourceMap(compiledJsWithInlineSourceMap);
        var composedSourceMap = combineSourceMaps(program, filePath, sourceMapJson);
        return source_map_utils_1.setInlineSourceMap(compiledJsWithInlineSourceMap, composedSourceMap);
    }
    function combineSourceMaps(program, filePath, tscSourceMapText) {
        var tscSourceMap = source_map_utils_1.parseSourceMap(tscSourceMapText);
        if (tscSourceMap.sourcesContent) {
            // strip incoming sourcemaps from the sources in the sourcemap
            // to reduce the size of the sourcemap.
            tscSourceMap.sourcesContent = tscSourceMap.sourcesContent.map(function (content) {
                if (source_map_utils_1.containsInlineSourceMap(content)) {
                    content = source_map_utils_1.removeInlineSourceMap(content);
                }
                return content;
            });
        }
        var fileDir = path.dirname(filePath);
        var tscSourceMapGenerator;
        try {
            for (var _a = __values(tscSourceMap.sources), _b = _a.next(); !_b.done; _b = _a.next()) {
                var sourceFileName = _b.value;
                var sourceFile = program.getSourceFile(path.resolve(fileDir, sourceFileName));
                if (!sourceFile || !source_map_utils_1.containsInlineSourceMap(sourceFile.text)) {
                    continue;
                }
                var preexistingSourceMapText = source_map_utils_1.extractInlineSourceMap(sourceFile.text);
                if (!tscSourceMapGenerator) {
                    tscSourceMapGenerator = source_map_1.SourceMapGenerator.fromSourceMap(new source_map_1.SourceMapConsumer(tscSourceMap));
                }
                tscSourceMapGenerator.applySourceMap(new source_map_1.SourceMapConsumer(source_map_utils_1.parseSourceMap(preexistingSourceMapText, sourceFileName)));
            }
        }
        catch (e_34_1) { e_34 = { error: e_34_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_34) throw e_34.error; }
        }
        return tscSourceMapGenerator ? tscSourceMapGenerator.toString() : tscSourceMapText;
        var e_34, _c;
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHNpY2tsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy90c2lja2xlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVILDJCQUE2QjtJQUM3Qix5Q0FBK0U7SUFFL0UsMkdBQTJGO0lBQzNGLDJEQUFtRDtJQUNuRCxxREFBbUQ7SUFDbkQsdURBQStDO0lBQy9DLGlHQUFnRjtJQUNoRix5Q0FBaUM7SUFDakMsaUVBQW1EO0lBQ25ELGlEQUF3RjtJQUN4RixpRUFBNEs7SUFDNUssMkVBQXVFO0lBQ3ZFLGlFQUE0RDtJQUM1RCw0REFBb0Q7SUFDcEQsMkNBQW1DO0lBQ25DLHlDQUFzRDtJQUV0RCxpRUFBNEQ7SUFBM0MsNkNBQUEsZUFBZSxDQUFBO0lBd0JoQzs7OztPQUlHO0lBQ1UsUUFBQSxjQUFjLEdBQUcsMkdBSzdCLENBQUM7SUFFRjs7O09BR0c7SUFDUSxRQUFBLHVCQUF1QixHQUFhO1FBQzdDLFNBQVM7UUFDVCxRQUFRO1FBQ1IsUUFBUTtRQUNSLGdFQUFnRTtRQUNoRSx1RUFBdUU7UUFDdkUsa0VBQWtFO1FBQ2xFLHFFQUFxRTtRQUNyRSxtRUFBbUU7UUFDbkUsd0VBQXdFO1FBQ3hFLGdDQUFnQztRQUNoQyxrQkFBa0I7UUFDbEIsUUFBUTtRQUNSLG1CQUFtQjtLQUNwQixDQUFDO0lBRUYsMkJBQWtDLEtBQXNCO1FBQ3RELE1BQU0sQ0FBQyxLQUFLO2FBQ1AsR0FBRyxDQUFDLFVBQUMsQ0FBQztZQUNMLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDNUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ1gsR0FBRyxJQUFJLE1BQU0sR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLElB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Z0JBQ1gsQ0FBQztnQkFDRCxJQUFNLHdCQUF3QixHQUFHLHlDQUFzQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDekUsRUFBRSxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUM7b0JBQzNCLHFCQUFxQixHQUFHLCtCQUFrQixDQUFDLGFBQWEsQ0FBQyxJQUFJLDhCQUFpQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7Z0JBQ2hHLENBQUM7Z0JBQ0QscUJBQXFCLENBQUMsY0FBYyxDQUNoQyxJQUFJLDhCQUFpQixDQUFDLGlDQUFjLENBQUMsd0JBQXdCLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3RGOzs7Ozs7Ozs7UUFDRCxNQUFNLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQzs7SUFDckYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7UmF3U291cmNlTWFwLCBTb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yfSBmcm9tICdzb3VyY2UtbWFwJztcblxuaW1wb3J0IHtjbGFzc0RlY29yYXRvckRvd25sZXZlbFRyYW5zZm9ybWVyfSBmcm9tICcuL2NsYXNzX2RlY29yYXRvcl9kb3dubGV2ZWxfdHJhbnNmb3JtZXInO1xuaW1wb3J0ICogYXMgZGVjb3JhdG9yIGZyb20gJy4vZGVjb3JhdG9yLWFubm90YXRvcic7XG5pbXBvcnQge2hhc0V4cG9ydGluZ0RlY29yYXRvcn0gZnJvbSAnLi9kZWNvcmF0b3JzJztcbmltcG9ydCAqIGFzIGVzNXByb2Nlc3NvciBmcm9tICcuL2VzNXByb2Nlc3Nvcic7XG5pbXBvcnQge3RyYW5zZm9ybUZpbGVvdmVydmlld0NvbW1lbnR9IGZyb20gJy4vZmlsZW92ZXJ2aWV3X2NvbW1lbnRfdHJhbnNmb3JtZXInO1xuaW1wb3J0ICogYXMganNkb2MgZnJvbSAnLi9qc2RvYyc7XG5pbXBvcnQge01vZHVsZXNNYW5pZmVzdH0gZnJvbSAnLi9tb2R1bGVzX21hbmlmZXN0JztcbmltcG9ydCB7Z2V0RW50aXR5TmFtZVRleHQsIGdldElkZW50aWZpZXJUZXh0LCBSZXdyaXRlciwgdW5lc2NhcGVOYW1lfSBmcm9tICcuL3Jld3JpdGVyJztcbmltcG9ydCB7Y29udGFpbnNJbmxpbmVTb3VyY2VNYXAsIGV4dHJhY3RJbmxpbmVTb3VyY2VNYXAsIHBhcnNlU291cmNlTWFwLCByZW1vdmVJbmxpbmVTb3VyY2VNYXAsIHNldElubGluZVNvdXJjZU1hcCwgU291cmNlTWFwcGVyLCBTb3VyY2VQb3NpdGlvbn0gZnJvbSAnLi9zb3VyY2VfbWFwX3V0aWxzJztcbmltcG9ydCB7Y3JlYXRlVHJhbnNmb3JtZXJGcm9tU291cmNlTWFwfSBmcm9tICcuL3RyYW5zZm9ybWVyX3NvdXJjZW1hcCc7XG5pbXBvcnQge2NyZWF0ZUN1c3RvbVRyYW5zZm9ybWVyc30gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCAqIGFzIHR5cGVUcmFuc2xhdG9yIGZyb20gJy4vdHlwZS10cmFuc2xhdG9yJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJy4vdHlwZXNjcmlwdCc7XG5pbXBvcnQge2hhc01vZGlmaWVyRmxhZywgaXNEdHNGaWxlTmFtZX0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IHtGaWxlTWFwLCBNb2R1bGVzTWFuaWZlc3R9IGZyb20gJy4vbW9kdWxlc19tYW5pZmVzdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW5ub3RhdG9ySG9zdCB7XG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCBhIGZ1bmN0aW9uIHRoYXQgbG9ncyBhbiBpbnRlcm5hbCB3YXJuaW5nLlxuICAgKiBUaGVzZSB3YXJuaW5ncyBhcmUgbm90IGFjdGlvbmFibGUgYnkgYW4gZW5kIHVzZXIgYW5kIHNob3VsZCBiZSBoaWRkZW5cbiAgICogYnkgZGVmYXVsdC5cbiAgICovXG4gIGxvZ1dhcm5pbmc/OiAod2FybmluZzogdHMuRGlhZ25vc3RpYykgPT4gdm9pZDtcbiAgcGF0aFRvTW9kdWxlTmFtZTogKGNvbnRleHQ6IHN0cmluZywgaW1wb3J0UGF0aDogc3RyaW5nKSA9PiBzdHJpbmc7XG4gIC8qKlxuICAgKiBJZiB0cnVlLCBjb252ZXJ0IGV2ZXJ5IHR5cGUgdG8gdGhlIENsb3N1cmUgez99IHR5cGUsIHdoaWNoIG1lYW5zXG4gICAqIFwiZG9uJ3QgY2hlY2sgdHlwZXNcIi5cbiAgICovXG4gIHVudHlwZWQ/OiBib29sZWFuO1xuICAvKiogSWYgcHJvdmlkZWQsIGEgc2V0IG9mIHBhdGhzIHdob3NlIHR5cGVzIHNob3VsZCBhbHdheXMgZ2VuZXJhdGUgYXMgez99LiAqL1xuICB0eXBlQmxhY2tMaXN0UGF0aHM/OiBTZXQ8c3RyaW5nPjtcbiAgLyoqXG4gICAqIENvbnZlcnQgc2hvcnRoYW5kIFwiL2luZGV4XCIgaW1wb3J0cyB0byBmdWxsIHBhdGggKGluY2x1ZGUgdGhlIFwiL2luZGV4XCIpLlxuICAgKiBBbm5vdGF0aW9uIHdpbGwgYmUgc2xvd2VyIGJlY2F1c2UgZXZlcnkgaW1wb3J0IG11c3QgYmUgcmVzb2x2ZWQuXG4gICAqL1xuICBjb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRoZSBoZWFkZXIgdG8gYmUgdXNlZCBpbiBnZW5lcmF0ZWQgZXh0ZXJucy4gIFRoaXMgaXMgbm90IGluY2x1ZGVkIGluIHRoZVxuICogb3V0cHV0IG9mIGFubm90YXRlKCkgYmVjYXVzZSBhbm5vdGF0ZSgpIHdvcmtzIG9uZSBmaWxlIGF0IGEgdGltZSwgYW5kXG4gKiB0eXBpY2FsbHkgeW91IGNyZWF0ZSBvbmUgZXh0ZXJucyBmaWxlIGZyb20gdGhlIGVudGlyZSBjb21waWxhdGlvbiB1bml0LlxuICovXG5leHBvcnQgY29uc3QgRVhURVJOU19IRUFERVIgPSBgLyoqXG4gKiBAZXh0ZXJuc1xuICogQHN1cHByZXNzIHtkdXBsaWNhdGUsY2hlY2tUeXBlc31cbiAqL1xuLy8gTk9URTogZ2VuZXJhdGVkIGJ5IHRzaWNrbGUsIGRvIG5vdCBlZGl0LlxuYDtcblxuLyoqXG4gKiBTeW1ib2xzIHRoYXQgYXJlIGFscmVhZHkgZGVjbGFyZWQgYXMgZXh0ZXJucyBpbiBDbG9zdXJlLCB0aGF0IHNob3VsZFxuICogYmUgYXZvaWRlZCBieSB0c2lja2xlJ3MgXCJkZWNsYXJlIC4uLlwiID0+IGV4dGVybnMuanMgY29udmVyc2lvbi5cbiAqL1xuZXhwb3J0IGxldCBjbG9zdXJlRXh0ZXJuc0JsYWNrbGlzdDogc3RyaW5nW10gPSBbXG4gICdleHBvcnRzJyxcbiAgJ2dsb2JhbCcsXG4gICdtb2R1bGUnLFxuICAvLyBFcnJvckNvbnN0cnVjdG9yIGlzIHRoZSBpbnRlcmZhY2Ugb2YgdGhlIEVycm9yIG9iamVjdCBpdHNlbGYuXG4gIC8vIHRzaWNrbGUgZGV0ZWN0cyB0aGF0IHRoaXMgaXMgcGFydCBvZiB0aGUgVHlwZVNjcmlwdCBzdGFuZGFyZCBsaWJyYXJ5XG4gIC8vIGFuZCBhc3N1bWVzIGl0J3MgcGFydCBvZiB0aGUgQ2xvc3VyZSBzdGFuZGFyZCBsaWJyYXJ5LCBidXQgdGhpc1xuICAvLyBhc3N1bXB0aW9uIGlzIHdyb25nIGZvciBFcnJvckNvbnN0cnVjdG9yLiAgVG8gcHJvcGVybHkgaGFuZGxlIHRoaXNcbiAgLy8gd2UnZCBzb21laG93IG5lZWQgdG8gbWFwIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgRXJyb3JDb25zdHJ1Y3RvclxuICAvLyBpbnRlcmZhY2UgaW50byBwcm9wZXJ0aWVzIG9uIENsb3N1cmUncyBFcnJvciBvYmplY3QsIGJ1dCBmb3Igbm93IGl0J3NcbiAgLy8gc2ltcGxlciB0byBqdXN0IGJsYWNrbGlzdCBpdC5cbiAgJ0Vycm9yQ29uc3RydWN0b3InLFxuICAnU3ltYm9sJyxcbiAgJ1dvcmtlckdsb2JhbFNjb3BlJyxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREaWFnbm9zdGljcyhkaWFnczogdHMuRGlhZ25vc3RpY1tdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGRpYWdzXG4gICAgICAubWFwKChkKSA9PiB7XG4gICAgICAgIGxldCByZXMgPSB0cy5EaWFnbm9zdGljQ2F0ZWdvcnlbZC5jYXRlZ29yeV07XG4gICAgICAgIGlmIChkLmZpbGUpIHtcbiAgICAgICAgICByZXMgKz0gJyBhdCAnICsgZm9ybWF0TG9jYXRpb24oZC5maWxlLCBkLnN0YXJ0KSArICc6JztcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gJyAnICsgdHMuZmxhdHRlbkRpYWdub3N0aWNNZXNzYWdlVGV4dChkLm1lc3NhZ2VUZXh0LCAnXFxuJyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KVxuICAgICAgLmpvaW4oJ1xcbicpO1xufVxuXG4vKiogUmV0dXJucyBhIGZpbGVOYW1lOmxpbmU6Y29sdW1uIHN0cmluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBmaWxlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdExvY2F0aW9uKHNmOiB0cy5Tb3VyY2VGaWxlLCBzdGFydDogbnVtYmVyfHVuZGVmaW5lZCkge1xuICBsZXQgcmVzID0gc2YuZmlsZU5hbWU7XG4gIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge2xpbmUsIGNoYXJhY3Rlcn0gPSBzZi5nZXRMaW5lQW5kQ2hhcmFjdGVyT2ZQb3NpdGlvbihzdGFydCk7XG4gICAgcmVzICs9ICc6JyArIChsaW5lICsgMSkgKyAnOicgKyAoY2hhcmFjdGVyICsgMSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqIEByZXR1cm4gdHJ1ZSBpZiBub2RlIGhhcyB0aGUgc3BlY2lmaWVkIG1vZGlmaWVyIGZsYWcgc2V0LiAqL1xuZnVuY3Rpb24gaXNBbWJpZW50KG5vZGU6IHRzLk5vZGUpOiBib29sZWFuIHtcbiAgbGV0IGN1cnJlbnQ6IHRzLk5vZGV8dW5kZWZpbmVkID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKGN1cnJlbnQsIHRzLk1vZGlmaWVyRmxhZ3MuQW1iaWVudCkpIHJldHVybiB0cnVlO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVHlwZVNjcmlwdCBhbGxvd3MgeW91IHRvIHdyaXRlIGlkZW50aWZpZXJzIHF1b3RlZCwgbGlrZTpcbiAqICAgaW50ZXJmYWNlIEZvbyB7XG4gKiAgICAgJ2Jhcic6IHN0cmluZztcbiAqICAgICAnY29tcGxleCBuYW1lJzogc3RyaW5nO1xuICogICB9XG4gKiAgIEZvby5iYXI7ICAvLyBva1xuICogICBGb29bJ2JhciddICAvLyBva1xuICogICBGb29bJ2NvbXBsZXggbmFtZSddICAvLyBva1xuICpcbiAqIEluIENsb3N1cmUtbGFuZCwgd2Ugd2FudCBpZGVudGlmeSB0aGF0IHRoZSBsZWdhbCBuYW1lICdiYXInIGNhbiBiZWNvbWUgYW5cbiAqIG9yZGluYXJ5IGZpZWxkLCBidXQgd2UgbmVlZCB0byBza2lwIHN0cmluZ3MgbGlrZSAnY29tcGxleCBuYW1lJy5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWUobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEluIGxvY2FsIGV4cGVyaW1lbnRhdGlvbiwgaXQgYXBwZWFycyB0aGF0IHJlc2VydmVkIHdvcmRzIGxpa2UgJ3ZhcicgYW5kXG4gIC8vICdpZicgYXJlIGxlZ2FsIEpTIGFuZCBzdGlsbCBhY2NlcHRlZCBieSBDbG9zdXJlLlxuICByZXR1cm4gL15bYS16QS1aX11bYS16QS1aMC05X10qJC8udGVzdChuYW1lKTtcbn1cblxuLyoqIFJldHVybnMgdGhlIENsb3N1cmUgbmFtZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciwgc3BlY2lhbC1jYXNpbmcgZGVzdHJ1Y3R1cmluZy4gKi9cbmZ1bmN0aW9uIGdldFBhcmFtZXRlck5hbWUocGFyYW06IHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uLCBpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgc3dpdGNoIChwYXJhbS5uYW1lLmtpbmQpIHtcbiAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgIGxldCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQocGFyYW0ubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICAgIC8vIFR5cGVTY3JpcHQgYWxsb3dzIHBhcmFtZXRlcnMgbmFtZWQgXCJhcmd1bWVudHNcIiwgYnV0IENsb3N1cmVcbiAgICAgIC8vIGRpc2FsbG93cyB0aGlzLCBldmVuIGluIGV4dGVybnMuXG4gICAgICBpZiAobmFtZSA9PT0gJ2FyZ3VtZW50cycpIG5hbWUgPSAndHNpY2tsZV9hcmd1bWVudHMnO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgY2FzZSB0cy5TeW50YXhLaW5kLkFycmF5QmluZGluZ1BhdHRlcm46XG4gICAgY2FzZSB0cy5TeW50YXhLaW5kLk9iamVjdEJpbmRpbmdQYXR0ZXJuOlxuICAgICAgLy8gQ2xvc3VyZSBjcmFzaGVzIGlmIHlvdSBwdXQgYSBiaW5kaW5nIHBhdHRlcm4gaW4gdGhlIGV4dGVybnMuXG4gICAgICAvLyBBdm9pZCB0aGlzIGJ5IGp1c3QgZ2VuZXJhdGluZyBhbiB1bnVzZWQgbmFtZTsgdGhlIG5hbWUgaXNcbiAgICAgIC8vIGlnbm9yZWQgYW55d2F5LlxuICAgICAgcmV0dXJuIGBfXyR7aW5kZXh9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVGhlIGFib3ZlIGxpc3Qgb2Yga2luZHMgaXMgZXhoYXVzdGl2ZS4gIHBhcmFtLm5hbWUgaXMgJ25ldmVyJyBhdCB0aGlzIHBvaW50LlxuICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGFyYW0ubmFtZSBhcyB0cy5Ob2RlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgZnVuY3Rpb24gcGFyYW1ldGVyIGtpbmQ6ICR7dHMuU3ludGF4S2luZFtwYXJhbU5hbWUua2luZF19YCk7XG4gIH1cbn1cblxuLyoqIEZsYWdzIHRoYXQgZGVjbGFyZSBhIGZpZWxkIG9mIHRoZSBzYW1lIG5hbWUgaWYgc2V0IG9uIGEgY3RvciBwYXJhbWV0ZXIuICovXG5jb25zdCBGSUVMRF9ERUNMQVJBVElPTl9NT0RJRklFUlM6IHRzLk1vZGlmaWVyRmxhZ3MgPSB0cy5Nb2RpZmllckZsYWdzLlByaXZhdGUgfFxuICAgIHRzLk1vZGlmaWVyRmxhZ3MuUHJvdGVjdGVkIHwgdHMuTW9kaWZpZXJGbGFncy5QdWJsaWMgfCB0cy5Nb2RpZmllckZsYWdzLlJlYWRvbmx5O1xuXG4vKipcbiAqIEEgc3ltYm9sIGNvbWJpbmVkIHdpdGggaXRzIG5hbWUgaW4gdGhlIGxvY2FsIGZpbGUuIFN5bWJvbHMgY2FuIGJlIHJlbmFtZWQgb24gaW1wb3J0IG9yIGV4cG9ydFxuICogKGBpbXBvcnQge0ZvbyBhcyBCYXJ9YCkuXG4gKi9cbmludGVyZmFjZSBOYW1lZFN5bWJvbCB7XG4gIC8qKiBUaGUgbG9jYWwgbmFtZSBvZiB0aGUgc3ltYm9sIChuYW1lZCBgQmFyYCBpbiB0aGUgZXhhbXBsZSBhYm92ZSkuICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqIFRoZSBzeW1ib2wgKG5hbWVkIGBGb29gIGluIHRoZSBleGFtcGxlIGFib3ZlKS4gKi9cbiAgc3ltOiB0cy5TeW1ib2w7XG59XG5cbi8qKlxuICogQSBSZXdyaXRlciBzdWJjbGFzcyB0aGF0IGFkZHMgVHNpY2tsZS1zcGVjaWZpYyAoQ2xvc3VyZSB0cmFuc2xhdGlvbikgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBPbmUgUmV3cml0ZXIgc3ViY2xhc3MgbWFuYWdlcyAudHMgPT4gLnRzK0Nsb3N1cmUgdHJhbnNsYXRpb24uXG4gKiBBbm90aGVyIFJld3JpdGVyIHN1YmNsYXNzIG1hbmFnZXMgLnRzID0+IGV4dGVybnMgdHJhbnNsYXRpb24uXG4gKi9cbmFic3RyYWN0IGNsYXNzIENsb3N1cmVSZXdyaXRlciBleHRlbmRzIFJld3JpdGVyIHtcbiAgLyoqXG4gICAqIEEgbWFwcGluZyBvZiBhbGlhc2VzIGZvciBzeW1ib2xzIGluIHRoZSBjdXJyZW50IGZpbGUsIHVzZWQgd2hlbiBlbWl0dGluZyB0eXBlcy5cbiAgICogVHlwZVNjcmlwdCBlbWl0cyBpbXBvcnRlZCBzeW1ib2xzIHdpdGggdW5wcmVkaWN0YWJsZSBwcmVmaXhlcy4gVG8gZ2VuZXJhdGUgY29ycmVjdCB0eXBlXG4gICAqIGFubm90YXRpb25zLCB0c2lja2xlIGNyZWF0ZXMgaXRzIG93biBhbGlhc2VzIGZvciB0eXBlcywgYW5kIHJlZ2lzdGVycyB0aGVtIGluIHRoaXMgbWFwIChzZWVcbiAgICogYGVtaXRJbXBvcnREZWNsYXJhdGlvbmAgYW5kIGBmb3J3YXJkRGVjbGFyZSgpYCBiZWxvdykuIFRoZSBhbGlhc2VzIGFyZSB0aGVuIHVzZWQgd2hlbiBlbWl0dGluZ1xuICAgKiB0eXBlcy5cbiAgICovXG4gIHN5bWJvbHNUb0FsaWFzZWROYW1lcyA9IG5ldyBNYXA8dHMuU3ltYm9sLCBzdHJpbmc+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcm90ZWN0ZWQgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBmaWxlOiB0cy5Tb3VyY2VGaWxlLCBwcm90ZWN0ZWQgaG9zdDogQW5ub3RhdG9ySG9zdCxcbiAgICAgIHNvdXJjZU1hcHBlcj86IFNvdXJjZU1hcHBlcikge1xuICAgIHN1cGVyKGZpbGUsIHNvdXJjZU1hcHBlcik7XG4gIH1cblxuICAvKiogRmluZHMgYW4gZXhwb3J0ZWQgKGkuZS4gbm90IGdsb2JhbCkgZGVjbGFyYXRpb24gZm9yIHRoZSBnaXZlbiBzeW1ib2wuICovXG4gIHByb3RlY3RlZCBmaW5kRXhwb3J0ZWREZWNsYXJhdGlvbihzeW06IHRzLlN5bWJvbCk6IHRzLkRlY2xhcmF0aW9ufHVuZGVmaW5lZCB7XG4gICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiBpdCdzIHVuY2xlYXIgd2hlbiBhIHN5bWJvbCB3b3VsZG4ndCBoYXZlIGEgZGVjbGFyYXRpb24sIG1heWJlIGp1c3QgZm9yXG4gICAgLy8gc29tZSBidWlsdGlucyAoZS5nLiBTeW1ib2wpP1xuICAgIGlmICghc3ltLmRlY2xhcmF0aW9ucyB8fCBzeW0uZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBBIHN5bWJvbCBkZWNsYXJlZCBpbiB0aGlzIGZpbGUgZG9lcyBub3QgbmVlZCB0byBiZSBpbXBvcnRlZC5cbiAgICBpZiAoc3ltLmRlY2xhcmF0aW9ucy5zb21lKGQgPT4gZC5nZXRTb3VyY2VGaWxlKCkgPT09IHRoaXMuZmlsZSkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAvLyBGaW5kIGFuIGV4cG9ydGVkIGRlY2xhcmF0aW9uLlxuICAgIC8vIEJlY2F1c2UgdHNpY2tsZSBydW5zIHdpdGggdGhlIC0tZGVjbGFyYXRpb24gZmxhZywgYWxsIHR5cGVzIHJlZmVyZW5jZWQgZnJvbSBleHBvcnRlZCB0eXBlc1xuICAgIC8vIG11c3QgYmUgZXhwb3J0ZWQsIHRvbywgc28gdGhlcmUgbXVzdCBlaXRoZXIgYmUgc29tZSBkZWNsYXJhdGlvbiB0aGF0IGlzIGV4cG9ydGVkLCBvciB0aGVcbiAgICAvLyBzeW1ib2wgaXMgYWN0dWFsbHkgYSBnbG9iYWwgZGVjbGFyYXRpb24gKGRlY2xhcmVkIGluIGEgc2NyaXB0IGZpbGUsIG5vdCBhIG1vZHVsZSkuXG4gICAgY29uc3QgZGVjbCA9IHN5bS5kZWNsYXJhdGlvbnMuZmluZChkID0+IHtcbiAgICAgIC8vIENoZWNrIGZvciBFeHBvcnQgfCBEZWZhdWx0IChkZWZhdWx0IGJlaW5nIGEgZGVmYXVsdCBleHBvcnQpLlxuICAgICAgaWYgKCFoYXNNb2RpZmllckZsYWcoZCwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnREZWZhdWx0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRXhjbHVkZSBzeW1ib2xzIGRlY2xhcmVkIGluIGBkZWNsYXJlIGdsb2JhbCB7Li4ufWAgYmxvY2tzLCB0aGV5IGFyZSBnbG9iYWwgYW5kIGRvbid0IG5lZWRcbiAgICAgIC8vIGltcG9ydHMuXG4gICAgICBsZXQgY3VycmVudDogdHMuTm9kZXx1bmRlZmluZWQgPSBkO1xuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuR2xvYmFsQXVnbWVudGF0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWNsO1xuICB9XG5cbiAgLyoqIENhbGxlZCB0byBlbnN1cmUgdGhhdCBhIHN5bWJvbCBpcyBkZWNsYXJlZCBpbiB0aGUgY3VycmVudCBmaWxlJ3Mgc2NvcGUuICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBlbnN1cmVTeW1ib2xEZWNsYXJlZChzeW06IHRzLlN5bWJvbCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHMuU3ltYm9sIGF0IGEgbG9jYXRpb24gb3IgdGhyb3cuXG4gICAqIFRoZSBUeXBlU2NyaXB0IEFQSSBjYW4gcmV0dXJuIHVuZGVmaW5lZCB3aGVuIGZldGNoaW5nIGEgc3ltYm9sLCBidXRcbiAgICogaW4gbWFueSBjb250ZXh0cyB3ZSBrbm93IGl0IHdvbid0IChlLmcuIG91ciBpbnB1dCBpcyBhbHJlYWR5IHR5cGUtY2hlY2tlZCkuXG4gICAqL1xuICBtdXN0R2V0U3ltYm9sQXRMb2NhdGlvbihub2RlOiB0cy5Ob2RlKTogdHMuU3ltYm9sIHtcbiAgICBjb25zdCBzeW0gPSB0aGlzLnR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZSk7XG4gICAgaWYgKCFzeW0pIHRocm93IG5ldyBFcnJvcignbm8gc3ltYm9sJyk7XG4gICAgcmV0dXJuIHN5bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGVtaXR0bmcgdGhlIGpzZG9jIGZvciBtZXRob2RzLCBpbmNsdWRpbmcgb3ZlcmxvYWRzLlxuICAgKiBJZiBvdmVybG9hZGVkLCBtZXJnZXMgdGhlIHNpZ25hdHVyZXMgaW4gdGhlIGxpc3Qgb2YgU2lnbmF0dXJlRGVjbGFyYXRpb25zIGludG8gYSBzaW5nbGUganNkb2MuXG4gICAqIC0gVG90YWwgbnVtYmVyIG9mIHBhcmFtZXRlcnMgd2lsbCBiZSB0aGUgbWF4aW11bSBjb3VudCBmb3VuZCBhY3Jvc3MgYWxsIHZhcmlhbnRzLlxuICAgKiAtIERpZmZlcmVudCBuYW1lcyBhdCB0aGUgc2FtZSBwYXJhbWV0ZXIgaW5kZXggd2lsbCBiZSBqb2luZWQgd2l0aCBcIl9vcl9cIlxuICAgKiAtIFZhcmlhYmxlIGFyZ3MgKC4uLnR5cGVbXSBpbiBUeXBlU2NyaXB0KSB3aWxsIGJlIG91dHB1dCBhcyBcIi4uLnR5cGVcIixcbiAgICogICAgZXhjZXB0IGlmIGZvdW5kIGF0IHRoZSBzYW1lIGluZGV4IGFzIGFub3RoZXIgYXJndW1lbnQuXG4gICAqIEBwYXJhbSAgZm5EZWNscyBQYXNzID4gMSBkZWNsYXJhdGlvbiBmb3Igb3ZlcmxvYWRzIG9mIHNhbWUgbmFtZVxuICAgKiBAcmV0dXJuIFRoZSBsaXN0IG9mIHBhcmFtZXRlciBuYW1lcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGVtaXQgdGhlIGFjdHVhbFxuICAgKiAgICBmdW5jdGlvbiBzdGF0ZW1lbnQ7IGZvciBvdmVybG9hZHMsIG5hbWUgd2lsbCBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgKi9cbiAgZW1pdEZ1bmN0aW9uVHlwZShmbkRlY2xzOiB0cy5TaWduYXR1cmVEZWNsYXJhdGlvbltdLCBleHRyYVRhZ3M6IGpzZG9jLlRhZ1tdID0gW10pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgdHlwZUNoZWNrZXIgPSB0aGlzLnR5cGVDaGVja2VyO1xuICAgIGNvbnN0IG5ld0RvYyA9IGV4dHJhVGFncztcbiAgICBjb25zdCBsZW5zID0gZm5EZWNscy5tYXAoZm5EZWNsID0+IGZuRGVjbC5wYXJhbWV0ZXJzLmxlbmd0aCk7XG4gICAgY29uc3QgbWluQXJnc0NvdW50ID0gTWF0aC5taW4oLi4ubGVucyk7XG4gICAgY29uc3QgbWF4QXJnc0NvdW50ID0gTWF0aC5tYXgoLi4ubGVucyk7XG4gICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IGZuRGVjbHMuZmluZChkID0+IGQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3RvcikgIT09IHVuZGVmaW5lZDtcbiAgICAvLyBGb3IgZWFjaCBwYXJhbWV0ZXIgaW5kZXggaSwgcGFyYW1UYWdzW2ldIGlzIGFuIGFycmF5IG9mIHBhcmFtZXRlcnNcbiAgICAvLyB0aGF0IGNhbiBiZSBmb3VuZCBhdCBpbmRleCBpLiAgRS5nLlxuICAgIC8vICAgIGZ1bmN0aW9uIGZvbyh4OiBzdHJpbmcpXG4gICAgLy8gICAgZnVuY3Rpb24gZm9vKHk6IG51bWJlciwgejogc3RyaW5nKVxuICAgIC8vIHRoZW4gcGFyYW1UYWdzWzBdID0gW2luZm8gYWJvdXQgeCwgaW5mbyBhYm91dCB5XS5cbiAgICBjb25zdCBwYXJhbVRhZ3M6IGpzZG9jLlRhZ1tdW10gPSBbXTtcbiAgICBjb25zdCByZXR1cm5UYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBmbkRlY2wgb2YgZm5EZWNscykge1xuICAgICAgLy8gQ29uc3RydWN0IHRoZSBKU0RvYyBjb21tZW50IGJ5IHJlYWRpbmcgdGhlIGV4aXN0aW5nIEpTRG9jLCBpZlxuICAgICAgLy8gYW55LCBhbmQgbWVyZ2luZyBpdCB3aXRoIHRoZSBrbm93biB0eXBlcyBvZiB0aGUgZnVuY3Rpb25cbiAgICAgIC8vIHBhcmFtZXRlcnMgYW5kIHJldHVybiB0eXBlLlxuICAgICAgY29uc3QgZG9jVGFncyA9IHRoaXMuZ2V0SlNEb2MoZm5EZWNsKSB8fCBbXTtcblxuICAgICAgLy8gQ29weSBhbGwgdGhlIHRhZ3Mgb3RoZXIgdGhhbiBAcGFyYW0vQHJldHVybiBpbnRvIHRoZSBuZXdcbiAgICAgIC8vIEpTRG9jIHdpdGhvdXQgYW55IGNoYW5nZTsgQHBhcmFtL0ByZXR1cm4gYXJlIGhhbmRsZWQgc3BlY2lhbGx5LlxuICAgICAgLy8gVE9ETzogdGhlcmUgbWF5IGJlIHByb2JsZW1zIGlmIGFuIGFubm90YXRpb24gZG9lc24ndCBhcHBseSB0byBhbGwgb3ZlcmxvYWRzO1xuICAgICAgLy8gaXMgaXQgd29ydGggY2hlY2tpbmcgZm9yIHRoaXMgYW5kIGVycm9yaW5nP1xuICAgICAgZm9yIChjb25zdCB0YWcgb2YgZG9jVGFncykge1xuICAgICAgICBpZiAodGFnLnRhZ05hbWUgPT09ICdwYXJhbScgfHwgdGFnLnRhZ05hbWUgPT09ICdyZXR1cm4nKSBjb250aW51ZTtcbiAgICAgICAgbmV3RG9jLnB1c2godGFnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIEBhYnN0cmFjdCBvbiBcImFic3RyYWN0XCIgZGVjbGFyYXRpb25zLlxuICAgICAgaWYgKGhhc01vZGlmaWVyRmxhZyhmbkRlY2wsIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpKSB7XG4gICAgICAgIG5ld0RvYy5wdXNoKHt0YWdOYW1lOiAnYWJzdHJhY3QnfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhbnkgQHRlbXBsYXRlIHRhZ3MuXG4gICAgICAvLyBNdWx0aXBsZSBkZWNsYXJhdGlvbnMgd2l0aCB0aGUgc2FtZSB0ZW1wbGF0ZSB2YXJpYWJsZSBuYW1lcyBzaG91bGQgd29yazpcbiAgICAgIC8vIHRoZSBkZWNsYXJhdGlvbnMgZ2V0IHR1cm5lZCBpbnRvIHVuaW9uIHR5cGVzLCBhbmQgQ2xvc3VyZSBDb21waWxlciB3aWxsIG5lZWRcbiAgICAgIC8vIHRvIGZpbmQgYSB1bmlvbiB3aGVyZSBhbGwgdHlwZSBhcmd1bWVudHMgYXJlIHNhdGlzZmllZC5cbiAgICAgIGlmIChmbkRlY2wudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0cCBvZiBmbkRlY2wudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICB0eXBlUGFyYW1ldGVyTmFtZXMuYWRkKGdldElkZW50aWZpZXJUZXh0KHRwLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgdGhlIHBhcmFtZXRlcnMgaW50byBhIHNpbmdsZSBsaXN0IG9mIG1lcmdlZCBuYW1lcyBhbmQgbGlzdCBvZiB0eXBlc1xuICAgICAgY29uc3Qgc2lnID0gdHlwZUNoZWNrZXIuZ2V0U2lnbmF0dXJlRnJvbURlY2xhcmF0aW9uKGZuRGVjbCk7XG4gICAgICBpZiAoIXNpZykgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSAke2ZuRGVjbC5uYW1lfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWcuZGVjbGFyYXRpb24ucGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJhbU5vZGUgPSBzaWcuZGVjbGFyYXRpb24ucGFyYW1ldGVyc1tpXTtcblxuICAgICAgICBjb25zdCBuYW1lID0gZ2V0UGFyYW1ldGVyTmFtZShwYXJhbU5vZGUsIGkpO1xuICAgICAgICBjb25zdCBpc1RoaXNQYXJhbSA9IG5hbWUgPT09ICd0aGlzJztcblxuICAgICAgICBjb25zdCBuZXdUYWc6IGpzZG9jLlRhZyA9IHtcbiAgICAgICAgICB0YWdOYW1lOiBpc1RoaXNQYXJhbSA/ICd0aGlzJyA6ICdwYXJhbScsXG4gICAgICAgICAgb3B0aW9uYWw6IHBhcmFtTm9kZS5pbml0aWFsaXplciAhPT0gdW5kZWZpbmVkIHx8IHBhcmFtTm9kZS5xdWVzdGlvblRva2VuICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgcGFyYW1ldGVyTmFtZTogaXNUaGlzUGFyYW0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCB0eXBlID0gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24ocGFyYW1Ob2RlKTtcbiAgICAgICAgaWYgKHBhcmFtTm9kZS5kb3REb3REb3RUb2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VGFnLnJlc3RQYXJhbSA9IHRydWU7XG4gICAgICAgICAgLy8gSW4gVHlwZVNjcmlwdCB5b3Ugd3JpdGUgXCIuLi54OiBudW1iZXJbXVwiLCBidXQgaW4gQ2xvc3VyZVxuICAgICAgICAgIC8vIHlvdSBkb24ndCB3cml0ZSB0aGUgYXJyYXk6IFwiQHBhcmFtIHsuLi5udW1iZXJ9IHhcIi4gIFVud3JhcFxuICAgICAgICAgIC8vIHRoZSBBcnJheTw+IHdyYXBwZXIuXG4gICAgICAgICAgY29uc3QgdHlwZVJlZiA9IHR5cGUgYXMgdHMuVHlwZVJlZmVyZW5jZTtcbiAgICAgICAgICBpZiAoIXR5cGVSZWYudHlwZUFyZ3VtZW50cykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlc3QgcGFyYW0nKTtcbiAgICAgICAgICB0eXBlID0gdHlwZVJlZi50eXBlQXJndW1lbnRzIVswXTtcbiAgICAgICAgfVxuICAgICAgICBuZXdUYWcudHlwZSA9IHRoaXMudHlwZVRvQ2xvc3VyZShmbkRlY2wsIHR5cGUpO1xuXG4gICAgICAgIGZvciAoY29uc3Qge3RhZ05hbWUsIHBhcmFtZXRlck5hbWUsIHRleHR9IG9mIGRvY1RhZ3MpIHtcbiAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3BhcmFtJyAmJiBwYXJhbWV0ZXJOYW1lID09PSBuZXdUYWcucGFyYW1ldGVyTmFtZSkge1xuICAgICAgICAgICAgbmV3VGFnLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1UYWdzW2ldKSBwYXJhbVRhZ3MucHVzaChbXSk7XG4gICAgICAgIHBhcmFtVGFnc1tpXS5wdXNoKG5ld1RhZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0eXBlLlxuICAgICAgaWYgKCFpc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJldFR5cGUgPSB0eXBlQ2hlY2tlci5nZXRSZXR1cm5UeXBlT2ZTaWduYXR1cmUoc2lnKTtcbiAgICAgICAgY29uc3QgcmV0VHlwZVN0cmluZzogc3RyaW5nID0gdGhpcy50eXBlVG9DbG9zdXJlKGZuRGVjbCwgcmV0VHlwZSk7XG4gICAgICAgIGxldCByZXR1cm5Eb2M6IHN0cmluZ3x1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qge3RhZ05hbWUsIHRleHR9IG9mIGRvY1RhZ3MpIHtcbiAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3JldHVybicpIHtcbiAgICAgICAgICAgIHJldHVybkRvYyA9IHRleHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuVGFncy5wdXNoKHtcbiAgICAgICAgICB0YWdOYW1lOiAncmV0dXJuJyxcbiAgICAgICAgICB0eXBlOiByZXRUeXBlU3RyaW5nLFxuICAgICAgICAgIHRleHQ6IHJldHVybkRvYyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJOYW1lcy5zaXplID4gMCkge1xuICAgICAgbmV3RG9jLnB1c2goe3RhZ05hbWU6ICd0ZW1wbGF0ZScsIHRleHQ6IEFycmF5LmZyb20odHlwZVBhcmFtZXRlck5hbWVzLnZhbHVlcygpKS5qb2luKCcsICcpfSk7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgdGhlIEpTRG9jIHRhZ3MgZm9yIGVhY2ggb3ZlcmxvYWRlZCBwYXJhbWV0ZXIuXG4gICAgLy8gRW5zdXJlIGVhY2ggcGFyYW1ldGVyIGhhcyBhIHVuaXF1ZSBuYW1lOyB0aGUgbWVyZ2luZyBwcm9jZXNzIGNhbiBvdGhlcndpc2VcbiAgICAvLyBhY2NpZGVudGFsbHkgZ2VuZXJhdGUgdGhlIHNhbWUgcGFyYW1ldGVyIG5hbWUgdHdpY2UuXG4gICAgY29uc3QgcGFyYW1OYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgZm91bmRPcHRpb25hbCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXJnc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcmFtVGFnID0ganNkb2MubWVyZ2UocGFyYW1UYWdzW2ldKTtcbiAgICAgIGlmIChwYXJhbU5hbWVzLmhhcyhwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lKSkge1xuICAgICAgICBwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lICs9IGkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHBhcmFtTmFtZXMuYWRkKHBhcmFtVGFnLnBhcmFtZXRlck5hbWUpO1xuICAgICAgLy8gSWYgdGhlIHRhZyBpcyBvcHRpb25hbCwgbWFyayBwYXJhbWV0ZXJzIGZvbGxvd2luZyBvcHRpb25hbCBhcyBvcHRpb25hbCxcbiAgICAgIC8vIGV2ZW4gaWYgdGhleSBhcmUgbm90LCBzaW5jZSBDbG9zdXJlIHJlc3RyaWN0cyB0aGlzLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMjMxNFxuICAgICAgaWYgKCFwYXJhbVRhZy5yZXN0UGFyYW0gJiYgKHBhcmFtVGFnLm9wdGlvbmFsIHx8IGZvdW5kT3B0aW9uYWwgfHwgaSA+PSBtaW5BcmdzQ291bnQpKSB7XG4gICAgICAgIGZvdW5kT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICBwYXJhbVRhZy5vcHRpb25hbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBuZXdEb2MucHVzaChwYXJhbVRhZyk7XG4gICAgICBpZiAocGFyYW1UYWcucmVzdFBhcmFtKSB7XG4gICAgICAgIC8vIENhbm5vdCBoYXZlIGFueSBwYXJhbWV0ZXJzIGFmdGVyIGEgcmVzdCBwYXJhbS5cbiAgICAgICAgLy8gSnVzdCBkdW1wIHRoZSByZW1haW5pbmcgcGFyYW1ldGVycy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgdGhlIEpTRG9jIHRhZ3MgZm9yIGVhY2ggb3ZlcmxvYWRlZCByZXR1cm4uXG4gICAgaWYgKCFpc0NvbnN0cnVjdG9yKSB7XG4gICAgICBuZXdEb2MucHVzaChqc2RvYy5tZXJnZShyZXR1cm5UYWdzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdcXG4nICsganNkb2MudG9TdHJpbmcobmV3RG9jKSk7XG4gICAgcmV0dXJuIG5ld0RvYy5maWx0ZXIodCA9PiB0LnRhZ05hbWUgPT09ICdwYXJhbScpLm1hcCh0ID0+IHQucGFyYW1ldGVyTmFtZSEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyBleGlzdGluZyBjb21tZW50LlxuICAgKi9cbiAgZ2V0SlNEb2Mobm9kZTogdHMuTm9kZSk6IGpzZG9jLlRhZ1tdfG51bGwge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldEZ1bGxUZXh0KCk7XG4gICAgY29uc3QgY29tbWVudHMgPSB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlcyh0ZXh0LCAwKTtcblxuICAgIGlmICghY29tbWVudHMgfHwgY29tbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIFdlIG5lZWQgdG8gc2VhcmNoIGJhY2t3YXJkcyBmb3IgdGhlIGZpcnN0IEpTRG9jIGNvbW1lbnQgdG8gYXZvaWQgaWdub3Jpbmcgc3VjaCB3aGVuIGFub3RoZXJcbiAgICAvLyBjb2RlLWxldmVsIGNvbW1lbnQgaXMgYmV0d2VlbiB0aGF0IGNvbW1lbnQgYW5kIHRoZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiAoc2VlXG4gICAgLy8gdGVzdGZpbGVzL2RvY19wYXJhbXMgZm9yIGFuIGV4YW1wbGUpLlxuICAgIGxldCBkb2NSZWxhdGl2ZVBvcyA9IDA7XG4gICAgbGV0IHBhcnNlZDoganNkb2MuUGFyc2VkSlNEb2NDb21tZW50fG51bGwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSBjb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3Qge3BvcywgZW5kfSA9IGNvbW1lbnRzW2ldO1xuICAgICAgLy8gZW5kIGlzIHJlbGF0aXZlIHdpdGhpbiBub2RlLmdldEZ1bGxUZXh0KCksIGFkZCBnZXRGdWxsU3RhcnQgdG8gb2J0YWluIGNvb3JkaW5hdGVzIHRoYXQgYXJlXG4gICAgICAvLyBjb21wYXJhYmxlIHRvIG5vZGUgcG9zaXRpb25zLlxuICAgICAgY29uc3QgZG9jUmVsYXRpdmVFbmQgPSBlbmQgKyBub2RlLmdldEZ1bGxTdGFydCgpO1xuICAgICAgaWYgKGRvY1JlbGF0aXZlRW5kIDw9IHRoaXMuZmlsZS5nZXRTdGFydCgpICYmXG4gICAgICAgICAgdGhpcy5maWxlLnRleHQuc3Vic3RyaW5nKGRvY1JlbGF0aXZlRW5kKS5zdGFydHNXaXRoKCdcXG5cXG4nKSkge1xuICAgICAgICAvLyBUaGlzIGNvbW1lbnQgaXMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIGFuZCB0aGVyZSdzIGFuIGVtcHR5IGxpbmUgYmV0d2VlbiB0aGVcbiAgICAgICAgLy8gY29tbWVudCBhbmQgdGhpcyBub2RlLCBpdCdzIGEgXCJkZXRhY2hlZCBjb21tZW50XCIuIFRoYXQgbWVhbnMgd2Ugc2hvdWxkIHRyZWF0IGl0IGFzIGFcbiAgICAgICAgLy8gZmlsZS1sZXZlbCBjb21tZW50LCBub3QgYXR0YWNoZWQgdG8gdGhpcyBjb2RlIG5vZGUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb21tZW50ID0gdGV4dC5zdWJzdHJpbmcocG9zLCBlbmQpO1xuICAgICAgcGFyc2VkID0ganNkb2MucGFyc2UoY29tbWVudCk7XG4gICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgIGRvY1JlbGF0aXZlUG9zID0gbm9kZS5nZXRGdWxsU3RhcnQoKSArIHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKHBhcnNlZC53YXJuaW5ncykge1xuICAgICAgY29uc3Qgc3RhcnQgPSBkb2NSZWxhdGl2ZVBvcztcbiAgICAgIHRoaXMuZGlhZ25vc3RpY3MucHVzaCh7XG4gICAgICAgIGZpbGU6IHRoaXMuZmlsZSxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGxlbmd0aDogbm9kZS5nZXRTdGFydCgpIC0gc3RhcnQsXG4gICAgICAgIG1lc3NhZ2VUZXh0OiBwYXJzZWQud2FybmluZ3Muam9pbignXFxuJyksXG4gICAgICAgIGNhdGVnb3J5OiB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuV2FybmluZyxcbiAgICAgICAgY29kZTogMCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkLnRhZ3M7XG4gIH1cblxuICBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlKGRvY1RhZ3M6IGpzZG9jLlRhZ1tdLCBkZWNsOiBIYXNUeXBlUGFyYW1ldGVycykge1xuICAgIGlmICghZGVjbC50eXBlUGFyYW1ldGVycykgcmV0dXJuO1xuICAgIC8vIENsb3N1cmUgZG9lcyBub3Qgc3VwcG9ydCB0ZW1wbGF0ZSBjb25zdHJhaW50cyAoVCBleHRlbmRzIFgpLlxuICAgIGRvY1RhZ3MucHVzaCh7XG4gICAgICB0YWdOYW1lOiAndGVtcGxhdGUnLFxuICAgICAgdGV4dDogZGVjbC50eXBlUGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIC5tYXAodHAgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHRwLmNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdcXG4vLyB1bnN1cHBvcnRlZDogdGVtcGxhdGUgY29uc3RyYWludHMuJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SWRlbnRpZmllclRleHQodHAubmFtZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKVxuICAgIH0pO1xuICB9XG5cbiAgbWF5YmVBZGRIZXJpdGFnZUNsYXVzZXMoXG4gICAgICBkb2NUYWdzOiBqc2RvYy5UYWdbXSwgZGVjbDogdHMuQ2xhc3NMaWtlRGVjbGFyYXRpb258dHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pIHtcbiAgICBpZiAoIWRlY2wuaGVyaXRhZ2VDbGF1c2VzKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBoZXJpdGFnZSBvZiBkZWNsLmhlcml0YWdlQ2xhdXNlcyEpIHtcbiAgICAgIGlmICghaGVyaXRhZ2UudHlwZXMpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgaXNDbGFzcyA9IGRlY2wua2luZCA9PT0gdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uO1xuICAgICAgaWYgKGlzQ2xhc3MgJiYgaGVyaXRhZ2UudG9rZW4gIT09IHRzLlN5bnRheEtpbmQuSW1wbGVtZW50c0tleXdvcmQgJiYgIWlzQW1iaWVudChkZWNsKSkge1xuICAgICAgICAvLyBJZiBhIGNsYXNzIGhhcyBcImV4dGVuZHMgRm9vXCIsIHRoYXQgaXMgcHJlc2VydmVkIGluIHRoZSBFUzYgb3V0cHV0XG4gICAgICAgIC8vIGFuZCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLiAgQnV0IGlmIGl0IGhhcyBcImltcGxlbWVudHMgRm9vXCIsXG4gICAgICAgIC8vIHRoYXQgaXMgYSBUUy1zcGVjaWZpYyB0aGluZyBhbmQgd2UgbmVlZCB0byB0cmFuc2xhdGUgaXQgdG8gdGhlXG4gICAgICAgIC8vIHRoZSBDbG9zdXJlIFwiQGltcGxlbWVudHMge0Zvb31cIi5cbiAgICAgICAgLy8gSG93ZXZlciBmb3IgYW1iaWVudCBkZWNsYXJhdGlvbnMsIHdlIG9ubHkgZW1pdCBleHRlcm5zLCBhbmQgaW4gdGhvc2Ugd2UgZG8gbmVlZCB0b1xuICAgICAgICAvLyBhZGQgXCJAZXh0ZW5kcyB7Rm9vfVwiIGFzIHRoZXkgdXNlIEVTNSBzeW50YXguXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbXBsIG9mIGhlcml0YWdlLnR5cGVzKSB7XG4gICAgICAgIGxldCB0YWdOYW1lID0gZGVjbC5raW5kID09PSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uID8gJ2V4dGVuZHMnIDogJ2ltcGxlbWVudHMnO1xuXG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IEBpbXBsZW1lbnRzIGFuIGludGVyZmFjZSwgbm90IGEgY2xhc3MuXG4gICAgICAgIC8vIEJ1dCBpdCdzIGZpbmUgdG8gdHJhbnNsYXRlIFRTIFwiaW1wbGVtZW50cyBDbGFzc1wiIGludG8gQ2xvc3VyZVxuICAgICAgICAvLyBcIkBleHRlbmRzIHtDbGFzc31cIiBiZWNhdXNlIHRoaXMgaXMganVzdCBhIHR5cGUgaGludC5cbiAgICAgICAgY29uc3QgdHlwZUNoZWNrZXIgPSB0aGlzLnR5cGVDaGVja2VyO1xuICAgICAgICBjb25zdCBzeW0gPSB0aGlzLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKGltcGwuZXhwcmVzc2lvbik7XG4gICAgICAgIGxldCBhbGlhczogdHMuU3ltYm9sID0gc3ltO1xuICAgICAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVHlwZUFsaWFzKSB7XG4gICAgICAgICAgLy8gSXQncyBpbXBsZW1lbnRpbmcgYSB0eXBlIGFsaWFzLiAgRm9sbG93IHRoZSB0eXBlIGFsaWFzIGJhY2tcbiAgICAgICAgICAvLyB0byB0aGUgb3JpZ2luYWwgc3ltYm9sIHRvIGNoZWNrIHdoZXRoZXIgaXQncyBhIHR5cGUgb3IgYSB2YWx1ZS5cbiAgICAgICAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlQ2hlY2tlci5nZXREZWNsYXJlZFR5cGVPZlN5bWJvbChzeW0pO1xuICAgICAgICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IGNsZWFyIHdoZW4gdGhpcyBjYW4gaGFwcGVuLCBidXQgaWYgaXQgZG9lcyBhbGwgd2VcbiAgICAgICAgICAgIC8vIGRvIGlzIGZhaWwgdG8gZW1pdCB0aGUgQGltcGxlbWVudHMsIHdoaWNoIGlzbid0IHNvIGhhcm1mdWwuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWxpYXMgPSB0eXBlLnN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpYXMuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgICAgIGFsaWFzID0gdHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChhbGlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVRyYW5zbGF0b3IgPSB0aGlzLm5ld1R5cGVUcmFuc2xhdG9yKGltcGwuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICh0eXBlVHJhbnNsYXRvci5pc0JsYWNrTGlzdGVkKGFsaWFzKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGlhcy5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkNsYXNzKSB7XG4gICAgICAgICAgaWYgKCFpc0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGNsYXNzZXMgY2FuIGV4dGVuZCBjbGFzc2VzIGluIFRTLiBJZ25vcmluZyB0aGUgaGVyaXRhZ2UgY2xhdXNlIHNob3VsZCBiZSBzYWZlLFxuICAgICAgICAgICAgLy8gYXMgaW50ZXJmYWNlcyBhcmUgQHJlY29yZCBhbnl3YXksIHNvIHNob3VsZCBwcmV2ZW50IHByb3BlcnR5IGRpc2FtYmlndWF0aW9uLlxuXG4gICAgICAgICAgICAvLyBQcm9ibGVtOiB2YWxpZGF0ZSB0aGF0IG1ldGhvZHMgYXJlIHRoZXJlP1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhZ05hbWUgPSAnZXh0ZW5kcyc7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpYXMuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkge1xuICAgICAgICAgIC8vIElmIHRoZSBzeW1ib2wgd2FzIGFscmVhZHkgaW4gdGhlIHZhbHVlIG5hbWVzcGFjZSwgdGhlbiBpdCB3aWxsXG4gICAgICAgICAgLy8gbm90IGJlIGEgdHlwZSBpbiB0aGUgQ2xvc3VyZSBvdXRwdXQgKGJlY2F1c2UgQ2xvc3VyZSBjb2xsYXBzZXNcbiAgICAgICAgICAvLyB0aGUgdHlwZSBhbmQgdmFsdWUgbmFtZXNwYWNlcykuICBKdXN0IGlnbm9yZSB0aGUgaW1wbGVtZW50cy5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0eXBlVG9DbG9zdXJlIGluY2x1ZGVzIG51bGxhYmlsaXR5IG1vZGlmaWVycywgc28gY2FsbCBzeW1ib2xUb1N0cmluZyBkaXJlY3RseSBoZXJlLlxuICAgICAgICBkb2NUYWdzLnB1c2goe3RhZ05hbWUsIHR5cGU6IHR5cGVUcmFuc2xhdG9yLnN5bWJvbFRvU3RyaW5nKHN5bSwgdHJ1ZSl9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogRW1pdHMgYSB0eXBlIGFubm90YXRpb24gaW4gSlNEb2MsIG9yIHs/fSBpZiB0aGUgdHlwZSBpcyB1bmF2YWlsYWJsZS4gKi9cbiAgZW1pdEpTRG9jVHlwZShub2RlOiB0cy5Ob2RlLCBhZGRpdGlvbmFsRG9jVGFnPzogc3RyaW5nLCB0eXBlPzogdHMuVHlwZSkge1xuICAgIHRoaXMuZW1pdCgnIC8qKicpO1xuICAgIGlmIChhZGRpdGlvbmFsRG9jVGFnKSB7XG4gICAgICB0aGlzLmVtaXQoJyAnICsgYWRkaXRpb25hbERvY1RhZyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChgIEB0eXBlIHske3RoaXMudHlwZVRvQ2xvc3VyZShub2RlLCB0eXBlKX19ICovYCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIFR5cGVTY3JpcHQgdHMuVHlwZSBpbnRvIHRoZSBlcXVpdmFsZW50IENsb3N1cmUgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRleHQgVGhlIHRzLk5vZGUgY29udGFpbmluZyB0aGUgdHlwZSByZWZlcmVuY2U7IHVzZWQgZm9yIHJlc29sdmluZyBzeW1ib2xzXG4gICAqICAgICBpbiBjb250ZXh0LlxuICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byB0cmFuc2xhdGU7IGlmIG5vdCBwcm92aWRlZCwgdGhlIE5vZGUncyB0eXBlIHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIHJlc29sdmVBbGlhcyBJZiB0cnVlLCBkbyBub3QgZW1pdCBhbGlhc2VzIGFzIHRoZWlyIHN5bWJvbCwgYnV0IHJhdGhlciBhcyB0aGUgcmVzb2x2ZWRcbiAgICogICAgIHR5cGUgdW5kZXJseWluZyB0aGUgYWxpYXMuIFRoaXMgc2hvdWxkIGJlIHRydWUgb25seSB3aGVuIGVtaXR0aW5nIHRoZSB0eXBlZGVmIGl0c2VsZi5cbiAgICovXG4gIHR5cGVUb0Nsb3N1cmUoY29udGV4dDogdHMuTm9kZSwgdHlwZT86IHRzLlR5cGUsIHJlc29sdmVBbGlhcz86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmhvc3QudW50eXBlZCkge1xuICAgICAgcmV0dXJuICc/JztcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlQ2hlY2tlciA9IHRoaXMudHlwZUNoZWNrZXI7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0eXBlID0gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24oY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5ld1R5cGVUcmFuc2xhdG9yKGNvbnRleHQpLnRyYW5zbGF0ZSh0eXBlLCByZXNvbHZlQWxpYXMpO1xuICB9XG5cbiAgbmV3VHlwZVRyYW5zbGF0b3IoY29udGV4dDogdHMuTm9kZSkge1xuICAgIGNvbnN0IHRyYW5zbGF0b3IgPSBuZXcgdHlwZVRyYW5zbGF0b3IuVHlwZVRyYW5zbGF0b3IoXG4gICAgICAgIHRoaXMudHlwZUNoZWNrZXIsIGNvbnRleHQsIHRoaXMuaG9zdC50eXBlQmxhY2tMaXN0UGF0aHMsIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLFxuICAgICAgICAoc3ltOiB0cy5TeW1ib2wpID0+IHRoaXMuZW5zdXJlU3ltYm9sRGVjbGFyZWQoc3ltKSk7XG4gICAgdHJhbnNsYXRvci53YXJuID0gbXNnID0+IHRoaXMuZGVidWdXYXJuKGNvbnRleHQsIG1zZyk7XG4gICAgcmV0dXJuIHRyYW5zbGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogZGVidWcgbG9ncyBhIGRlYnVnIHdhcm5pbmcuICBUaGVzZSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjYXNlc1xuICAgKiB3aGVyZSB0c2lja2xlIGlzIG1ha2luZyBhIHF1ZXN0aW9uYWJsZSBqdWRnZW1lbnQgYWJvdXQgd2hhdCB0byBkby5cbiAgICogQnkgZGVmYXVsdCwgdHNpY2tsZSBkb2VzIG5vdCByZXBvcnQgYW55IHdhcm5pbmdzIHRvIHRoZSBjYWxsZXIsXG4gICAqIGFuZCB3YXJuaW5ncyBhcmUgaGlkZGVuIGJlaGluZCBhIGRlYnVnIGZsYWcsIGFzIHdhcm5pbmdzIGFyZSBvbmx5XG4gICAqIGZvciB0c2lja2xlIHRvIGRlYnVnIGl0c2VsZi5cbiAgICovXG4gIGRlYnVnV2Fybihub2RlOiB0cy5Ob2RlLCBtZXNzYWdlVGV4dDogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmhvc3QubG9nV2FybmluZykgcmV0dXJuO1xuICAgIC8vIFVzZSBhIHRzLkRpYWdub3NpYyBzbyB0aGF0IHRoZSB3YXJuaW5nIGluY2x1ZGVzIGNvbnRleHQgYW5kIGZpbGUgb2ZmZXRzLlxuICAgIGNvbnN0IGRpYWdub3N0aWM6IHRzLkRpYWdub3N0aWMgPSB7XG4gICAgICBmaWxlOiB0aGlzLmZpbGUsXG4gICAgICBzdGFydDogbm9kZS5nZXRTdGFydCgpLFxuICAgICAgbGVuZ3RoOiBub2RlLmdldEVuZCgpIC0gbm9kZS5nZXRTdGFydCgpLFxuICAgICAgbWVzc2FnZVRleHQsXG4gICAgICBjYXRlZ29yeTogdHMuRGlhZ25vc3RpY0NhdGVnb3J5Lldhcm5pbmcsXG4gICAgICBjb2RlOiAwLFxuICAgIH07XG4gICAgdGhpcy5ob3N0LmxvZ1dhcm5pbmcoZGlhZ25vc3RpYyk7XG4gIH1cbn1cblxudHlwZSBIYXNUeXBlUGFyYW1ldGVycyA9XG4gICAgdHMuSW50ZXJmYWNlRGVjbGFyYXRpb258dHMuQ2xhc3NMaWtlRGVjbGFyYXRpb258dHMuVHlwZUFsaWFzRGVjbGFyYXRpb258dHMuU2lnbmF0dXJlRGVjbGFyYXRpb247XG5cbi8vIE1hdGNoZXMgY29tbW9uIGV4dGVuc2lvbnMgb2YgVHlwZVNjcmlwdCBpbnB1dCBmaWxlbmFtZXNcbmNvbnN0IGV4dGVuc2lvbiA9IC8oXFwudHN8XFwuZFxcLnRzfFxcLmpzfFxcLmpzeHxcXC50c3gpJC87XG5cbmNvbnN0IEZJTEVPVkVSVklFV19DT01NRU5UUzogUmVhZG9ubHlTZXQ8c3RyaW5nPiA9XG4gICAgbmV3IFNldChbJ2ZpbGVvdmVydmlldycsICdleHRlcm5zJywgJ21vZE5hbWUnLCAnbW9kcycsICdwaW50b21vZHVsZSddKTtcblxuLyoqIEFubm90YXRvciB0cmFuc2xhdGVzIGEgLnRzIHRvIGEgLnRzIHdpdGggQ2xvc3VyZSBhbm5vdGF0aW9ucy4gKi9cbmNsYXNzIEFubm90YXRvciBleHRlbmRzIENsb3N1cmVSZXdyaXRlciB7XG4gIC8qKiBFeHBvcnRlZCBzeW1ib2wgbmFtZXMgdGhhdCBoYXZlIGJlZW4gZ2VuZXJhdGVkIGJ5IGV4cGFuZGluZyBhbiBcImV4cG9ydCAqIGZyb20gLi4uXCIuICovXG4gIHByaXZhdGUgZ2VuZXJhdGVkRXhwb3J0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAvKiogRGVjb3JhdG9yQ2xhc3NWaXNpdG9yIHdoZW4gbG93ZXJpbmcgZGVjb3JhdG9ycyB3aGlsZSBjbG9zdXJlIGFubm90YXRpbmcgKi9cbiAgcHJpdmF0ZSBjdXJyZW50RGVjb3JhdG9yQ29udmVydGVyOiBkZWNvcmF0b3IuRGVjb3JhdG9yQ2xhc3NWaXNpdG9yfHVuZGVmaW5lZDtcbiAgLyoqIENvbGxlY3Rpb24gb2YgSWRlbnRpZmllcnMgdXNlZCBpbiBhbiBgaW1wb3J0IHtmb299YCBkZWNsYXJhdGlvbiB3aXRoIHRoZWlyIFN5bWJvbCAqL1xuICBwcml2YXRlIGltcG9ydGVkTmFtZXM6IEFycmF5PHtuYW1lOiB0cy5JZGVudGlmaWVyLCBkZWNsYXJhdGlvbk5hbWVzOiB0cy5JZGVudGlmaWVyW119PiA9IFtdO1xuXG4gIHByaXZhdGUgdGVtcGxhdGVTcGFuU3RhY2tDb3VudCA9IDA7XG4gIHByaXZhdGUgcG9seW1lckJlaGF2aW9yU3RhY2tDb3VudCA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBzZXQgb2YgbW9kdWxlIHN5bWJvbHMgZm9yd2FyZCBkZWNsYXJlZCBpbiB0aGUgbG9jYWwgbmFtZXNwYWNlICh3aXRoIGdvb2cuZm9yd2FyRGVjbGFyZSkuXG4gICAqXG4gICAqIFN5bWJvbHMgbm90IGltcG9ydGVkIG11c3QgYmUgZGVjbGFyZWQsIHdoaWNoIGlzIGRvbmUgYnkgYWRkaW5nIGZvcndhcmQgZGVjbGFyZXMgdG9cbiAgICogYGV4dHJhSW1wb3J0c2AgYmVsb3cuXG4gICAqL1xuICBwcml2YXRlIGZvcndhcmREZWNsYXJlZE1vZHVsZXMgPSBuZXcgU2V0PHRzLlN5bWJvbD4oKTtcbiAgcHJpdmF0ZSBleHRyYURlY2xhcmVzID0gJyc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIGZpbGU6IHRzLlNvdXJjZUZpbGUsIGhvc3Q6IEFubm90YXRvckhvc3QsXG4gICAgICBwcml2YXRlIHRzSG9zdD86IHRzLk1vZHVsZVJlc29sdXRpb25Ib3N0LCBwcml2YXRlIHRzT3B0cz86IHRzLkNvbXBpbGVyT3B0aW9ucyxcbiAgICAgIHNvdXJjZU1hcHBlcj86IFNvdXJjZU1hcHBlcikge1xuICAgIHN1cGVyKHR5cGVDaGVja2VyLCBmaWxlLCBob3N0LCBzb3VyY2VNYXBwZXIpO1xuICB9XG5cbiAgYW5ub3RhdGUoKToge291dHB1dDogc3RyaW5nLCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdfSB7XG4gICAgdGhpcy52aXNpdCh0aGlzLmZpbGUpO1xuICAgIHJldHVybiB0aGlzLmdldE91dHB1dCh0aGlzLmV4dHJhRGVjbGFyZXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGVuc3VyZVN5bWJvbERlY2xhcmVkKHN5bTogdHMuU3ltYm9sKSB7XG4gICAgY29uc3QgZGVjbCA9IHRoaXMuZmluZEV4cG9ydGVkRGVjbGFyYXRpb24oc3ltKTtcbiAgICBpZiAoIWRlY2wpIHJldHVybjtcblxuICAgIC8vIEFjdHVhbGx5IGltcG9ydCB0aGUgc3ltYm9sLlxuICAgIGNvbnN0IHNmID0gZGVjbC5nZXRTb3VyY2VGaWxlKCk7XG4gICAgY29uc3QgbW9kdWxlU3ltYm9sID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHNmKTtcbiAgICBpZiAoIW1vZHVsZVN5bWJvbCkge1xuICAgICAgcmV0dXJuOyAgLy8gQSBzb3VyY2UgZmlsZSBtaWdodCBub3QgaGF2ZSBhIHN5bWJvbCBpZiBpdCdzIG5vdCBhIG1vZHVsZSAobm8gRVM2IGltL2V4cG9ydHMpLlxuICAgIH1cbiAgICAvLyBBbHJlYWR5IGltcG9ydGVkP1xuICAgIGlmICh0aGlzLmZvcndhcmREZWNsYXJlZE1vZHVsZXMuaGFzKG1vZHVsZVN5bWJvbCkpIHJldHVybjtcbiAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IHRoaXMgc2hvdWxkIHBvc3NpYmx5IHVzZSBmaWxlTmFtZVRvTW9kdWxlSWQuXG4gICAgY29uc3QgdGV4dCA9IHRoaXMuZ2V0Rm9yd2FyZERlY2xhcmVUZXh0KHNmLmZpbGVOYW1lLCBtb2R1bGVTeW1ib2wpO1xuICAgIHRoaXMuZXh0cmFEZWNsYXJlcyArPSB0ZXh0O1xuICB9XG5cbiAgZ2V0RXhwb3J0RGVjbGFyYXRpb25OYW1lcyhub2RlOiB0cy5Ob2RlKTogdHMuSWRlbnRpZmllcltdIHtcbiAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlU3RhdGVtZW50OlxuICAgICAgICBjb25zdCB2YXJEZWNsID0gbm9kZSBhcyB0cy5WYXJpYWJsZVN0YXRlbWVudDtcbiAgICAgICAgcmV0dXJuIHZhckRlY2wuZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9ucy5tYXAoXG4gICAgICAgICAgICAoZCkgPT4gdGhpcy5nZXRFeHBvcnREZWNsYXJhdGlvbk5hbWVzKGQpWzBdKTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Nb2R1bGVEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgZGVjbCA9IG5vZGUgYXMgdHMuTmFtZWREZWNsYXJhdGlvbjtcbiAgICAgICAgaWYgKCFkZWNsLm5hbWUgfHwgZGVjbC5uYW1lLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZGVjbC5uYW1lXTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQWxpYXNEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgdHlwZUFsaWFzID0gbm9kZSBhcyB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIFt0eXBlQWxpYXMubmFtZV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5lcnJvcihcbiAgICAgICAgbm9kZSwgYHVuc3VwcG9ydGVkIGV4cG9ydCBkZWNsYXJhdGlvbiAke3RzLlN5bnRheEtpbmRbbm9kZS5raW5kXX06ICR7bm9kZS5nZXRUZXh0KCl9YCk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIEVTNiBleHBvcnQgZm9yIHRoZSBhbWJpZW50IGRlY2xhcmF0aW9uIGJlaGluZCBub2RlLCBpZiBpdCBpcyBpbmRlZWQgZXhwb3J0ZWQuXG4gICAqL1xuICBtYXliZUVtaXRBbWJpZW50RGVjbGFyYXRpb25FeHBvcnQobm9kZTogdHMuTm9kZSkge1xuICAgIC8vIEluIFR5cGVTY3JpcHQsIGBleHBvcnQgZGVjbGFyZWAgc2ltcGx5IGdlbmVyYXRlcyBubyBjb2RlIGluIHRoZSBleHBvcnRpbmcgbW9kdWxlLCBidXQgZG9lc1xuICAgIC8vIGdlbmVyYXRlIGEgcmVndWxhciBpbXBvcnQgaW4gdGhlIGltcG9ydGluZyBtb2R1bGUuXG4gICAgLy8gRm9yIENsb3N1cmUgQ29tcGlsZXIsIHN1Y2ggZGVjbGFyYXRpb25zIG11c3Qgc3RpbGwgYmUgZXhwb3J0ZWQsIHNvIHRoYXQgaW1wb3J0aW5nIGNvZGUgaW5cbiAgICAvLyBvdGhlciBtb2R1bGVzIGNhbiByZWZlcmVuY2UgdGhlbS4gQmVjYXVzZSB0c2lja2xlIGdlbmVyYXRlcyBnbG9iYWwgc3ltYm9scyBmb3Igc3VjaCB0eXBlcyxcbiAgICAvLyB0aGUgYXBwcm9wcmlhdGUgc2VtYW50aWNzIGFyZSByZWZlcmVuY2luZyB0aGUgZ2xvYmFsIG5hbWUuXG4gICAgaWYgKHRoaXMuaG9zdC51bnR5cGVkIHx8ICFoYXNNb2RpZmllckZsYWcobm9kZSwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlY2xOYW1lcyA9IHRoaXMuZ2V0RXhwb3J0RGVjbGFyYXRpb25OYW1lcyhub2RlKTtcbiAgICBmb3IgKGNvbnN0IGRlY2wgb2YgZGVjbE5hbWVzKSB7XG4gICAgICBjb25zdCBzeW0gPSB0aGlzLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKGRlY2wpO1xuICAgICAgY29uc3QgaXNWYWx1ZSA9IHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlO1xuICAgICAgY29uc3QgZGVjbE5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsKTtcbiAgICAgIGlmIChub2RlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgLy8gRm9yIHZhcmlhYmxlcywgVHlwZVNjcmlwdCByZXdyaXRlcyBldmVyeSByZWZlcmVuY2UgdG8gdGhlIHZhcmlhYmxlIG5hbWUgYXMgYW5cbiAgICAgICAgLy8gXCJleHBvcnRzLlwiIGFjY2VzcywgdG8gbWFpbnRhaW4gbXV0YWJsZSBFUzYgZXhwb3J0cyBzZW1hbnRpY3MuIEluZGlyZWN0aW5nIHRocm91Z2ggdGhlXG4gICAgICAgIC8vIHdpbmRvdyBvYmplY3QgbWVhbnMgd2UgcmVmZXJlbmNlIHRoZSBjb3JyZWN0IGdsb2JhbCBzeW1ib2wuIENsb3N1cmUgQ29tcGlsZXIgZG9lc1xuICAgICAgICAvLyB1bmRlcnN0YW5kIHRoYXQgXCJ2YXIgZm9vXCIgaW4gZXh0ZXJucyBjb3JyZXNwb25kcyB0byBcIndpbmRvdy5mb29cIi5cbiAgICAgICAgdGhpcy5lbWl0KGBcXG5leHBvcnRzLiR7ZGVjbE5hbWV9ID0gd2luZG93LiR7ZGVjbE5hbWV9O1xcbmApO1xuICAgICAgfSBlbHNlIGlmICghaXNWYWx1ZSkge1xuICAgICAgICAvLyBEbyBub3QgZW1pdCByZS1leHBvcnRzIGZvciBNb2R1bGVEZWNsYXJhdGlvbnMuXG4gICAgICAgIC8vIEFtYmllbnQgTW9kdWxlRGVjbGFyYXRpb25zIGFyZSBhbHdheXMgcmVmZXJlbmNlZCBhcyBnbG9iYWwgc3ltYm9scywgc28gdGhleSBkb24ndCBuZWVkIHRvXG4gICAgICAgIC8vIGJlIGV4cG9ydGVkLlxuICAgICAgICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLk1vZHVsZURlY2xhcmF0aW9uKSBjb250aW51ZTtcbiAgICAgICAgLy8gTm9uLXZhbHVlIG9iamVjdHMgZG8gbm90IGV4aXN0IGF0IHJ1bnRpbWUsIHNvIHdlIGNhbm5vdCBhY2Nlc3MgdGhlIHN5bWJvbCAoaXQgb25seVxuICAgICAgICAvLyBleGlzdHMgaW4gZXh0ZXJucykuIEV4cG9ydCB0aGVtIGFzIGEgdHlwZWRlZiwgd2hpY2ggZm9yd2FyZHMgdG8gdGhlIHR5cGUgaW4gZXh0ZXJucy5cbiAgICAgICAgdGhpcy5lbWl0KGBcXG4vKiogQHR5cGVkZWYgeyR7ZGVjbE5hbWV9fSAqL1xcbmV4cG9ydHMuJHtkZWNsTmFtZX07XFxuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoYFxcbmV4cG9ydHMuJHtkZWNsTmFtZX0gPSAke2RlY2xOYW1lfTtcXG5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhhbWluZXMgYSB0cy5Ob2RlIGFuZCBkZWNpZGVzIHdoZXRoZXIgdG8gZG8gc3BlY2lhbCBwcm9jZXNzaW5nIG9mIGl0IGZvciBvdXRwdXQuXG4gICAqXG4gICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgdHMuTm9kZSBoYXMgYmVlbiBoYW5kbGVkLCBmYWxzZSBpZiB3ZSBzaG91bGRcbiAgICogICAgIGVtaXQgaXQgYXMgaXMgYW5kIHZpc2l0IGl0cyBjaGlsZHJlbi5cbiAgICovXG4gIG1heWJlUHJvY2Vzcyhub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gICAgaWYgKGhhc01vZGlmaWVyRmxhZyhub2RlLCB0cy5Nb2RpZmllckZsYWdzLkFtYmllbnQpIHx8IGlzRHRzRmlsZU5hbWUodGhpcy5maWxlLmZpbGVOYW1lKSkge1xuICAgICAgLy8gQW4gYW1iaWVudCBkZWNsYXJhdGlvbiBkZWNsYXJlcyB0eXBlcyBmb3IgVHlwZVNjcmlwdCdzIGJlbmVmaXQsIHNvIHdlIHdhbnQgdG8gc2tpcCBUc2lja2xlXG4gICAgICAvLyBjb252ZXJzaW9uIG9mIGl0cyBjb250ZW50cy5cbiAgICAgIHRoaXMud3JpdGVSYW5nZShub2RlLCBub2RlLmdldEZ1bGxTdGFydCgpLCBub2RlLmdldEVuZCgpKTtcbiAgICAgIC8vIC4uLiBidXQgaXQgbWlnaHQgbmVlZCB0byBiZSBleHBvcnRlZCBmb3IgZG93bnN0cmVhbSBpbXBvcnRpbmcgY29kZS5cbiAgICAgIHRoaXMubWF5YmVFbWl0QW1iaWVudERlY2xhcmF0aW9uRXhwb3J0KG5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXIpIHtcbiAgICAgIHRoaXMuY3VycmVudERlY29yYXRvckNvbnZlcnRlci5iZWZvcmVQcm9jZXNzTm9kZShub2RlKTtcbiAgICB9XG4gICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Tb3VyY2VGaWxlOlxuICAgICAgICB0aGlzLmhhbmRsZVNvdXJjZUZpbGUobm9kZSBhcyB0cy5Tb3VyY2VGaWxlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW1wb3J0RGVjbGFyYXRpb246XG4gICAgICAgIHRoaXMuaW1wb3J0ZWROYW1lcy5wdXNoKFxuICAgICAgICAgICAgLi4uZGVjb3JhdG9yLmNvbGxlY3RJbXBvcnRlZE5hbWVzKHRoaXMudHlwZUNoZWNrZXIsIG5vZGUgYXMgdHMuSW1wb3J0RGVjbGFyYXRpb24pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdEltcG9ydERlY2xhcmF0aW9uKG5vZGUgYXMgdHMuSW1wb3J0RGVjbGFyYXRpb24pO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkV4cG9ydERlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCBleHBvcnREZWNsID0gbm9kZSBhcyB0cy5FeHBvcnREZWNsYXJhdGlvbjtcbiAgICAgICAgdGhpcy53cml0ZUxlYWRpbmdUcml2aWEobm9kZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXhwb3J0Jyk7XG4gICAgICAgIGxldCBleHBvcnRlZFN5bWJvbHM6IE5hbWVkU3ltYm9sW10gPSBbXTtcbiAgICAgICAgaWYgKCFleHBvcnREZWNsLmV4cG9ydENsYXVzZSAmJiBleHBvcnREZWNsLm1vZHVsZVNwZWNpZmllcikge1xuICAgICAgICAgIC8vIEl0J3MgYW4gXCJleHBvcnQgKiBmcm9tIC4uLlwiIHN0YXRlbWVudC5cbiAgICAgICAgICAvLyBSZXdyaXRlIGl0IHRvIHJlLWV4cG9ydCBlYWNoIGV4cG9ydGVkIHN5bWJvbCBkaXJlY3RseS5cbiAgICAgICAgICBleHBvcnRlZFN5bWJvbHMgPSB0aGlzLmV4cGFuZFN5bWJvbHNGcm9tRXhwb3J0U3RhcihleHBvcnREZWNsKTtcbiAgICAgICAgICBjb25zdCBleHBvcnRTeW1ib2xzVG9FbWl0ID1cbiAgICAgICAgICAgICAgZXhwb3J0ZWRTeW1ib2xzLmZpbHRlcihzID0+IHRoaXMuc2hvdWxkRW1pdEV4cG9ydFN5bWJvbChzLnN5bSkpO1xuICAgICAgICAgIHRoaXMuZW1pdChgIHske2V4cG9ydFN5bWJvbHNUb0VtaXQubWFwKGUgPT4gdW5lc2NhcGVOYW1lKGUubmFtZSkpLmpvaW4oJywnKX19YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGV4cG9ydERlY2wuZXhwb3J0Q2xhdXNlKSB7XG4gICAgICAgICAgICBleHBvcnRlZFN5bWJvbHMgPSB0aGlzLmdldE5hbWVkU3ltYm9scyhleHBvcnREZWNsLmV4cG9ydENsYXVzZS5lbGVtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KGV4cG9ydERlY2wuZXhwb3J0Q2xhdXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGAgZnJvbSAnJHt0aGlzLnJlc29sdmVNb2R1bGVTcGVjaWZpZXIoZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIpfSc7YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXhwb3J0IHsuLi59O1xuICAgICAgICAgIHRoaXMuZW1pdCgnOycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkU291cmNlTWFwcGluZyhub2RlKTtcbiAgICAgICAgaWYgKGV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkRGVjbGFyZShleHBvcnREZWNsLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydGVkU3ltYm9scy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmVtaXRUeXBlRGVmRXhwb3J0cyhleHBvcnRlZFN5bWJvbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uOlxuICAgICAgICB0aGlzLmVtaXRJbnRlcmZhY2Uobm9kZSBhcyB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbik7XG4gICAgICAgIC8vIEVtaXQgdGhlIFRTIGludGVyZmFjZSB2ZXJiYXRpbSwgd2l0aCBubyB0c2lja2xlIHByb2Nlc3Npbmcgb2YgcHJvcGVydGllcy5cbiAgICAgICAgdGhpcy53cml0ZVJhbmdlKG5vZGUsIG5vZGUuZ2V0RnVsbFN0YXJ0KCksIG5vZGUuZ2V0RW5kKCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCB2YXJEZWNsID0gbm9kZSBhcyB0cy5WYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgICAgICAvLyBPbmx5IGVtaXQgYSB0eXBlIGFubm90YXRpb24gd2hlbiBpdCdzIGEgcGxhaW4gdmFyaWFibGUgYW5kXG4gICAgICAgIC8vIG5vdCBhIGJpbmRpbmcgcGF0dGVybiwgYXMgQ2xvc3VyZSBkb2Vzbid0KD8pIGhhdmUgYSBzeW50YXhcbiAgICAgICAgLy8gZm9yIGFubm90YXRpbmcgYmluZGluZyBwYXR0ZXJucy4gIFNlZSBpc3N1ZSAjMTI4LlxuICAgICAgICAvLyBEb24ndCBlbWl0IHR5cGUgYW5ub3RhdGlvbiB3aGVuIHRoZSB2YXJpYWJsZSBzdGF0ZW1lbnQgaXMgYSBAcG9seW1lckJlaGF2aW9yLFxuICAgICAgICAvLyBhcyBvdGhlcndpc2UgdGhlIHBvbHltZXIgY2xvc3VyZSBjaGVja2VyIHdpbGwgZmFpbC5cbiAgICAgICAgLy8gU2VlIGIvNjQzODk4MDZcbiAgICAgICAgaWYgKHRoaXMucG9seW1lckJlaGF2aW9yU3RhY2tDb3VudCA9PT0gMCAmJlxuICAgICAgICAgICAgdmFyRGVjbC5uYW1lLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgICAgIHRoaXMuZW1pdEpTRG9jVHlwZSh2YXJEZWNsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgY2xhc3NOb2RlID0gbm9kZSBhcyB0cy5DbGFzc0RlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLnZpc2l0Q2xhc3NEZWNsYXJhdGlvbihjbGFzc05vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5QdWJsaWNLZXl3b3JkOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByaXZhdGVLZXl3b3JkOlxuICAgICAgICAvLyBUaGUgXCJwdWJsaWNcIi9cInByaXZhdGVcIiBrZXl3b3JkcyBhcmUgZW5jb3VudGVyZWQgaW4gdHdvIHBsYWNlczpcbiAgICAgICAgLy8gMSkgSW4gY2xhc3MgZmllbGRzICh3aGljaCBkb24ndCBhcHBlYXIgaW4gdGhlIHRyYW5zZm9ybWVkIG91dHB1dCkuXG4gICAgICAgIC8vIDIpIEluIFwicGFyYW1ldGVyIHByb3BlcnRpZXNcIiwgZS5nLlxuICAgICAgICAvLyAgICAgIGNvbnN0cnVjdG9yKC8qKiBAZXhwb3J0ICovIHB1YmxpYyBmb286IHN0cmluZykuXG4gICAgICAgIC8vIEluIGNhc2UgMiBpdCdzIGltcG9ydGFudCB0byBub3QgZW1pdCB0aGF0IEpTRG9jIGluIHRoZSBnZW5lcmF0ZWRcbiAgICAgICAgLy8gY29uc3RydWN0b3IsIGFzIHRoaXMgaXMgaWxsZWdhbCBmb3IgQ2xvc3VyZS4gIEl0J3Mgc2FmZSB0byBqdXN0XG4gICAgICAgIC8vIGFsd2F5cyBza2lwIGNvbW1lbnRzIHByZWNlZGluZyB0aGUgJ3B1YmxpYycga2V5d29yZC5cbiAgICAgICAgLy8gU2VlIHRlc3RfZmlsZXMvcGFyYW1ldGVyX3Byb3BlcnRpZXMudHMuXG4gICAgICAgIHRoaXMud3JpdGVOb2RlKG5vZGUsIC8qIHNraXBDb21tZW50cyAqLyB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgIGNvbnN0IGN0b3IgPSBub2RlIGFzIHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb247XG4gICAgICAgIHRoaXMuZW1pdEZ1bmN0aW9uVHlwZShbY3Rvcl0pO1xuICAgICAgICAvLyBXcml0ZSB0aGUgXCJjb25zdHJ1Y3RvciguLi4pIHtcIiBiaXQsIGJ1dCBpdGVyYXRlIHRocm91Z2ggYW55XG4gICAgICAgIC8vIHBhcmFtZXRlcnMgaWYgZ2l2ZW4gc28gdGhhdCB3ZSBjYW4gZXhhbWluZSB0aGVtIG1vcmUgY2xvc2VseS5cbiAgICAgICAgdGhpcy53cml0ZU5vZGVGcm9tKGN0b3IsIGN0b3IuZ2V0U3RhcnQoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkFycm93RnVuY3Rpb246XG4gICAgICAgIC8vIEl0J3MgZGlmZmljdWx0IHRvIGFubm90YXRlIGFycm93IGZ1bmN0aW9ucyBkdWUgdG8gYSBidWcgaW5cbiAgICAgICAgLy8gVHlwZVNjcmlwdCAoc2VlIHRzaWNrbGUgaXNzdWUgNTcpLiAgRm9yIG5vdywganVzdCBwYXNzIHRoZW1cbiAgICAgICAgLy8gdGhyb3VnaCB1bmFubm90YXRlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTWV0aG9kRGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuR2V0QWNjZXNzb3I6XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuU2V0QWNjZXNzb3I6XG4gICAgICAgIGNvbnN0IGZuRGVjbCA9IG5vZGUgYXMgdHMuRnVuY3Rpb25MaWtlRGVjbGFyYXRpb247XG4gICAgICAgIGNvbnN0IHRhZ3MgPSBoYXNFeHBvcnRpbmdEZWNvcmF0b3Iobm9kZSwgdGhpcy50eXBlQ2hlY2tlcikgPyBbe3RhZ05hbWU6ICdleHBvcnQnfV0gOiBbXTtcblxuICAgICAgICBpZiAoIWZuRGVjbC5ib2R5KSB7XG4gICAgICAgICAgLy8gVHdvIGNhc2VzOiBhYnN0cmFjdCBtZXRob2RzIGFuZCBvdmVybG9hZGVkIG1ldGhvZHMvZnVuY3Rpb25zLlxuICAgICAgICAgIC8vIEFic3RyYWN0IG1ldGhvZHMgYXJlIGhhbmRsZWQgaW4gZW1pdFR5cGVBbm5vdGF0aW9uc0hhbmRsZXIuXG4gICAgICAgICAgLy8gT3ZlcmxvYWRzIGFyZSB1bmlvbi1pemVkIGludG8gdGhlIHNoYXJlZCB0eXBlIGluIGVtaXRGdW5jdGlvblR5cGUuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0RnVuY3Rpb25UeXBlKFtmbkRlY2xdLCB0YWdzKTtcbiAgICAgICAgdGhpcy5uZXdUeXBlVHJhbnNsYXRvcihmbkRlY2wpLmJsYWNrbGlzdFR5cGVQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgdGhpcy5zeW1ib2xzVG9BbGlhc2VkTmFtZXMsIGZuRGVjbC50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMud3JpdGVOb2RlRnJvbShmbkRlY2wsIGZuRGVjbC5nZXRTdGFydCgpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVHlwZUFsaWFzRGVjbGFyYXRpb246XG4gICAgICAgIHRoaXMud3JpdGVOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLnZpc2l0VHlwZUFsaWFzKG5vZGUgYXMgdHMuVHlwZUFsaWFzRGVjbGFyYXRpb24pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5FbnVtRGVjbGFyYXRpb246XG4gICAgICAgIHRoaXMucHJvY2Vzc0VudW0obm9kZSBhcyB0cy5FbnVtRGVjbGFyYXRpb24pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UZW1wbGF0ZVNwYW46XG4gICAgICAgIHRoaXMudGVtcGxhdGVTcGFuU3RhY2tDb3VudCsrO1xuICAgICAgICB0aGlzLndyaXRlTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVNwYW5TdGFja0NvdW50LS07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBc3NlcnRpb25FeHByZXNzaW9uOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkFzRXhwcmVzc2lvbjpcbiAgICAgICAgLy8gQm90aCBvZiB0aGVzZSBjYXNlcyBhcmUgQXNzZXJ0aW9uRXhwcmVzc2lvbnMuXG4gICAgICAgIGNvbnN0IHR5cGVBc3NlcnRpb24gPSBub2RlIGFzIHRzLkFzc2VydGlvbkV4cHJlc3Npb247XG4gICAgICAgIGlmICh0aGlzLnBvbHltZXJCZWhhdmlvclN0YWNrQ291bnQgPiAwKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZW1pdCB0eXBlIGNhc3RzIGZvciBQb2x5bWVyIGJlaGF2aW9ycyB0aGF0IGFyZSBkZWNsYXJlZFxuICAgICAgICAgIC8vIGJ5IGNhbGxpbmcgdGhlIFBvbHltZXIgZnVuY3Rpb25cbiAgICAgICAgICAvLyBhcyB0aGUgUG9seW1lciBjbG9zdXJlIHBsdWdpbiBkb2VzIG5vdCB3b3JrIHdoZW4gZW1pdHRpbmcgdGhlbS5cbiAgICAgICAgICAvLyBTZWUgYi82NDM4OTgwNi5cbiAgICAgICAgICAvLyBOb3RlOiBUaGlzIG9ubHkgbWF0dGVycyBpbiB0aGUgdHJhbnNmb3JtZXIgdmVyc2lvbiBvZiB0c2lja2xlLFxuICAgICAgICAgIC8vIGFzIHRoZSBub24gdHJhbnNmb3JtZXIgdmVyc2lvbiBuZXZlciBlbWl0dGVkIHR5cGUgY2FzdHMgZHVlIHRvXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy85ODczIChzZWUgYmVsb3cpLlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHVzaW5nIGEgdHlwZSBjYXN0cyBpbiB0ZW1wbGF0ZSBleHByZXNzaW9ucyxcbiAgICAgICAgLy8gY2xvc3VyZSByZXF1aXJlcyBhbm90aGVyIHBhaXIgb2YgcGFyZW5zLCBvdGhlcndpc2UgaXQgd2lsbFxuICAgICAgICAvLyBjb21wbGFpbiB3aXRoIFwiTWlzcGxhY2VkIHR5cGUgYW5ub3RhdGlvbi4gVHlwZSBhbm5vdGF0aW9ucyBhcmUgbm90IGFsbG93ZWQgaGVyZS5cIlxuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZVNwYW5TdGFja0NvdW50ID4gMCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnKCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdEpTRG9jVHlwZSh0eXBlQXNzZXJ0aW9uKTtcbiAgICAgICAgLy8gV2hlbiBUeXBlU2NyaXB0IGVtaXRzIEpTLCBpdCByZW1vdmVzIG9uZSBsYXllciBvZiBcInJlZHVuZGFudFwiXG4gICAgICAgIC8vIHBhcmVucywgYnV0IHdlIG5lZWQgdGhlbSBmb3IgdGhlIENsb3N1cmUgdHlwZSBhc3NlcnRpb24uICBXb3JrXG4gICAgICAgIC8vIGFyb3VuZCB0aGlzIGJ5IHVzaW5nIHR3byBwYXJlbnMuICBTZWUgdGVzdF9maWxlcy9jb2VyY2UuKi5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgaW4gYm90aCwgdGhlIHRyYW5zZm9ybWVyIGFuZCBub24gdHJhbnNmb3JtZXIgdmVyc2lvbi5cbiAgICAgICAgLy8gVE9ETzogaW4gdGhlIG5vbiB0cmFuc2Zvcm1lciB2ZXJzaW9uLCB0aGUgY29tbWVudCBpcyBjdXJyZW50bHkgZHJvcHBlZFxuICAgICAgICAvLyAgYWxsdGVnZXRoZXIgZnJvbSBwdXJlIGFzc2lnbm1lbnRzIGR1ZSB0b1xuICAgICAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy85ODczLlxuICAgICAgICB0aGlzLmVtaXQoJygoJyk7XG4gICAgICAgIHRoaXMud3JpdGVOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmVtaXQoJykpJyk7XG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlU3BhblN0YWNrQ291bnQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTm9uTnVsbEV4cHJlc3Npb246XG4gICAgICAgIGNvbnN0IG5uZXhwciA9IG5vZGUgYXMgdHMuTm9uTnVsbEV4cHJlc3Npb247XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy50eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihubmV4cHIuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLlVuaW9uKSB7XG4gICAgICAgICAgY29uc3Qgbm9uTnVsbFVuaW9uID1cbiAgICAgICAgICAgICAgKHR5cGUgYXMgdHMuVW5pb25UeXBlKVxuICAgICAgICAgICAgICAgICAgLnR5cGVzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICB0ID0+ICh0LmZsYWdzICYgKHRzLlR5cGVGbGFncy5OdWxsIHwgdHMuVHlwZUZsYWdzLlVuZGVmaW5lZCkpID09PSAwKTtcbiAgICAgICAgICBjb25zdCB0eXBlQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGUgYXMgdHMuVW5pb25UeXBlKTtcbiAgICAgICAgICB0eXBlQ29weS50eXBlcyA9IG5vbk51bGxVbmlvbjtcbiAgICAgICAgICB0eXBlID0gdHlwZUNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUuXG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlU3BhblN0YWNrQ291bnQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0SlNEb2NUeXBlKG5uZXhwciwgdW5kZWZpbmVkLCB0eXBlKTtcbiAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUuXG4gICAgICAgIHRoaXMuZW1pdCgnKCgnKTtcbiAgICAgICAgdGhpcy53cml0ZU5vZGUobm5leHByLmV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLmVtaXQoJykpJyk7XG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlU3BhblN0YWNrQ291bnQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlEZWNsYXJhdGlvbjpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5WYXJpYWJsZVN0YXRlbWVudDpcbiAgICAgICAgY29uc3QgZG9jVGFncyA9IHRoaXMuZ2V0SlNEb2Mobm9kZSkgfHwgW107XG4gICAgICAgIGlmIChoYXNFeHBvcnRpbmdEZWNvcmF0b3Iobm9kZSwgdGhpcy50eXBlQ2hlY2tlcikpIHtcbiAgICAgICAgICBkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdleHBvcnQnfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jVGFncy5sZW5ndGggPiAwICYmIG5vZGUuZ2V0Rmlyc3RUb2tlbigpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdcXG4nKTtcbiAgICAgICAgICB0aGlzLmVtaXQoanNkb2MudG9TdHJpbmcoZG9jVGFncykpO1xuICAgICAgICAgIGNvbnN0IGlzUG9seW1lckJlaGF2aW9yID0gZG9jVGFncy5zb21lKHQgPT4gdC50YWdOYW1lID09PSAncG9seW1lckJlaGF2aW9yJyk7XG4gICAgICAgICAgaWYgKGlzUG9seW1lckJlaGF2aW9yKSB7XG4gICAgICAgICAgICB0aGlzLnBvbHltZXJCZWhhdmlvclN0YWNrQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy53cml0ZU5vZGVGcm9tKG5vZGUsIG5vZGUuZ2V0U3RhcnQoKSk7XG4gICAgICAgICAgaWYgKGlzUG9seW1lckJlaGF2aW9yKSB7XG4gICAgICAgICAgICB0aGlzLnBvbHltZXJCZWhhdmlvclN0YWNrQ291bnQtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlBc3NpZ25tZW50OlxuICAgICAgICBjb25zdCBwYSA9IG5vZGUgYXMgdHMuUHJvcGVydHlBc3NpZ25tZW50O1xuICAgICAgICBpZiAoaXNQb2x5bWVyQmVoYXZpb3JQcm9wZXJ0eUluQ2FsbEV4cHJlc3Npb24ocGEpKSB7XG4gICAgICAgICAgdGhpcy5wb2x5bWVyQmVoYXZpb3JTdGFja0NvdW50Kys7XG4gICAgICAgICAgdGhpcy53cml0ZU5vZGVGcm9tKG5vZGUsIG5vZGUuZ2V0U3RhcnQoKSk7XG4gICAgICAgICAgdGhpcy5wb2x5bWVyQmVoYXZpb3JTdGFja0NvdW50LS07XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkVsZW1lbnRBY2Nlc3NFeHByZXNzaW9uOlxuICAgICAgICAvLyBXYXJuIGZvciBxdW90ZWQgYWNjZXNzZXMgdG8gcHJvcGVydGllcyB0aGF0IGhhdmUgYSBzeW1ib2wgZGVjbGFyZWQuXG4gICAgICAgIC8vIE1peGluZyBxdW90ZWQgYW5kIG5vbi1xdW90ZWQgYWNjZXNzIHRvIGEgc3ltYm9sICh4Wydmb28nXSBhbmQgeC5mb28pIHJpc2tzIGJyZWFraW5nXG4gICAgICAgIC8vIENsb3N1cmUgQ29tcGlsZXIgcmVuYW1pbmcuIFF1b3RlZCBhY2Nlc3MgaXMgbW9yZSBjdW1iZXJzb21lIHRvIHdyaXRlIHRoYW4gZG90dGVkIGFjY2Vzc1xuICAgICAgICAvLyB0aG91Z2gsIHNvIGNoYW5jZXMgYXJlIHVzZXJzIGRpZCBpbnRlbmQgdG8gYXZvaWQgcmVuYW1pbmcuIFRoZSBiZXR0ZXIgZml4IGlzIHRvIHVzZVxuICAgICAgICAvLyBgZGVjbGFyZSBpbnRlcmZhY2VgIHRob3VnaC5cbiAgICAgICAgY29uc3QgZWFlID0gbm9kZSBhcyB0cy5FbGVtZW50QWNjZXNzRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFlYWUuYXJndW1lbnRFeHByZXNzaW9uIHx8XG4gICAgICAgICAgICBlYWUuYXJndW1lbnRFeHByZXNzaW9uLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdW90ZWRQcm9wU3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKGVhZS5hcmd1bWVudEV4cHJlc3Npb24pO1xuICAgICAgICAvLyBJZiBpdCBoYXMgYSBzeW1ib2wsIGl0J3MgYWN0dWFsbHkgYSByZWd1bGFyIGRlY2xhcmVkIHByb3BlcnR5LlxuICAgICAgICBpZiAoIXF1b3RlZFByb3BTeW0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb25IYXNRdW90ZXMgPVxuICAgICAgICAgICAgIXF1b3RlZFByb3BTeW0uZGVjbGFyYXRpb25zIHx8IHF1b3RlZFByb3BTeW0uZGVjbGFyYXRpb25zLnNvbWUoZCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlY2wgPSBkIGFzIHRzLk5hbWVkRGVjbGFyYXRpb247XG4gICAgICAgICAgICAgIGlmICghZGVjbC5uYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBkZWNsLm5hbWUua2luZCA9PT0gdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBkZWNsYXJlZCB3aXRoIHF1b3RlcywgaXQgc2hvdWxkIGFsc28gYmUgYWNjZXNzZWQgd2l0aCB0aGVtLlxuICAgICAgICBpZiAoZGVjbGFyYXRpb25IYXNRdW90ZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoZWFlLmFyZ3VtZW50RXhwcmVzc2lvbiBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgICAgICAvLyBQcm9wZXJ0aWVzIGNvbnRhaW5pbmcgbm9uLUpTIGlkZW50aWZpZXIgbmFtZXMgY2FuIG9ubHkgYmUgYWNjZXNzZWQgd2l0aCBxdW90ZXMuXG4gICAgICAgIGlmICghaXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWUocHJvcE5hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN5bU5hbWUgPSB0aGlzLnR5cGVDaGVja2VyLnN5bWJvbFRvU3RyaW5nKHF1b3RlZFByb3BTeW0pO1xuICAgICAgICB0aGlzLmRlYnVnV2FybihcbiAgICAgICAgICAgIGVhZSxcbiAgICAgICAgICAgIGBEZWNsYXJlZCBwcm9wZXJ0eSAke3N5bU5hbWV9IGFjY2Vzc2VkIHdpdGggcXVvdGVzLiBgICtcbiAgICAgICAgICAgICAgICBgVGhpcyBjYW4gbGVhZCB0byByZW5hbWluZyBidWdzLiBBIGJldHRlciBmaXggaXMgdG8gdXNlICdkZWNsYXJlIGludGVyZmFjZScgYCArXG4gICAgICAgICAgICAgICAgYG9uIHRoZSBkZWNsYXJhdGlvbi5gKTtcbiAgICAgICAgLy8gUHJldmlvdXNseSwgdGhlIGNvZGUgYmVsb3cgY2hhbmdlZCB0aGUgcXVvdGVkIGludG8gYSBub24tcXVvdGVkIGFjY2Vzcy5cbiAgICAgICAgLy8gdGhpcy53cml0ZU5vZGUoZWFlLmV4cHJlc3Npb24pO1xuICAgICAgICAvLyB0aGlzLmVtaXQoYC4ke3Byb3BOYW1lfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uOlxuICAgICAgICAvLyBDb252ZXJ0IGRvdHRlZCBhY2Nlc3NlcyB0byB0eXBlcyB0aGF0IGhhdmUgYW4gaW5kZXggdHlwZSBkZWNsYXJlZCB0byBxdW90ZWQgYWNjZXNzZXMsIHRvXG4gICAgICAgIC8vIGF2b2lkIENsb3N1cmUgcmVuYW1pbmcgb25lIGFjY2VzcyBidXQgbm90IHRoZSBvdGhlci5cbiAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGJlY2F1c2UgVFMgYWxsb3dzIGRvdHRlZCBhY2Nlc3MgdG8gc3RyaW5nIGluZGV4IHR5cGVzLlxuICAgICAgICBjb25zdCBwYWUgPSBub2RlIGFzIHRzLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbjtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24ocGFlLmV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoIXQuZ2V0U3RyaW5nSW5kZXhUeXBlKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVHlwZXMgY2FuIGhhdmUgc3RyaW5nIGluZGV4IHNpZ25hdHVyZXMgYW5kIGRlY2xhcmVkIHByb3BlcnRpZXMgKG9mIHRoZSBtYXRjaGluZyB0eXBlKS5cbiAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBoYXZlIGEgc3ltYm9sLCBhcyBvcHBvc2VkIHRvIHB1cmUgc3RyaW5nIGluZGV4IHR5cGVzLlxuICAgICAgICBjb25zdCBwcm9wU3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHBhZS5uYW1lKTtcbiAgICAgICAgLy8gVGhlIGRlY2lzaW9uIHRvIHJldHVybiBiZWxvdyBpcyBhIGp1ZGdlbWVudCBjYWxsLiBQcmVzdW1hYmx5LCBpbiBtb3N0IHNpdHVhdGlvbnMsIGRvdHRlZFxuICAgICAgICAvLyBhY2Nlc3MgdG8gYSBwcm9wZXJ0eSBpcyBjb3JyZWN0LCBhbmQgc2hvdWxkIG5vdCBiZSB0dXJuZWQgaW50byBxdW90ZWQgYWNjZXNzIGV2ZW4gaWZcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBzdHJpbmcgaW5kZXggb24gdGhlIHR5cGUuIEhvd2V2ZXIgaXQgaXMgcG9zc2libGUgdG8gY29uc3RydWN0IHByb2dyYW1zIHdoZXJlXG4gICAgICAgIC8vIHRoaXMgaXMgaW5jb3JyZWN0LCBlLmcuIHdoZXJlIHVzZXIgY29kZSBhc3NpZ25zIGludG8gYSBwcm9wZXJ0eSB0aHJvdWdoIHRoZSBpbmRleCBhY2Nlc3NcbiAgICAgICAgLy8gaW4gYW5vdGhlciBsb2NhdGlvbi5cbiAgICAgICAgaWYgKHByb3BTeW0pIHJldHVybiBmYWxzZTtcblxuICAgICAgICB0aGlzLmRlYnVnV2FybihcbiAgICAgICAgICAgIHBhZSxcbiAgICAgICAgICAgIHRoaXMudHlwZUNoZWNrZXIudHlwZVRvU3RyaW5nKHQpICtcbiAgICAgICAgICAgICAgICBgIGhhcyBhIHN0cmluZyBpbmRleCB0eXBlIGJ1dCBpcyBhY2Nlc3NlZCB1c2luZyBkb3R0ZWQgYWNjZXNzLiBgICtcbiAgICAgICAgICAgICAgICBgUXVvdGluZyB0aGUgYWNjZXNzLmApO1xuICAgICAgICB0aGlzLndyaXRlTm9kZShwYWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMuZW1pdCgnW1wiJyk7XG4gICAgICAgIHRoaXMud3JpdGVOb2RlKHBhZS5uYW1lKTtcbiAgICAgICAgdGhpcy5lbWl0KCdcIl0nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRGVjb3JhdG9yOlxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RGVjb3JhdG9yQ29udmVydGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERlY29yYXRvckNvbnZlcnRlci5tYXliZVByb2Nlc3NEZWNvcmF0b3Iobm9kZSBhcyB0cy5EZWNvcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZEVtaXRFeHBvcnRTeW1ib2woc3ltOiB0cy5TeW1ib2wpOiBib29sZWFuIHtcbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgIHN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW0pO1xuICAgIH1cbiAgICBpZiAoKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSA9PT0gMCkge1xuICAgICAgLy8gTm90ZTogV2UgY3JlYXRlIGV4cGxpY2l0IHJlZXhwb3J0cyB2aWEgY2xvc3VyZSBhdCBhbm90aGVyIHBsYWNlIGluXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5Db25zdEVudW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVNvdXJjZUZpbGUoc2Y6IHRzLlNvdXJjZUZpbGUpIHtcbiAgICAvLyBFbWl0IGxlYWRpbmcgZGV0YWNoZWQgY29tbWVudHM6IGNvbW1lbnRzIHNlcGFyYXRlZCBieSBhIFxcblxcbiBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAvLyBXaGlsZSBoYW5kbGVycyBiZWxvdyBnZW5lcmFsbHkgZW1pdCBjb21tZW50cyBwcmVjZWRpbmcgdGhlbSwgbm90IGFsbCBvZiB0aGVtIGRvIGluIGFsbFxuICAgIC8vIHNpdHVhdGlvbnMgKGUuZy4gSlNEb2MgcHJlY2VkaW5nIGEgY2xhc3MpLlxuICAgIC8vIFRoaXMgaXMgc3ltbWV0cmljIHdpdGggYGdldEpTRG9jYCBiZWxvdyBub3QgcmV0dXJuaW5nIGRldGFjaGVkIGZpbGUgbGV2ZWwgY29tbWVudHMuXG4gICAgY29uc3QgY29tbWVudHMgPSB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlcyhzZi50ZXh0LCAwKSB8fCBbXTtcbiAgICBsZXQgc3RhcnQgPSBzZi5nZXRGdWxsU3RhcnQoKTtcbiAgICBmb3IgKGxldCBpID0gY29tbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChzZi50ZXh0LnN1YnN0cmluZyhjb21tZW50c1tpXS5lbmQsIGNvbW1lbnRzW2ldLmVuZCArIDIpID09PSAnXFxuXFxuJykge1xuICAgICAgICB0aGlzLmVtaXQoc2YudGV4dC5zdWJzdHJpbmcoMCwgY29tbWVudHNbaV0uZW5kICsgMikpO1xuICAgICAgICBzdGFydCA9IGNvbW1lbnRzW2ldLmVuZCArIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyaXRlTm9kZUZyb20oc2YsIHN0YXJ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFwiZXhwb3J0ICogZnJvbSAuLi5cIiBzdGF0ZW1lbnQsIGdhdGhlcnMgdGhlIHN5bWJvbCBuYW1lcyBpdCBhY3R1YWxseVxuICAgKiBleHBvcnRzIHRvIGJlIHVzZWQgaW4gYSBzdGF0ZW1lbnQgbGlrZSBcImV4cG9ydCB7Zm9vLCBiYXIsIGJhen0gZnJvbSAuLi5cIi5cbiAgICpcbiAgICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBUUyB0cmFuc3BpbGVzIFwiZXhwb3J0ICpcIiBieSBqdXN0IGRvaW5nIGEgcnVudGltZSBsb29wXG4gICAqIG92ZXIgdGhlIHRhcmdldCBtb2R1bGUncyBleHBvcnRzLCB3aGljaCBtZWFucyBDbG9zdXJlIHdvbid0IHNlZSB0aGUgZGVjbGFyYXRpb25zL3R5cGVzXG4gICAqIHRoYXQgYXJlIGV4cG9ydGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBleHBhbmRTeW1ib2xzRnJvbUV4cG9ydFN0YXIoZXhwb3J0RGVjbDogdHMuRXhwb3J0RGVjbGFyYXRpb24pOiBOYW1lZFN5bWJvbFtdIHtcbiAgICAvLyBZb3UgY2FuJ3QgaGF2ZSBhbiBcImV4cG9ydCAqXCIgd2l0aG91dCBhIG1vZHVsZSBzcGVjaWZpZXIuXG4gICAgY29uc3QgbW9kdWxlU3BlY2lmaWVyID0gZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIhO1xuXG4gICAgLy8gR2F0aGVyIHRoZSBuYW1lcyBvZiBsb2NhbCBleHBvcnRzLCB0byBhdm9pZCByZWV4cG9ydGluZyBhbnlcbiAgICAvLyBuYW1lcyB0aGF0IGFyZSBhbHJlYWR5IGxvY2FsbHkgZXhwb3J0ZWQuXG4gICAgY29uc3QgbW9kdWxlU3ltYm9sID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHRoaXMuZmlsZSk7XG4gICAgY29uc3QgbW9kdWxlRXhwb3J0cyA9IG1vZHVsZVN5bWJvbCAmJiBtb2R1bGVTeW1ib2wuZXhwb3J0cyB8fCBuZXcgTWFwPHN0cmluZywgdHMuU3ltYm9sPigpO1xuXG4gICAgLy8gRXhwYW5kIHRoZSBleHBvcnQgbGlzdCwgdGhlbiBmaWx0ZXIgaXQgdG8gdGhlIHN5bWJvbHMgd2Ugd2FudCB0byByZWV4cG9ydC5cbiAgICBjb25zdCBleHBvcnRzID1cbiAgICAgICAgdGhpcy50eXBlQ2hlY2tlci5nZXRFeHBvcnRzT2ZNb2R1bGUodGhpcy5tdXN0R2V0U3ltYm9sQXRMb2NhdGlvbihtb2R1bGVTcGVjaWZpZXIpKTtcbiAgICBjb25zdCByZWV4cG9ydHMgPSBuZXcgU2V0PHRzLlN5bWJvbD4oKTtcbiAgICBmb3IgKGNvbnN0IHN5bSBvZiBleHBvcnRzKSB7XG4gICAgICBjb25zdCBuYW1lID0gdW5lc2NhcGVOYW1lKHN5bS5uYW1lKTtcbiAgICAgIGlmIChtb2R1bGVFeHBvcnRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGlmIChtb2R1bGVFeHBvcnRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIC8vIFRoaXMgbmFtZSBpcyBzaGFkb3dlZCBieSBhIGxvY2FsIGRlZmluaXRpb24sIHN1Y2ggYXM6XG4gICAgICAgICAgLy8gLSBleHBvcnQgdmFyIGZvbyAuLi5cbiAgICAgICAgICAvLyAtIGV4cG9ydCB7Zm9vfSBmcm9tIC4uLlxuICAgICAgICAgIC8vIC0gZXhwb3J0IHtiYXIgYXMgZm9vfSBmcm9tIC4uLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPKCM2MzQpOiBjaGVjayBpZiB0aGlzIGlzIGEgc2FmZSBjYXN0LlxuICAgICAgICBpZiAobW9kdWxlRXhwb3J0cy5oYXMobmFtZSBhcyB0cy5fX1N0cmluZykpIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVkRXhwb3J0cy5oYXMobmFtZSkpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBleHBvcnRlZCB2aWEgYW4gZWFybGllciBleHBhbnNpb24gb2YgYW4gXCJleHBvcnQgKiBmcm9tIC4uLlwiLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2VuZXJhdGVkRXhwb3J0cy5hZGQobmFtZSk7XG4gICAgICByZWV4cG9ydHMuYWRkKHN5bSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHJlZXhwb3J0cy5rZXlzKCkpLm1hcChzeW0gPT4ge1xuICAgICAgcmV0dXJuIHtuYW1lOiBzeW0ubmFtZSwgc3ltfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhbiBgZXhwb3J0cy5gIGFzc2lnbm1lbnQgZm9yIGVhY2ggdHlwZSBhbGlhcyBleHBvcnRlZCBpbiB0aGUgZ2l2ZW4gYGV4cG9ydHNgLlxuICAgKiBUeXBlU2NyaXB0IGJ5IGl0c2VsZiBkb2VzIG5vdCBleHBvcnQgbm9uLXZhbHVlIHN5bWJvbHMgKGUuZy4gaW50ZXJmYWNlcywgdHlwZWRlZnMpLCBhcyBpdFxuICAgKiBleHBlY3RzIHRvIHJlbW92ZSB0aG9zZSBlbnRpcmVseSBmb3IgcnVudGltZS4gRm9yIENsb3N1cmUsIHR5cGVzIG11c3QgYmVcbiAgICogZXhwb3J0ZWQgYXMgZG93bnN0cmVhbSBjb2RlIHdpbGwgaW1wb3J0IHRoZSB0eXBlLlxuICAgKlxuICAgKiBUaGUgdHNpY2tsZSBwYXNzIHR1cm5zIGludGVyZmFjZXMgaW50byB2YWx1ZXMgYnkgZ2VuZXJhdGluZyBhIGBmdW5jdGlvbiBNeUludGVyZmFjZSgpIHt9YCBmb3JcbiAgICogdGhlbSwgc28gaW4gdGhlIHNlY29uZCBjb252ZXJzaW9uIHBhc3MsIFR5cGVTY3JpcHQgZG9lcyBleHBvcnQgYSB2YWx1ZSBmb3IgdGhlbS4gSG93ZXZlciBmb3JcbiAgICogcHVyZSB0eXBlZGVmcywgdHNpY2tsZSBvbmx5IGdlbmVyYXRlcyBhIHByb3BlcnR5IGFjY2VzcyB3aXRoIGEgSlNEb2MgY29tbWVudCwgc28gdGhleSBuZWVkIHRvXG4gICAqIGJlIGV4cG9ydGVkIGV4cGxpY2l0bHkgaGVyZS5cbiAgICovXG4gIHByaXZhdGUgZW1pdFR5cGVEZWZFeHBvcnRzKGV4cG9ydHM6IE5hbWVkU3ltYm9sW10pIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IGV4cCBvZiBleHBvcnRzKSB7XG4gICAgICBpZiAoZXhwLnN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkFsaWFzKVxuICAgICAgICBleHAuc3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKGV4cC5zeW0pO1xuICAgICAgY29uc3QgaXNUeXBlQWxpYXMgPSAoKGV4cC5zeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5UeXBlQWxpYXMpICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhwLnN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSA9PT0gMCkgfHxcbiAgICAgICAgICAoZXhwLnN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkludGVyZmFjZSkgIT09IDAgJiZcbiAgICAgICAgICAgICAgKGV4cC5zeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkgPT09IDA7XG4gICAgICBpZiAoIWlzVHlwZUFsaWFzKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHR5cGVOYW1lID0gdGhpcy5zeW1ib2xzVG9BbGlhc2VkTmFtZXMuZ2V0KGV4cC5zeW0pIHx8IGV4cC5zeW0ubmFtZTtcbiAgICAgIHRoaXMuZW1pdChgXFxuLyoqIEB0eXBlZGVmIHske3R5cGVOYW1lfX0gKi9cXG5leHBvcnRzLiR7ZXhwLm5hbWV9OyAvLyByZS1leHBvcnQgdHlwZWRlZmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGZyb20gaW1wbGljaXQgYGltcG9ydCB7fSBmcm9tICdwa2cnYCB0byBgaW1wb3J0IHt9IGZyb20gJ3BrZy9pbmRleCcuXG4gICAqIFR5cGVTY3JpcHQgc3VwcG9ydHMgdGhlIHNob3J0aGFuZCwgYnV0IG5vdCBhbGwgRVM2IG1vZHVsZSBsb2FkZXJzIGRvLlxuICAgKiBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEyNTk3XG4gICAqL1xuICBwcml2YXRlIHJlc29sdmVNb2R1bGVTcGVjaWZpZXIobW9kdWxlU3BlY2lmaWVyOiB0cy5FeHByZXNzaW9uKTogc3RyaW5nIHtcbiAgICBpZiAobW9kdWxlU3BlY2lmaWVyLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgbW9kdWxlU3BlY2lmaWVyIGtpbmQ6ICR7dHMuU3ludGF4S2luZFttb2R1bGVTcGVjaWZpZXIua2luZF19YCk7XG4gICAgfVxuICAgIGxldCBtb2R1bGVJZCA9IChtb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICBpZiAodGhpcy5ob3N0LmNvbnZlcnRJbmRleEltcG9ydFNob3J0aGFuZCkge1xuICAgICAgaWYgKCF0aGlzLnRzT3B0cyB8fCAhdGhpcy50c0hvc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29wdGlvbiBjb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQgcmVxdWlyZXMgdGhhdCBhbm5vdGF0ZSBiZSBjYWxsZWQgd2l0aCBhIFR5cGVTY3JpcHQgaG9zdCBhbmQgb3B0aW9ucy4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0gdHMucmVzb2x2ZU1vZHVsZU5hbWUobW9kdWxlSWQsIHRoaXMuZmlsZS5maWxlTmFtZSwgdGhpcy50c09wdHMsIHRoaXMudHNIb3N0KTtcbiAgICAgIGlmIChyZXNvbHZlZCAmJiByZXNvbHZlZC5yZXNvbHZlZE1vZHVsZSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRNb2R1bGUgPSBtb2R1bGVJZC5yZXBsYWNlKGV4dGVuc2lvbiwgJycpO1xuICAgICAgICBjb25zdCByZXNvbHZlZE1vZHVsZSA9IHJlc29sdmVkLnJlc29sdmVkTW9kdWxlLnJlc29sdmVkRmlsZU5hbWUucmVwbGFjZShleHRlbnNpb24sICcnKTtcbiAgICAgICAgaWYgKHJlc29sdmVkTW9kdWxlLmluZGV4T2YoJ25vZGVfbW9kdWxlcycpID09PSAtMSAmJlxuICAgICAgICAgICAgcmVxdWVzdGVkTW9kdWxlLnN1YnN0cihyZXF1ZXN0ZWRNb2R1bGUubGFzdEluZGV4T2YoJy8nKSkgIT09XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRNb2R1bGUuc3Vic3RyKHJlc29sdmVkTW9kdWxlLmxhc3RJbmRleE9mKCcvJykpKSB7XG4gICAgICAgICAgbW9kdWxlSWQgPSAnLi8nICtcbiAgICAgICAgICAgICAgcGF0aC5yZWxhdGl2ZShwYXRoLmRpcm5hbWUodGhpcy5maWxlLmZpbGVOYW1lKSwgcmVzb2x2ZWRNb2R1bGUpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZShwYXRoLnNlcCwgJy8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9kdWxlSWQ7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBlbWl0IG9mIGFuIFwiaW1wb3J0IC4uLlwiIHN0YXRlbWVudC5cbiAgICogV2UgbmVlZCB0byBkbyBhIGJpdCBvZiByZXdyaXRpbmcgc28gdGhhdCBpbXBvcnRlZCB0eXBlcyBzaG93IHVwIHVuZGVyIHRoZVxuICAgKiBjb3JyZWN0IG5hbWUgaW4gSlNEb2MuXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgZGVjbCB3YXMgaGFuZGxlZCwgZmFsc2UgdG8gYWxsb3cgZGVmYXVsdCBwcm9jZXNzaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0SW1wb3J0RGVjbGFyYXRpb24oZGVjbDogdHMuSW1wb3J0RGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgICB0aGlzLndyaXRlTGVhZGluZ1RyaXZpYShkZWNsKTtcbiAgICB0aGlzLmVtaXQoJ2ltcG9ydCcpO1xuICAgIGNvbnN0IGltcG9ydFBhdGggPSB0aGlzLnJlc29sdmVNb2R1bGVTcGVjaWZpZXIoZGVjbC5tb2R1bGVTcGVjaWZpZXIpO1xuICAgIGNvbnN0IGltcG9ydENsYXVzZSA9IGRlY2wuaW1wb3J0Q2xhdXNlO1xuICAgIGlmICghaW1wb3J0Q2xhdXNlKSB7XG4gICAgICAvLyBpbXBvcnQgJy4vZm9vJztcbiAgICAgIHRoaXMuZW1pdChgJyR7aW1wb3J0UGF0aH0nO2ApO1xuICAgICAgdGhpcy5hZGRTb3VyY2VNYXBwaW5nKGRlY2wpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgaW1wb3J0Q2xhdXNlLm5hbWUgfHxcbiAgICAgICAgKGltcG9ydENsYXVzZS5uYW1lZEJpbmRpbmdzICYmXG4gICAgICAgICBpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncy5raW5kID09PSB0cy5TeW50YXhLaW5kLk5hbWVkSW1wb3J0cykpIHtcbiAgICAgIHRoaXMudmlzaXQoaW1wb3J0Q2xhdXNlKTtcbiAgICAgIHRoaXMuZW1pdChgIGZyb20gJyR7aW1wb3J0UGF0aH0nO2ApO1xuICAgICAgdGhpcy5hZGRTb3VyY2VNYXBwaW5nKGRlY2wpO1xuXG4gICAgICAvLyBpbXBvcnRDbGF1c2UubmFtZSBpbXBsaWVzXG4gICAgICAvLyAgIGltcG9ydCBkZWZhdWx0TmFtZSBmcm9tIC4uLjtcbiAgICAgIC8vIG5hbWVkQmluZGluZ3MgYmVpbmcgTmFtZWRJbXBvcnRzIGltcGxpZXNcbiAgICAgIC8vICAgaW1wb3J0IHthLCBiIGFzIGN9IGZyb20gLi4uO1xuICAgICAgLy9cbiAgICAgIC8vIEJvdGggb2YgdGhlc2UgZm9ybXMgY3JlYXRlIGEgbG9jYWwgbmFtZSBcImFcIiwgd2hpY2ggYWZ0ZXIgVHlwZVNjcmlwdCBDb21tb25KUyBjb21waWxhdGlvblxuICAgICAgLy8gd2lsbCBiZWNvbWUgc29tZSByZW5hbWVkIHZhcmlhYmxlIGxpa2UgXCJtb2R1bGVfMS5kZWZhdWx0XCIgb3IgXCJtb2R1bGVfMS5hXCIgb3IgXCJtb2R1bGVfMS5jXCJcbiAgICAgIC8vIChmb3IgZGVmYXVsdCB2cyBuYW1lZCB2cyByZW5hbWVkIGJpbmRpbmdzLCByZXNwZWN0aXZlbHkpLlxuICAgICAgLy8gdHNpY2tsZSByZWZlcmVuY2VzIHR5cGVzIGluIEpTRG9jLiBCZWNhdXNlIHRoZSBtb2R1bGUgcHJlZml4ZXMgYXJlIG5vdCBwcmVkaWN0YWJsZSwgYW5kXG4gICAgICAvLyBiZWNhdXNlIFR5cGVTY3JpcHQgbWlnaHQgcmVtb3ZlIGltcG9ydHMgZW50aXJlbHkgaWYgdGhleSBhcmUgb25seSBmb3IgdHlwZXMsIHRoZSBjb2RlIGJlbG93XG4gICAgICAvLyBpbnNlcnRzIGFuIGFydGlmaWNpYWwgYGNvbnN0IHByZWZpeCA9IGdvb2cuZm9yd2FyZERlY2xhcmVgIGNhbGwgZm9yIHRoZSBtb2R1bGUsIGFuZCB0aGVuXG4gICAgICAvLyByZWdpc3RlcnMgYWxsIHN5bWJvbHMgZnJvbSB0aGlzIGltcG9ydCB0byBiZSBwcmVmaXhlZC5cbiAgICAgIHRoaXMuZm9yd2FyZERlY2xhcmUoZGVjbC5tb2R1bGVTcGVjaWZpZXIsIC8qKiBkZWZhdWx0IGltcG9ydD8gKi8gISFpbXBvcnRDbGF1c2UubmFtZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncyAmJlxuICAgICAgICBpbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncy5raW5kID09PSB0cy5TeW50YXhLaW5kLk5hbWVzcGFjZUltcG9ydCkge1xuICAgICAgLy8gaW1wb3J0ICogYXMgZm9vIGZyb20gLi4uO1xuICAgICAgdGhpcy52aXNpdChpbXBvcnRDbGF1c2UpO1xuICAgICAgdGhpcy5lbWl0KGAgZnJvbSAnJHtpbXBvcnRQYXRofSc7YCk7XG4gICAgICB0aGlzLmFkZFNvdXJjZU1hcHBpbmcoZGVjbCk7XG5cbiAgICAgIC8vIEludHJvZHVjZSBhIGdvb2cuZm9yd2FyZERlY2xhcmUgZm9yIHRoZSBtb2R1bGUsIHNvIHRoYXQgaWYgVHlwZVNjcmlwdCBkb2VzIG5vdCBlbWl0IHRoZVxuICAgICAgLy8gbW9kdWxlIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgaW4gdHlwZSBwb3NpdGlvbnMsIHRoZSBKU0RvYyBjb21tZW50cyBzdGlsbCByZWZlcmVuY2UgYSB2YWxpZFxuICAgICAgLy8gQ2xvc3VyZSBsZXZlbCBzeW1ib2wuXG4gICAgICBjb25zdCBzeW0gPSB0aGlzLnR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oZGVjbC5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgaWYgKCFzeW0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7ICAvLyBtb2R1bGVzIG1pZ2h0IG5vdCBoYXZlIGEgc3ltYm9sIGlmIHRoZXkgYXJlIHVudXNlZC5cbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yd2FyZERlY2xhcmUoZGVjbC5tb2R1bGVTcGVjaWZpZXIsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVycm9yVW5pbXBsZW1lbnRlZEtpbmQoZGVjbCwgJ3VuZXhwZWN0ZWQga2luZCBvZiBpbXBvcnQnKTtcbiAgICAgIHJldHVybiBmYWxzZTsgIC8vIFVzZSBkZWZhdWx0IHByb2Nlc3NpbmcuXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXROYW1lZFN5bWJvbHMoc3BlY2lmaWVyczogUmVhZG9ubHlBcnJheTx0cy5JbXBvcnRTcGVjaWZpZXJ8dHMuRXhwb3J0U3BlY2lmaWVyPik6XG4gICAgICBOYW1lZFN5bWJvbFtdIHtcbiAgICByZXR1cm4gc3BlY2lmaWVycy5tYXAoZSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBlLm5hbWUgbWlnaHQgYmUgcmVuYW1pbmcgc3ltYm9sIGFzIGluIGBleHBvcnQge0ZvbyBhcyBCYXJ9YCwgd2hlcmUgZS5uYW1lIHdvdWxkIGJlICdCYXInXG4gICAgICAgIC8vIGFuZCAhPSBzeW0ubmFtZS4gU3RvcmUgYXdheSB0aGUgbmFtZSBzbyBmb3J3YXJkRGVjbGFyZSBiZWxvdyBjYW4gZW1pdCB0aGUgcmlnaHQgbmFtZS5cbiAgICAgICAgbmFtZTogZ2V0SWRlbnRpZmllclRleHQoZS5uYW1lKSxcbiAgICAgICAgc3ltOiB0aGlzLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKGUubmFtZSksXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3J3YXJkRGVjbGFyZUNvdW50ZXIgPSAwO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGBnb29nLmZvcndhcmREZWNsYXJlYCBhbGlhcyBmb3IgZWFjaCBzeW1ib2wgZnJvbSB0aGUgZ2l2ZW4gbGlzdC5cbiAgICogQHBhcmFtIHNwZWNpZmllciB0aGUgaW1wb3J0IHNwZWNpZmllciwgaS5lLiBtb2R1bGUgcGF0aCAoXCJmcm9tICcuLi4nXCIpLlxuICAgKi9cbiAgcHJpdmF0ZSBmb3J3YXJkRGVjbGFyZShzcGVjaWZpZXI6IHRzLkV4cHJlc3Npb24sIGlzRGVmYXVsdEltcG9ydCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaW1wb3J0UGF0aCA9IHRoaXMucmVzb2x2ZU1vZHVsZVNwZWNpZmllcihzcGVjaWZpZXIpO1xuICAgIGNvbnN0IG1vZHVsZVN5bWJvbCA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihzcGVjaWZpZXIpO1xuICAgIHRoaXMuZW1pdCh0aGlzLmdldEZvcndhcmREZWNsYXJlVGV4dChpbXBvcnRQYXRoLCBtb2R1bGVTeW1ib2wsIGlzRGVmYXVsdEltcG9ydCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBjb25zdCB4ID0gZ29vZy5mb3J3YXJkRGVjbGFyZS4uLmAgdGV4dCBmb3IgYW4gaW1wb3J0IG9mIHRoZSBnaXZlbiBgaW1wb3J0UGF0aGAuXG4gICAqIFRoaXMgYWxzbyByZWdpc3RlcnMgYWxpYXNlcyBmb3Igc3ltYm9scyBmcm9tIHRoZSBtb2R1bGUgdGhhdCBtYXAgdG8gdGhpcyBmb3J3YXJkIGRlY2xhcmUuXG4gICAqL1xuICBwcml2YXRlIGdldEZvcndhcmREZWNsYXJlVGV4dChcbiAgICAgIGltcG9ydFBhdGg6IHN0cmluZywgbW9kdWxlU3ltYm9sOiB0cy5TeW1ib2x8dW5kZWZpbmVkLCBpc0RlZmF1bHRJbXBvcnQgPSBmYWxzZSk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuaG9zdC51bnR5cGVkKSByZXR1cm4gJyc7XG4gICAgY29uc3QgbnNJbXBvcnQgPSBlczVwcm9jZXNzb3IuZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQoaW1wb3J0UGF0aCk7XG4gICAgY29uc3QgZm9yd2FyZERlY2xhcmVQcmVmaXggPSBgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfJHsrK3RoaXMuZm9yd2FyZERlY2xhcmVDb3VudGVyfWA7XG4gICAgY29uc3QgbW9kdWxlTmFtZXNwYWNlID1cbiAgICAgICAgbnNJbXBvcnQgIT09IG51bGwgPyBuc0ltcG9ydCA6IHRoaXMuaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKHRoaXMuZmlsZS5maWxlTmFtZSwgaW1wb3J0UGF0aCk7XG4gICAgLy8gSW4gVHlwZVNjcmlwdCwgaW1wb3J0aW5nIGEgbW9kdWxlIGZvciB1c2UgaW4gYSB0eXBlIGFubm90YXRpb24gZG9lcyBub3QgY2F1c2UgYSBydW50aW1lIGxvYWQuXG4gICAgLy8gSW4gQ2xvc3VyZSBDb21waWxlciwgZ29vZy5yZXF1aXJlJ2luZyBhIG1vZHVsZSBjYXVzZXMgYSBydW50aW1lIGxvYWQsIHNvIGVtaXR0aW5nIHJlcXVpcmVzXG4gICAgLy8gaGVyZSB3b3VsZCBjYXVzZSBhIGNoYW5nZSBpbiBsb2FkIG9yZGVyLCB3aGljaCBpcyBvYnNlcnZhYmxlIChhbmQgY2FuIGxlYWQgdG8gZXJyb3JzKS5cbiAgICAvLyBJbnN0ZWFkLCBnb29nLmZvcndhcmREZWNsYXJlIHR5cGVzLCB3aGljaCBhbGxvd3MgdXNpbmcgdGhlbSBpbiB0eXBlIGFubm90YXRpb25zIHdpdGhvdXRcbiAgICAvLyBjYXVzaW5nIGEgbG9hZC4gU2VlIGJlbG93IGZvciB0aGUgZXhjZXB0aW9uIHRvIHRoZSBydWxlLlxuICAgIGxldCBlbWl0VGV4dCA9IGBjb25zdCAke2ZvcndhcmREZWNsYXJlUHJlZml4fSA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCIke21vZHVsZU5hbWVzcGFjZX1cIik7XFxuYDtcblxuICAgIC8vIFNjcmlwdHMgZG8gbm90IGhhdmUgYSBzeW1ib2wuIFNjcmlwdHMgY2FuIHN0aWxsIGJlIGltcG9ydGVkLCBlaXRoZXIgYXMgc2lkZSBlZmZlY3QgaW1wb3J0cyBvclxuICAgIC8vIHdpdGggYW4gZW1wdHkgaW1wb3J0IHNldCAoXCJ7fVwiKS4gVHlwZVNjcmlwdCBkb2VzIG5vdCBlbWl0IGEgcnVudGltZSBsb2FkIGZvciBhbiBpbXBvcnQgd2l0aFxuICAgIC8vIGFuIGVtcHR5IGxpc3Qgb2Ygc3ltYm9scywgYnV0IHRoZSBpbXBvcnQgZm9yY2VzIGFueSBnbG9iYWwgZGVjbGFyYXRpb25zIGZyb20gdGhlIGxpYnJhcnkgdG9cbiAgICAvLyBiZSB2aXNpYmxlLCB3aGljaCBpcyB3aGF0IHVzZXJzIHVzZSB0aGlzIGZvci4gTm8gc3ltYm9scyBmcm9tIHRoZSBzY3JpcHQgbmVlZCBmb3J3YXJkXG4gICAgLy8gZGVjbGFyYXRpb24sIHNvIGp1c3QgcmV0dXJuLlxuICAgIGlmICghbW9kdWxlU3ltYm9sKSByZXR1cm4gJyc7XG4gICAgdGhpcy5mb3J3YXJkRGVjbGFyZWRNb2R1bGVzLmFkZChtb2R1bGVTeW1ib2wpO1xuICAgIGNvbnN0IGV4cG9ydHMgPSB0aGlzLnR5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShtb2R1bGVTeW1ib2wpO1xuICAgIGNvbnN0IGhhc1ZhbHVlcyA9IGV4cG9ydHMuc29tZShlID0+IHtcbiAgICAgIGNvbnN0IGlzVmFsdWUgPSAoZS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSAhPT0gMDtcbiAgICAgIGNvbnN0IGlzQ29uc3RFbnVtID0gKGUuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5Db25zdEVudW0pICE9PSAwO1xuICAgICAgLy8gY29uc3QgZW51bXMgYXJlIGlubGluZWQgYnkgVHlwZVNjcmlwdCAoaWYgcHJlc2VydmVDb25zdEVudW1zPWZhbHNlKSwgc28gdGhlcmUgaXMgbmV2ZXIgYVxuICAgICAgLy8gdmFsdWUgaW1wb3J0IGdlbmVyYXRlZCBmb3IgdGhlbS4gVGhhdCBtZWFucyBmb3IgdGhlIHB1cnBvc2Ugb2YgZm9yY2UtaW1wb3J0aW5nIG1vZHVsZXMsXG4gICAgICAvLyB0aGV5IGRvIG5vdCBjb3VudCBhcyB2YWx1ZXMuIElmIHByZXNlcnZlQ29uc3RFbnVtcz10cnVlLCB0aGlzIHNob3VsZG4ndCBodXJ0LlxuICAgICAgcmV0dXJuIGlzVmFsdWUgJiYgIWlzQ29uc3RFbnVtO1xuICAgIH0pO1xuICAgIGlmICghaGFzVmFsdWVzKSB7XG4gICAgICAvLyBDbG9zdXJlIENvbXBpbGVyJ3MgdG9vbGNoYWluIHdpbGwgZHJvcCBmaWxlcyB0aGF0IGFyZSBuZXZlciBnb29nLnJlcXVpcmUnZCAqYmVmb3JlKiB0eXBlXG4gICAgICAvLyBjaGVja2luZyAoZS5nLiB3aGVuIHVzaW5nIC0tY2xvc3VyZV9lbnRyeV9wb2ludCBvciBzaW1pbGFyIHRvb2xzKS4gVGhpcyBjYXVzZXMgZXJyb3JzXG4gICAgICAvLyBjb21wbGFpbmluZyBhYm91dCB2YWx1ZXMgbm90IG1hdGNoaW5nICdOb1Jlc29sdmVkVHlwZScsIG9yIG1vZHVsZXMgbm90IGhhdmluZyBhIGNlcnRhaW5cbiAgICAgIC8vIG1lbWJlci5cbiAgICAgIC8vIFRvIGZpeCwgZXhwbGljaXRseSBnb29nLnJlcXVpcmUoKSBtb2R1bGVzIHRoYXQgb25seSBleHBvcnQgdHlwZXMuIFRoaXMgc2hvdWxkIHVzdWFsbHkgbm90XG4gICAgICAvLyBjYXVzZSBicmVha2FnZXMgZHVlIHRvIGxvYWQgb3JkZXIgKGFzIG5vIHN5bWJvbHMgYXJlIGFjY2Vzc2libGUgZnJvbSB0aGUgbW9kdWxlIC0gdGhvdWdoXG4gICAgICAvLyBjb250cml2ZWQgY29kZSBjb3VsZCBvYnNlcnZlIGNoYW5nZXMgaW4gc2lkZSBlZmZlY3RzKS5cbiAgICAgIC8vIFRoaXMgaXMgYSBoZXVyaXN0aWMgLSBpZiB0aGUgbW9kdWxlIGV4cG9ydHMgc29tZSB2YWx1ZXMsIGJ1dCB0aG9zZSBhcmUgbmV2ZXIgaW1wb3J0ZWQsXG4gICAgICAvLyB0aGUgZmlsZSB3aWxsIHN0aWxsIGVuZCB1cCBub3QgYmVpbmcgaW1wb3J0ZWQuIEhvcGVmdWxseSBtb2R1bGVzIHRoYXQgZXhwb3J0IHZhbHVlcyBhcmVcbiAgICAgIC8vIGltcG9ydGVkIGZvciB0aGVpciB2YWx1ZSBpbiBzb21lIHBsYWNlLlxuICAgICAgZW1pdFRleHQgKz0gYGdvb2cucmVxdWlyZShcIiR7bW9kdWxlTmFtZXNwYWNlfVwiKTsgLy8gZm9yY2UgdHlwZS1vbmx5IG1vZHVsZSB0byBiZSBsb2FkZWRcXG5gO1xuICAgIH1cbiAgICBmb3IgKGxldCBzeW0gb2YgZXhwb3J0cykge1xuICAgICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkFsaWFzKSB7XG4gICAgICAgIHN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW0pO1xuICAgICAgfVxuICAgICAgLy8gZ29vZzogaW1wb3J0cyBkb24ndCBhY3R1YWxseSB1c2UgdGhlIC5kZWZhdWx0IHByb3BlcnR5IHRoYXQgVFMgdGhpbmtzIHRoZXkgaGF2ZS5cbiAgICAgIGNvbnN0IHF1YWxpZmllZE5hbWUgPSBuc0ltcG9ydCAmJiBpc0RlZmF1bHRJbXBvcnQgPyBmb3J3YXJkRGVjbGFyZVByZWZpeCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZERlY2xhcmVQcmVmaXggKyAnLicgKyBzeW0ubmFtZTtcbiAgICAgIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLnNldChzeW0sIHF1YWxpZmllZE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZW1pdFRleHQ7XG4gIH1cblxuICBwcml2YXRlIHZpc2l0Q2xhc3NEZWNsYXJhdGlvbihjbGFzc0RlY2w6IHRzLkNsYXNzRGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLmFkZFNvdXJjZU1hcHBpbmcoY2xhc3NEZWNsKTtcbiAgICBjb25zdCBvbGREZWNvcmF0b3JDb252ZXJ0ZXIgPSB0aGlzLmN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXI7XG4gICAgdGhpcy5jdXJyZW50RGVjb3JhdG9yQ29udmVydGVyID1cbiAgICAgICAgbmV3IGRlY29yYXRvci5EZWNvcmF0b3JDbGFzc1Zpc2l0b3IodGhpcy50eXBlQ2hlY2tlciwgdGhpcywgY2xhc3NEZWNsLCB0aGlzLmltcG9ydGVkTmFtZXMpO1xuXG4gICAgY29uc3QgZG9jVGFncyA9IHRoaXMuZ2V0SlNEb2MoY2xhc3NEZWNsKSB8fCBbXTtcbiAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKGNsYXNzRGVjbCwgdHMuTW9kaWZpZXJGbGFncy5BYnN0cmFjdCkpIHtcbiAgICAgIGRvY1RhZ3MucHVzaCh7dGFnTmFtZTogJ2Fic3RyYWN0J30pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ob3N0LnVudHlwZWQpIHtcbiAgICAgIHRoaXMubWF5YmVBZGRUZW1wbGF0ZUNsYXVzZShkb2NUYWdzLCBjbGFzc0RlY2wpO1xuICAgICAgdGhpcy5tYXliZUFkZEhlcml0YWdlQ2xhdXNlcyhkb2NUYWdzLCBjbGFzc0RlY2wpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnXFxuJyk7XG4gICAgaWYgKGRvY1RhZ3MubGVuZ3RoID4gMCkgdGhpcy5lbWl0KGpzZG9jLnRvU3RyaW5nKGRvY1RhZ3MpKTtcbiAgICBkZWNvcmF0b3IudmlzaXRDbGFzc0NvbnRlbnRJbmNsdWRpbmdEZWNvcmF0b3JzKGNsYXNzRGVjbCwgdGhpcywgdGhpcy5jdXJyZW50RGVjb3JhdG9yQ29udmVydGVyKTtcbiAgICB0aGlzLmVtaXRUeXBlQW5ub3RhdGlvbnNIZWxwZXIoY2xhc3NEZWNsKTtcblxuICAgIHRoaXMuY3VycmVudERlY29yYXRvckNvbnZlcnRlciA9IG9sZERlY29yYXRvckNvbnZlcnRlcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdEludGVyZmFjZShpZmFjZTogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pIHtcbiAgICAvLyBJZiB0aGlzIHN5bWJvbCBpcyBib3RoIGEgdHlwZSBhbmQgYSB2YWx1ZSwgd2UgY2Fubm90IGVtaXQgYm90aCBpbnRvIENsb3N1cmUnc1xuICAgIC8vIHNpbmdsZSBuYW1lc3BhY2UuXG4gICAgY29uc3Qgc3ltID0gdGhpcy5tdXN0R2V0U3ltYm9sQXRMb2NhdGlvbihpZmFjZS5uYW1lKTtcbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpIHJldHVybjtcblxuICAgIGNvbnN0IGRvY1RhZ3MgPSB0aGlzLmdldEpTRG9jKGlmYWNlKSB8fCBbXTtcbiAgICBkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdyZWNvcmQnfSk7XG4gICAgaWYgKCF0aGlzLmhvc3QudW50eXBlZCkge1xuICAgICAgdGhpcy5tYXliZUFkZFRlbXBsYXRlQ2xhdXNlKGRvY1RhZ3MsIGlmYWNlKTtcbiAgICAgIHRoaXMubWF5YmVBZGRIZXJpdGFnZUNsYXVzZXMoZG9jVGFncywgaWZhY2UpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnXFxuJyk7XG4gICAgdGhpcy5lbWl0KGpzZG9jLnRvU3RyaW5nKGRvY1RhZ3MpKTtcblxuICAgIGlmIChoYXNNb2RpZmllckZsYWcoaWZhY2UsIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSkgdGhpcy5lbWl0KCdleHBvcnQgJyk7XG4gICAgY29uc3QgbmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGlmYWNlLm5hbWUpO1xuICAgIHRoaXMuZW1pdChgZnVuY3Rpb24gJHtuYW1lfSgpIHt9XFxuYCk7XG5cbiAgICB0aGlzLmVtaXQoYFxcblxcbmZ1bmN0aW9uICR7bmFtZX1fdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcXG5gKTtcbiAgICBjb25zdCBtZW1iZXJOYW1lc3BhY2UgPSBbbmFtZSwgJ3Byb3RvdHlwZSddO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBpZmFjZS5tZW1iZXJzKSB7XG4gICAgICBjb25zdCBpc09wdGlvbmFsID0gZWxlbS5xdWVzdGlvblRva2VuICE9IG51bGw7XG4gICAgICB0aGlzLnZpc2l0UHJvcGVydHkobWVtYmVyTmFtZXNwYWNlLCBlbGVtLCBpc09wdGlvbmFsKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KGB9XFxuYCk7XG4gIH1cblxuICAvKipcbiAgICogZW1pdFR5cGVBbm5vdGF0aW9uc0hlbHBlciBwcm9kdWNlcyBhIF90c2lja2xlX3R5cGVBbm5vdGF0aW9uc0hlbHBlcigpIHdoZXJlXG4gICAqIG5vbmUgZXhpc3RlZCBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiBJdCdzIG5lY2Vzc2FyeSBpbiB0aGUgY2FzZSB3aGVyZVxuICAgKiBUeXBlU2NyaXB0IHN5bnRheCBzcGVjaWZpZXMgdGhlcmUgYXJlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvbiB0aGUgY2xhc3MsXG4gICAqIGJlY2F1c2UgdG8gZGVjbGFyZSB0aGVzZSBpbiBDbG9zdXJlIHlvdSBtdXN0IGRlY2xhcmUgdGhlc2UgaW4gYSBtZXRob2RcbiAgICogc29tZXdoZXJlLlxuICAgKi9cbiAgcHJpdmF0ZSBlbWl0VHlwZUFubm90YXRpb25zSGVscGVyKGNsYXNzRGVjbDogdHMuQ2xhc3NEZWNsYXJhdGlvbikge1xuICAgIC8vIEdhdGhlciBwYXJhbWV0ZXIgcHJvcGVydGllcyBmcm9tIHRoZSBjb25zdHJ1Y3RvciwgaWYgaXQgZXhpc3RzLlxuICAgIGNvbnN0IGN0b3JzOiB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uW10gPSBbXTtcbiAgICBsZXQgcGFyYW1Qcm9wczogdHMuUGFyYW1ldGVyRGVjbGFyYXRpb25bXSA9IFtdO1xuICAgIGNvbnN0IG5vblN0YXRpY1Byb3BzOiB0cy5Qcm9wZXJ0eURlY2xhcmF0aW9uW10gPSBbXTtcbiAgICBjb25zdCBzdGF0aWNQcm9wczogdHMuUHJvcGVydHlEZWNsYXJhdGlvbltdID0gW107XG4gICAgY29uc3QgYWJzdHJhY3RNZXRob2RzOiB0cy5GdW5jdGlvbkxpa2VEZWNsYXJhdGlvbltdID0gW107XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgY2xhc3NEZWNsLm1lbWJlcnMpIHtcbiAgICAgIGlmIChtZW1iZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3Rvcikge1xuICAgICAgICBjdG9ycy5wdXNoKG1lbWJlciBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobWVtYmVyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuUHJvcGVydHlEZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBwcm9wID0gbWVtYmVyIGFzIHRzLlByb3BlcnR5RGVjbGFyYXRpb247XG4gICAgICAgIGNvbnN0IGlzU3RhdGljID0gaGFzTW9kaWZpZXJGbGFnKHByb3AsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKTtcbiAgICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgICAgc3RhdGljUHJvcHMucHVzaChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub25TdGF0aWNQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGhhc01vZGlmaWVyRmxhZyhtZW1iZXIsIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpICYmXG4gICAgICAgICAgKG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uIHx8XG4gICAgICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLkdldEFjY2Vzc29yIHx8XG4gICAgICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLlNldEFjY2Vzc29yKSkge1xuICAgICAgICBhYnN0cmFjdE1ldGhvZHMucHVzaChcbiAgICAgICAgICAgIG1lbWJlciBhcyB0cy5NZXRob2REZWNsYXJhdGlvbiB8IHRzLkdldEFjY2Vzc29yRGVjbGFyYXRpb24gfCB0cy5TZXRBY2Nlc3NvckRlY2xhcmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3RvciA9IGN0b3JzWzBdO1xuICAgICAgcGFyYW1Qcm9wcyA9IGN0b3IucGFyYW1ldGVycy5maWx0ZXIocCA9PiBoYXNNb2RpZmllckZsYWcocCwgRklFTERfREVDTEFSQVRJT05fTU9ESUZJRVJTKSk7XG4gICAgfVxuXG4gICAgaWYgKG5vblN0YXRpY1Byb3BzLmxlbmd0aCA9PT0gMCAmJiBwYXJhbVByb3BzLmxlbmd0aCA9PT0gMCAmJiBzdGF0aWNQcm9wcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgYWJzdHJhY3RNZXRob2RzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAhKHRoaXMuY3VycmVudERlY29yYXRvckNvbnZlcnRlciAmJiB0aGlzLmN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXIuZm91bmREZWNvcmF0b3JzKCkpKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgbm8gbWVtYmVycyBzbyB3ZSBkb24ndCBuZWVkIHRvIGVtaXQgYW55IHR5cGVcbiAgICAgIC8vIGFubm90YXRpb25zIGhlbHBlci5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNsYXNzRGVjbC5uYW1lKSByZXR1cm47XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZ2V0SWRlbnRpZmllclRleHQoY2xhc3NEZWNsLm5hbWUpO1xuXG4gICAgdGhpcy5lbWl0KGBcXG5cXG5mdW5jdGlvbiAke2NsYXNzTmFtZX1fdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcXG5gKTtcbiAgICBpZiAodGhpcy5jdXJyZW50RGVjb3JhdG9yQ29udmVydGVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnREZWNvcmF0b3JDb252ZXJ0ZXIuZW1pdE1ldGFkYXRhVHlwZUFubm90YXRpb25zSGVscGVycygpO1xuICAgIH1cbiAgICBzdGF0aWNQcm9wcy5mb3JFYWNoKHAgPT4gdGhpcy52aXNpdFByb3BlcnR5KFtjbGFzc05hbWVdLCBwKSk7XG4gICAgY29uc3QgbWVtYmVyTmFtZXNwYWNlID0gW2NsYXNzTmFtZSwgJ3Byb3RvdHlwZSddO1xuICAgIG5vblN0YXRpY1Byb3BzLmZvckVhY2goKHApID0+IHRoaXMudmlzaXRQcm9wZXJ0eShtZW1iZXJOYW1lc3BhY2UsIHApKTtcbiAgICBwYXJhbVByb3BzLmZvckVhY2goKHApID0+IHRoaXMudmlzaXRQcm9wZXJ0eShtZW1iZXJOYW1lc3BhY2UsIHApKTtcblxuICAgIGZvciAoY29uc3QgZm5EZWNsIG9mIGFic3RyYWN0TWV0aG9kcykge1xuICAgICAgY29uc3QgbmFtZSA9IHRoaXMucHJvcGVydHlOYW1lKGZuRGVjbCk7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhpcy5lcnJvcihmbkRlY2wsICdhbm9ueW1vdXMgYWJzdHJhY3QgZnVuY3Rpb24nKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWdzID0gaGFzRXhwb3J0aW5nRGVjb3JhdG9yKGZuRGVjbCwgdGhpcy50eXBlQ2hlY2tlcikgPyBbe3RhZ05hbWU6ICdleHBvcnQnfV0gOiBbXTtcbiAgICAgIGNvbnN0IHBhcmFtTmFtZXMgPSB0aGlzLmVtaXRGdW5jdGlvblR5cGUoW2ZuRGVjbF0sIHRhZ3MpO1xuICAgICAgLy8gbWVtYmVyTmFtZXNwYWNlIGJlY2F1c2UgYWJzdHJhY3QgbWV0aG9kcyBjYW5ub3QgYmUgc3RhdGljIGluIFR5cGVTY3JpcHQuXG4gICAgICB0aGlzLmVtaXQoYCR7bWVtYmVyTmFtZXNwYWNlLmpvaW4oJy4nKX0uJHtuYW1lfSA9IGZ1bmN0aW9uKCR7cGFyYW1OYW1lcy5qb2luKCcsICcpfSkge307XFxuYCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KGB9XFxuYCk7XG4gIH1cblxuICBwcml2YXRlIHByb3BlcnR5TmFtZShwcm9wOiB0cy5OYW1lZERlY2xhcmF0aW9uKTogc3RyaW5nfG51bGwge1xuICAgIGlmICghcHJvcC5uYW1lKSByZXR1cm4gbnVsbDtcblxuICAgIHN3aXRjaCAocHJvcC5uYW1lLmtpbmQpIHtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JZGVudGlmaWVyOlxuICAgICAgICByZXR1cm4gZ2V0SWRlbnRpZmllclRleHQocHJvcC5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgIC8vIEUuZy4gaW50ZXJmYWNlIEZvbyB7ICdiYXInOiBudW1iZXI7IH1cbiAgICAgICAgLy8gSWYgJ2JhcicgaXMgYSBuYW1lIHRoYXQgaXMgbm90IHZhbGlkIGluIENsb3N1cmUgdGhlbiB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvLlxuICAgICAgICBjb25zdCB0ZXh0ID0gKHByb3AubmFtZSBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgICAgICBpZiAoIWlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lKHRleHQpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbmFsIElmIHRydWUsIHByb3BlcnR5IGlzIG9wdGlvbmFsIChlLmcuIHdyaXR0ZW4gXCJmb28/OiBzdHJpbmdcIikuXG4gICAqL1xuICBwcml2YXRlIHZpc2l0UHJvcGVydHkobmFtZXNwYWNlOiBzdHJpbmdbXSwgcHJvcDogdHMuRGVjbGFyYXRpb24sIG9wdGlvbmFsID0gZmFsc2UpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5wcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aGlzLmVtaXQoYC8qIFRPRE86IGhhbmRsZSBzdHJhbmdlIG1lbWJlcjpcXG4ke3RoaXMuZXNjYXBlRm9yQ29tbWVudChwcm9wLmdldFRleHQoKSl9XFxuKi9cXG5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdHlwZSA9IHRoaXMudHlwZVRvQ2xvc3VyZShwcm9wKTtcbiAgICAvLyBXaGVuIGEgcHJvcGVydHkgaXMgb3B0aW9uYWwsIGUuZy5cbiAgICAvLyAgIGZvbz86IHN0cmluZztcbiAgICAvLyBUaGVuIHRoZSBUeXBlU2NyaXB0IHR5cGUgb2YgdGhlIHByb3BlcnR5IGlzIHN0cmluZ3x1bmRlZmluZWQsIHRoZVxuICAgIC8vIHR5cGVUb0Nsb3N1cmUgdHJhbnNsYXRpb24gaGFuZGxlcyBpdCBjb3JyZWN0bHksIGFuZCBzdHJpbmd8dW5kZWZpbmVkIGlzXG4gICAgLy8gaG93IHlvdSB3cml0ZSBhbiBvcHRpb25hbCBwcm9wZXJ0eSBpbiBDbG9zdXJlLlxuICAgIC8vXG4gICAgLy8gQnV0IGluIHRoZSBzcGVjaWFsIGNhc2Ugb2YgYW4gb3B0aW9uYWwgcHJvcGVydHkgd2l0aCB0eXBlIGFueTpcbiAgICAvLyAgIGZvbz86IGFueTtcbiAgICAvLyBUaGUgVHlwZVNjcmlwdCB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBpcyBqdXN0IFwiYW55XCIgKGJlY2F1c2UgYW55IGluY2x1ZGVzXG4gICAgLy8gdW5kZWZpbmVkIGFzIHdlbGwpIHNvIG91ciBkZWZhdWx0IHRyYW5zbGF0aW9uIG9mIHRoZSB0eXBlIGlzIGp1c3QgXCI/XCIuXG4gICAgLy8gVG8gbWFyayB0aGUgcHJvcGVydHkgYXMgb3B0aW9uYWwgaW4gQ2xvc3VyZSBpdCBtdXN0IGhhdmUgXCJ8dW5kZWZpbmVkXCIsXG4gICAgLy8gc28gdGhlIENsb3N1cmUgdHlwZSBtdXN0IGJlID98dW5kZWZpbmVkLlxuICAgIGlmIChvcHRpb25hbCAmJiB0eXBlID09PSAnPycpIHR5cGUgKz0gJ3x1bmRlZmluZWQnO1xuXG4gICAgY29uc3QgdGFncyA9IHRoaXMuZ2V0SlNEb2MocHJvcCkgfHwgW107XG4gICAgdGFncy5wdXNoKHt0YWdOYW1lOiAndHlwZScsIHR5cGV9KTtcbiAgICBpZiAoaGFzRXhwb3J0aW5nRGVjb3JhdG9yKHByb3AsIHRoaXMudHlwZUNoZWNrZXIpKSB7XG4gICAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICdleHBvcnQnfSk7XG4gICAgfVxuICAgIC8vIEF2b2lkIHByaW50aW5nIGFubm90YXRpb25zIHRoYXQgY2FuIGNvbmZsaWN0IHdpdGggQHR5cGVcbiAgICAvLyBUaGlzIGF2b2lkcyBDbG9zdXJlJ3MgZXJyb3IgXCJ0eXBlIGFubm90YXRpb24gaW5jb21wYXRpYmxlIHdpdGggb3RoZXIgYW5ub3RhdGlvbnNcIlxuICAgIHRoaXMuZW1pdChqc2RvYy50b1N0cmluZyh0YWdzLCBuZXcgU2V0KFsncGFyYW0nLCAncmV0dXJuJ10pKSk7XG4gICAgbmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZV0pO1xuICAgIHRoaXMuZW1pdChgJHtuYW1lc3BhY2Uuam9pbignLicpfTtcXG5gKTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRUeXBlQWxpYXMobm9kZTogdHMuVHlwZUFsaWFzRGVjbGFyYXRpb24pIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHJldHVybjtcblxuICAgIC8vIElmIHRoZSB0eXBlIGlzIGFsc28gZGVmaW5lZCBhcyBhIHZhbHVlLCBza2lwIGVtaXR0aW5nIGl0LiBDbG9zdXJlIGNvbGxhcHNlcyB0eXBlICYgdmFsdWVcbiAgICAvLyBuYW1lc3BhY2VzLCB0aGUgdHdvIGVtaXRzIHdvdWxkIGNvbmZsaWN0IGlmIHRzaWNrbGUgZW1pdHRlZCBib3RoLlxuICAgIGNvbnN0IHN5bSA9IHRoaXMubXVzdEdldFN5bWJvbEF0TG9jYXRpb24obm9kZS5uYW1lKTtcbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpIHJldHVybjtcblxuICAgIC8vIFdyaXRlIGEgQ2xvc3VyZSB0eXBlZGVmLCB3aGljaCBpbnZvbHZlcyBhbiB1bnVzZWQgXCJ2YXJcIiBkZWNsYXJhdGlvbi5cbiAgICAvLyBOb3RlOiBpbiB0aGUgY2FzZSBvZiBhbiBleHBvcnQsIHdlIGNhbm5vdCBlbWl0IGEgbGl0ZXJhbCBcInZhclwiIGJlY2F1c2VcbiAgICAvLyBUeXBlU2NyaXB0IGRyb3BzIGV4cG9ydHMgdGhhdCBhcmUgbmV2ZXIgYXNzaWduZWQgdG8gKGFuZCBDbG9zdXJlXG4gICAgLy8gcmVxdWlyZXMgdXMgdG8gbm90IGFzc2lnbiB0byB0eXBlZGVmIGV4cG9ydHMpLiAgSW5zdGVhZCwgZW1pdCB0aGVcbiAgICAvLyBcImV4cG9ydHMuZm9vO1wiIGxpbmUgZGlyZWN0bHkgaW4gdGhhdCBjYXNlLlxuICAgIHRoaXMubmV3VHlwZVRyYW5zbGF0b3Iobm9kZSkuYmxhY2tsaXN0VHlwZVBhcmFtZXRlcnMoXG4gICAgICAgIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCBub2RlLnR5cGVQYXJhbWV0ZXJzKTtcblxuICAgIGNvbnN0IHR5cGVTdHIgPSB0aGlzLnR5cGVUb0Nsb3N1cmUobm9kZSwgdW5kZWZpbmVkLCB0cnVlIC8qIHJlc29sdmVBbGlhcyAqLyk7XG4gICAgdGhpcy5lbWl0KGBcXG4vKiogQHR5cGVkZWYgeyR7dHlwZVN0cn19ICovXFxuYCk7XG4gICAgaWYgKGhhc01vZGlmaWVyRmxhZyhub2RlLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXhwb3J0cy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCd2YXIgJyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChgJHtub2RlLm5hbWUuZ2V0VGV4dCgpfTtcXG5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRFbnVtVHlwZSBjb21wdXRlcyB0aGUgQ2xvc3VyZSB0eXBlIG9mIGFuIGVudW0sIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBtZW1iZXJzXG4gICAqIGFuZCBnYXRoZXJpbmcgdGhlaXIgdHlwZXMuXG4gICAqL1xuICBwcml2YXRlIGdldEVudW1UeXBlKGVudW1EZWNsOiB0cy5FbnVtRGVjbGFyYXRpb24pOiAnbnVtYmVyfHN0cmluZyd8J251bWJlcid8J3N0cmluZyd8Jz8nIHtcbiAgICBsZXQgaGFzTnVtYmVyID0gZmFsc2U7XG4gICAgbGV0IGhhc1N0cmluZyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGVudW1EZWNsLm1lbWJlcnMpIHtcbiAgICAgIGlmIChtZW1iZXIuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obWVtYmVyLmluaXRpYWxpemVyKTtcbiAgICAgICAgLy8gTm90ZTogY2hlY2tpbmcgYWdhaW5zdCAnTnVtYmVyTGlrZScgaW5zdGVhZCBvZiBqdXN0ICdOdW1iZXInIG1lYW5zIHRoaXMgY29kZVxuICAgICAgICAvLyBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gICBNRU1CRVIgPSAzLCAgLy8gVHlwZUZsYWdzLk51bWJlckxpdGVyYWxcbiAgICAgICAgLy8gYW5kXG4gICAgICAgIC8vICAgTUVNQkVSID0gc29tZUZ1bmN0aW9uKCksICAvLyBUeXBlRmxhZ3MuTnVtYmVyXG4gICAgICAgIGlmICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLk51bWJlckxpa2UpIHtcbiAgICAgICAgICBoYXNOdW1iZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuZmxhZ3MgJiB0cy5UeXBlRmxhZ3MuU3RyaW5nTGlrZSkge1xuICAgICAgICAgIGhhc1N0cmluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRW51bSBjb250YWlucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIHN0cmluZyBvciBhIG51bWJlcjsgYmFpbC5cbiAgICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZW1iZXJzIHdpdGhvdXQgaW5pdGlhbGl6ZXJzIGRlZmF1bHQgdG8gbnVtZXJpYy5cbiAgICAgICAgaGFzTnVtYmVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc051bWJlciAmJiBoYXNTdHJpbmcpIHtcbiAgICAgIHJldHVybiAnPyc7ICAvLyBDbG9zdXJlJ3MgbmV3IHR5cGUgaW5mZXJlbmNlIGRvZXNuJ3Qgc3VwcG9ydCBlbnVtcyBvZiB1bmlvbnMuXG4gICAgfSBlbHNlIGlmIChoYXNOdW1iZXIpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKGhhc1N0cmluZykge1xuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQZXJoYXBzIGFuIGVtcHR5IGVudW0/XG4gICAgICByZXR1cm4gJz8nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYW4gRW51bURlY2xhcmF0aW9uIGludG8gYSBDbG9zdXJlIHR5cGUuIEFsd2F5cyBlbWl0cyBhIENsb3N1cmUgdHlwZSwgZXZlbiBpbiB1bnR5cGVkXG4gICAqIG1vZGUsIGFzIHRoYXQgc2hvdWxkIGJlIGhhcm1sZXNzIChpdCBvbmx5IGV2ZXIgdXNlcyB0aGUgbnVtYmVyIHR5cGUpLlxuICAgKi9cbiAgcHJpdmF0ZSBwcm9jZXNzRW51bShub2RlOiB0cy5FbnVtRGVjbGFyYXRpb24pIHtcbiAgICAvLyBFbWl0IHRoZSBlbnVtIGRlY2xhcmF0aW9uLCB3aGljaCBsb29rcyBsaWtlOlxuICAgIC8vICAgLyoqIEBlbnVtIHtudW1iZXJ9ICovXG4gICAgLy8gICBjb25zdCBGb28gPSB7QkFSOiAwLCBCQVo6IDEsIC4uLn07XG4gICAgLy8gICBleHBvcnQge0Zvb307ICAvLyBldmVuIGlmIG9yaWdpbmFsbHkgZXhwb3J0ZWQgb24gb25lIGxpbmUuXG4gICAgLy8gVGhpcyBkZWNsYXJlcyBhbiBlbnVtIHR5cGUgZm9yIENsb3N1cmUgQ29tcGlsZXIgKGFuZCBDbG9zdXJlIEpTIHVzZXJzIG9mIHRoaXMgVFMgY29kZSkuXG4gICAgLy8gU3BsaXR0aW5nIHRoZSBlbnVtIGludG8gZGVjbGFyYXRpb24gYW5kIGV4cG9ydCBpcyByZXF1aXJlZCBzbyB0aGF0IGxvY2FsIHJlZmVyZW5jZXMgdG8gdGhlXG4gICAgLy8gdHlwZSByZXNvbHZlIChcIkB0eXBlIHtGb299XCIpLlxuICAgIHRoaXMuZW1pdCgnXFxuJyk7XG4gICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZS5nZXRUZXh0KCk7XG5cbiAgICBjb25zdCBlbnVtVHlwZSA9IHRoaXMuZ2V0RW51bVR5cGUobm9kZSk7XG4gICAgdGhpcy5lbWl0KGAvKiogQGVudW0geyR7ZW51bVR5cGV9fSAqL1xcbmApO1xuICAgIHRoaXMuZW1pdChgY29uc3QgJHtuYW1lfTogRG9udFR5cGVDaGVja01lID0ge2ApO1xuICAgIC8vIEVtaXQgZW51bSB2YWx1ZXMgKCdCQVI6IDAsJykuXG4gICAgbGV0IGVudW1JbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2Ygbm9kZS5tZW1iZXJzKSB7XG4gICAgICBjb25zdCBtZW1iZXJOYW1lID0gbWVtYmVyLm5hbWUuZ2V0VGV4dCgpO1xuICAgICAgLy8gRW1pdCBhbnkgY29tbWVudHMgYW5kIGxlYWRpbmcgd2hpdGVzcGFjZSBvbiB0aGUgZW51bSB2YWx1ZSBkZWZpbml0aW9uLlxuICAgICAgdGhpcy53cml0ZUxlYWRpbmdUcml2aWEobWVtYmVyKTtcbiAgICAgIHRoaXMuZW1pdChgJHttZW1iZXJOYW1lfTogYCk7XG5cbiAgICAgIGlmIChtZW1iZXIuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgY29uc3QgZW51bUNvbnN0VmFsdWUgPSB0aGlzLnR5cGVDaGVja2VyLmdldENvbnN0YW50VmFsdWUobWVtYmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnVtQ29uc3RWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBlbnVtSW5kZXggPSBlbnVtQ29uc3RWYWx1ZSArIDE7XG4gICAgICAgICAgdGhpcy5lbWl0KGVudW1Db25zdFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vbi1udW1lcmljIGVudW0gdmFsdWUgKHN0cmluZyBvciBhbiBleHByZXNzaW9uKS5cbiAgICAgICAgICAvLyBFbWl0IHRoaXMgaW5pdGlhbGl6ZXIgZXhwcmVzc2lvbiBhcy1pcy5cbiAgICAgICAgICAvLyBOb3RlOiBpZiB0aGUgbWVtYmVyJ3MgaW5pdGlhbGl6ZXIgZXhwcmVzc2lvbiByZWZlcnMgdG8gYW5vdGhlclxuICAgICAgICAgIC8vIHZhbHVlIHdpdGhpbiB0aGUgZW51bSAoZS5nLiBzb21ldGhpbmcgbGlrZVxuICAgICAgICAgIC8vICAgZW51bSBGb28ge1xuICAgICAgICAgIC8vICAgICBGaWVsZDEsXG4gICAgICAgICAgLy8gICAgIEZpZWxkMiA9IEZpZWxkMSArIHNvbWV0aGluZygpLFxuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vIFRoZW4gd2hlbiB3ZSBlbWl0IHRoZSBpbml0aWFsaXplciB3ZSBwcm9kdWNlIGludmFsaWQgY29kZSBiZWNhdXNlXG4gICAgICAgICAgLy8gb24gdGhlIENsb3N1cmUgc2lkZSB0aGUgcmVmZXJlbmNlIHRvIEZpZWxkMSBoYXMgdG8gYmUgbmFtZXNwYWNlZCxcbiAgICAgICAgICAvLyBlLmcuIHdyaXR0ZW4gXCJGb28uRmllbGQxICsgc29tZXRoaW5nKClcIi5cbiAgICAgICAgICAvLyBIb3BlZnVsbHkgdGhpcyBkb2Vzbid0IGNvbWUgdXAgb2Z0ZW4gLS0gaWYgdGhlIGVudW0gaW5zdGVhZCBoYXNcbiAgICAgICAgICAvLyBzb21ldGhpbmcgbGlrZVxuICAgICAgICAgIC8vICAgICBGaWVsZDIgPSBGaWVsZDEgKyAzLFxuICAgICAgICAgIC8vIHRoZW4gaXQncyBzdGlsbCBhIGNvbnN0YW50IGV4cHJlc3Npb24gYW5kIHdlIGlubGluZSB0aGUgY29uc3RhbnRcbiAgICAgICAgICAvLyB2YWx1ZSBpbiB0aGUgYWJvdmUgYnJhbmNoIG9mIHRoaXMgXCJpZlwiIHN0YXRlbWVudC5cbiAgICAgICAgICB0aGlzLnZpc2l0KG1lbWJlci5pbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChlbnVtSW5kZXgudG9TdHJpbmcoKSk7XG4gICAgICAgIGVudW1JbmRleCsrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCcsJyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnfTtcXG4nKTtcblxuICAgIGNvbnN0IGlzRXhwb3J0ZWQgPSBoYXNNb2RpZmllckZsYWcobm9kZSwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpO1xuICAgIGlmIChpc0V4cG9ydGVkKSB0aGlzLmVtaXQoYGV4cG9ydCB7JHtuYW1lfX07XFxuYCk7XG5cbiAgICBpZiAoaGFzTW9kaWZpZXJGbGFnKG5vZGUsIHRzLk1vZGlmaWVyRmxhZ3MuQ29uc3QpKSB7XG4gICAgICAvLyBCeSBUeXBlU2NyaXB0IHNlbWFudGljcywgY29uc3QgZW51bXMgZGlzYXBwZWFyIGFmdGVyIFRTIGNvbXBpbGF0aW9uLlxuICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBnZW5lcmF0ZSB0aGUgcnVudGltZSB2YWx1ZSBhYm92ZSB0byBtYWtlIENsb3N1cmUgQ29tcGlsZXIncyB0eXBlIHN5c3RlbVxuICAgICAgLy8gaGFwcHkgYW5kIGFsbG93IHJlZmVyaW5nIHRvIGVudW1zIGZyb20gSlMgY29kZSwgYnV0IHdlIHNob3VsZCBhdCBsZWFzdCBub3QgZW1pdCBzdHJpbmdcbiAgICAgIC8vIHZhbHVlIG1hcHBpbmdzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEVtaXQgdGhlIHJldmVyc2UgbWFwcGluZyBvZiBmb29bZm9vLkJBUl0gPSAnQkFSJzsgbGluZXMgZm9yIG51bWJlciBlbnVtcy5cbiAgICBpZiAoZW51bVR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBub2RlLm1lbWJlcnMpIHtcbiAgICAgICAgY29uc3QgbWVtYmVyTmFtZSA9IG1lbWJlci5uYW1lLmdldFRleHQoKTtcbiAgICAgICAgdGhpcy5lbWl0KGAke25hbWV9WyR7bmFtZX0uJHttZW1iZXJOYW1lfV0gPSBcIiR7bWVtYmVyTmFtZX1cIjtcXG5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIEV4dGVybnNXcml0ZXIgZ2VuZXJhdGVzIENsb3N1cmUgZXh0ZXJucyBmcm9tIFR5cGVTY3JpcHQgc291cmNlLiAqL1xuY2xhc3MgRXh0ZXJuc1dyaXRlciBleHRlbmRzIENsb3N1cmVSZXdyaXRlciB7XG4gIHByb2Nlc3MoKToge291dHB1dDogc3RyaW5nLCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdfSB7XG4gICAgdGhpcy5maW5kRXh0ZXJuUm9vdHMoKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy52aXNpdChub2RlKSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3V0cHV0KCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZW5zdXJlU3ltYm9sRGVjbGFyZWQoc3ltOiB0cy5TeW1ib2wpOiB2b2lkIHtcbiAgICBjb25zdCBkZWNsID0gdGhpcy5maW5kRXhwb3J0ZWREZWNsYXJhdGlvbihzeW0pO1xuICAgIGlmICghZGVjbCkgcmV0dXJuOyAgLy8gc3ltYm9sIGRvZXMgbm90IG5lZWQgZGVjbGFyaW5nLlxuICAgIHRoaXMuZXJyb3IoXG4gICAgICAgIHRoaXMuZmlsZSxcbiAgICAgICAgYENhbm5vdCByZWZlcmVuY2UgYSBub24tZ2xvYmFsIHN5bWJvbCBmcm9tIGFuIGV4dGVybnM6ICR7c3ltLm5hbWV9IGRlY2xhcmVkIGF0ICR7XG4gICAgICAgICAgICBmb3JtYXRMb2NhdGlvbihkZWNsLmdldFNvdXJjZUZpbGUoKSwgZGVjbC5nZXRTdGFydCgpKX1gKTtcbiAgfVxuXG4gIG5ld1R5cGVUcmFuc2xhdG9yKGNvbnRleHQ6IHRzLk5vZGUpIHtcbiAgICBjb25zdCB0dCA9IHN1cGVyLm5ld1R5cGVUcmFuc2xhdG9yKGNvbnRleHQpO1xuICAgIHR0LmlzRm9yRXh0ZXJucyA9IHRydWU7XG4gICAgcmV0dXJuIHR0O1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kRXh0ZXJuUm9vdHMoKTogdHMuTm9kZVtdIHtcbiAgICBpZiAoaXNEdHNGaWxlTmFtZSh0aGlzLmZpbGUuZmlsZU5hbWUpKSB7XG4gICAgICByZXR1cm4gW3RoaXMuZmlsZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbGUuc3RhdGVtZW50cy5maWx0ZXIoc3RtdCA9PiBoYXNNb2RpZmllckZsYWcoc3RtdCwgdHMuTW9kaWZpZXJGbGFncy5BbWJpZW50KSk7XG4gIH1cblxuICAvKiogdmlzaXQgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQuICBJdCBnZW5lcmF0ZXMgZXh0ZXJucyBmcm9tIGEgdHMuTm9kZS4gKi9cbiAgcHVibGljIHZpc2l0KG5vZGU6IHRzLk5vZGUsIG5hbWVzcGFjZTogc3RyaW5nW10gPSBbXSkge1xuICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuU291cmNlRmlsZTpcbiAgICAgICAgY29uc3Qgc291cmNlRmlsZSA9IG5vZGUgYXMgdHMuU291cmNlRmlsZTtcbiAgICAgICAgZm9yIChjb25zdCBzdG10IG9mIHNvdXJjZUZpbGUuc3RhdGVtZW50cykge1xuICAgICAgICAgIHRoaXMudmlzaXQoc3RtdCwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Nb2R1bGVEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgZGVjbCA9IG5vZGUgYXMgdHMuTW9kdWxlRGVjbGFyYXRpb247XG4gICAgICAgIHN3aXRjaCAoZGVjbC5uYW1lLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIC8vIEUuZy4gXCJkZWNsYXJlIG5hbWVzcGFjZSBmb28ge1wiXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQoZGVjbC5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICAgIC8vIEUuZy4gXCJkZWNsYXJlIGdsb2JhbCB7IC4uLiB9XCIuICBSZXNldCB0byB0aGUgb3V0ZXIgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzRmlyc3REZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnLyoqIEBjb25zdCAqL1xcbicpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVFeHRlcm5zVmFyaWFibGUobmFtZSwgbmFtZXNwYWNlLCAne30nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBuYW1lc3BhY2UuY29uY2F0KG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlY2wuYm9keSkgdGhpcy52aXNpdChkZWNsLmJvZHksIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgICAgIC8vIEUuZy4gXCJkZWNsYXJlIG1vZHVsZSAnZm9vJyB7XCIgKG5vdGUgdGhlIHF1b3RlcykuXG4gICAgICAgICAgICAvLyBXZSBzdGlsbCB3YW50IHRvIGVtaXQgZXh0ZXJucyBmb3IgdGhpcyBtb2R1bGUsIGJ1dFxuICAgICAgICAgICAgLy8gQ2xvc3VyZSBkb2Vzbid0IHJlYWxseSBwcm92aWRlIGEgbWVjaGFuaXNtIGZvclxuICAgICAgICAgICAgLy8gbW9kdWxlLXNjb3BlZCBleHRlcm5zLiAgRm9yIG5vdywgaWdub3JlIHRoZSBlbmNsb3NpbmdcbiAgICAgICAgICAgIC8vIG5hbWVzcGFjZSAoYmVjYXVzZSB0aGlzIGlzIGRlY2xhcmluZyBhIHRvcC1sZXZlbCBtb2R1bGUpXG4gICAgICAgICAgICAvLyBhbmQgZW1pdCBpbnRvIGEgZmFrZSBuYW1lc3BhY2UuXG5cbiAgICAgICAgICAgIC8vIERlY2xhcmUgdGhlIHRvcC1sZXZlbCBcInRzaWNrbGVfZGVjbGFyZV9tb2R1bGVcIi5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnLyoqIEBjb25zdCAqL1xcbicpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUV4dGVybnNWYXJpYWJsZSgndHNpY2tsZV9kZWNsYXJlX21vZHVsZScsIFtdLCAne30nKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFsndHNpY2tsZV9kZWNsYXJlX21vZHVsZSddO1xuXG4gICAgICAgICAgICAvLyBEZWNsYXJlIHRoZSBpbm5lciBcInRzaWNrbGVfZGVjbGFyZV9tb2R1bGUuZm9vXCIsIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyBkZWNsYXJlZCBhbHJlYWR5IGVsc2V3aGVyZS5cbiAgICAgICAgICAgIGxldCBpbXBvcnROYW1lID0gKGRlY2wubmFtZSBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgICAgICAgICAgdGhpcy5lbWl0KGAvLyBEZXJpdmVkIGZyb206IGRlY2xhcmUgbW9kdWxlIFwiJHtpbXBvcnROYW1lfVwiXFxuYCk7XG4gICAgICAgICAgICAvLyBXZSBhbHNvIGRvbid0IGNhcmUgYWJvdXQgdGhlIGFjdHVhbCBuYW1lIG9mIHRoZSBtb2R1bGUgKFwiZm9vXCJcbiAgICAgICAgICAgIC8vIGluIHRoZSBhYm92ZSBleGFtcGxlKSwgZXhjZXB0IHRoYXQgd2Ugd2FudCBpdCB0byBub3QgY29uZmxpY3QuXG4gICAgICAgICAgICBpbXBvcnROYW1lID0gaW1wb3J0TmFtZS5yZXBsYWNlKC9fLywgJ19fJykucmVwbGFjZSgvW15BLVphLXpdL2csICdfJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpcnN0RGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCcvKiogQGNvbnN0ICovXFxuJyk7XG4gICAgICAgICAgICAgIHRoaXMud3JpdGVFeHRlcm5zVmFyaWFibGUoaW1wb3J0TmFtZSwgbmFtZXNwYWNlLCAne30nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVjbGFyZSB0aGUgY29udGVudHMgaW5zaWRlIHRoZSBcInRzaWNrbGVfZGVjbGFyZV9tb2R1bGUuZm9vXCIuXG4gICAgICAgICAgICBpZiAoZGVjbC5ib2R5KSB0aGlzLnZpc2l0KGRlY2wuYm9keSwgbmFtZXNwYWNlLmNvbmNhdChpbXBvcnROYW1lKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5lcnJvclVuaW1wbGVtZW50ZWRLaW5kKGRlY2wubmFtZSwgJ2V4dGVybnMgZ2VuZXJhdGlvbiBvZiBuYW1lc3BhY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Nb2R1bGVCbG9jazpcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlIGFzIHRzLk1vZHVsZUJsb2NrO1xuICAgICAgICBmb3IgKGNvbnN0IHN0bXQgb2YgYmxvY2suc3RhdGVtZW50cykge1xuICAgICAgICAgIHRoaXMudmlzaXQoc3RtdCwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgaW1wb3J0RXF1YWxzID0gbm9kZSBhcyB0cy5JbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjtcbiAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gZ2V0SWRlbnRpZmllclRleHQoaW1wb3J0RXF1YWxzLm5hbWUpO1xuICAgICAgICBpZiAobG9jYWxOYW1lID09PSAnbmcnKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGBcXG4vKiBTa2lwcGluZyBwcm9ibGVtYXRpYyBpbXBvcnQgbmcgPSAuLi47ICovXFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcG9ydEVxdWFscy5tb2R1bGVSZWZlcmVuY2Uua2luZCA9PT0gdHMuU3ludGF4S2luZC5FeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSkge1xuICAgICAgICAgIHRoaXMuZW1pdChgXFxuLyogVE9ETzogaW1wb3J0ICR7bG9jYWxOYW1lfSA9IHJlcXVpcmUoLi4uKSAqL1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHFuID0gZ2V0RW50aXR5TmFtZVRleHQoaW1wb3J0RXF1YWxzLm1vZHVsZVJlZmVyZW5jZSk7XG4gICAgICAgIC8vIEBjb25zdCBzbyB0aGF0IENsb3N1cmUgQ29tcGlsZXIgdW5kZXJzdGFuZHMgdGhpcyBpcyBhbiBhbGlhcy5cbiAgICAgICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggPT09IDApIHRoaXMuZW1pdCgnLyoqIEBjb25zdCAqL1xcbicpO1xuICAgICAgICB0aGlzLndyaXRlRXh0ZXJuc1ZhcmlhYmxlKGxvY2FsTmFtZSwgbmFtZXNwYWNlLCBxbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb246XG4gICAgICAgIHRoaXMud3JpdGVFeHRlcm5zVHlwZShub2RlIGFzIHRzLkludGVyZmFjZURlY2xhcmF0aW9uIHwgdHMuQ2xhc3NEZWNsYXJhdGlvbiwgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgZm5EZWNsID0gbm9kZSBhcyB0cy5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgICAgICBjb25zdCBuYW1lID0gZm5EZWNsLm5hbWU7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgIHRoaXMuZXJyb3IoZm5EZWNsLCAnYW5vbnltb3VzIGZ1bmN0aW9uIGluIGV4dGVybnMnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBHYXRoZXIgdXAgYWxsIG92ZXJsb2FkcyBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICBjb25zdCBzeW0gPSB0aGlzLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKG5hbWUpO1xuICAgICAgICBjb25zdCBkZWNscyA9IHN5bS5kZWNsYXJhdGlvbnMhLmZpbHRlcihkID0+IGQua2luZCA9PT0gdHMuU3ludGF4S2luZC5GdW5jdGlvbkRlY2xhcmF0aW9uKSBhc1xuICAgICAgICAgICAgdHMuRnVuY3Rpb25EZWNsYXJhdGlvbltdO1xuICAgICAgICAvLyBPbmx5IGVtaXQgdGhlIGZpcnN0IGRlY2xhcmF0aW9uIG9mIGVhY2ggb3ZlcmxvYWRlZCBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGZuRGVjbCAhPT0gZGVjbHNbMF0pIGJyZWFrO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmVtaXRGdW5jdGlvblR5cGUoZGVjbHMpO1xuICAgICAgICB0aGlzLndyaXRlRXh0ZXJuc0Z1bmN0aW9uKG5hbWUsIHBhcmFtcywgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6XG4gICAgICAgIGZvciAoY29uc3QgZGVjbCBvZiAobm9kZSBhcyB0cy5WYXJpYWJsZVN0YXRlbWVudCkuZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgIHRoaXMud3JpdGVFeHRlcm5zVmFyaWFibGVEZWNsKGRlY2wsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRW51bURlY2xhcmF0aW9uOlxuICAgICAgICB0aGlzLndyaXRlRXh0ZXJuc0VudW0obm9kZSBhcyB0cy5FbnVtRGVjbGFyYXRpb24sIG5hbWVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBbGlhc0RlY2xhcmF0aW9uOlxuICAgICAgICB0aGlzLndyaXRlRXh0ZXJuc1R5cGVBbGlhcyhub2RlIGFzIHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZW1pdChgXFxuLyogVE9ETzogJHt0cy5TeW50YXhLaW5kW25vZGUua2luZF19IGluICR7bmFtZXNwYWNlLmpvaW4oJy4nKX0gKi9cXG5gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGlzRmlyc3REZWNsYXJhdGlvbiByZXR1cm5zIHRydWUgaWYgZGVjbCBpcyB0aGUgZmlyc3QgZGVjbGFyYXRpb25cbiAgICogb2YgaXRzIHN5bWJvbC4gIEUuZy4gaW1hZ2luZVxuICAgKiAgIGludGVyZmFjZSBGb28geyB4OiBudW1iZXI7IH1cbiAgICogICBpbnRlcmZhY2UgRm9vIHsgeTogbnVtYmVyOyB9XG4gICAqIHdlIG9ubHkgd2FudCB0byBlbWl0IHRoZSBcIkByZWNvcmRcIiBmb3IgRm9vIG9uIHRoZSBmaXJzdCBvbmUuXG4gICAqL1xuICBwcml2YXRlIGlzRmlyc3REZWNsYXJhdGlvbihkZWNsOiB0cy5EZWNsYXJhdGlvblN0YXRlbWVudCk6IGJvb2xlYW4ge1xuICAgIGlmICghZGVjbC5uYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBzeW0gPSB0aGlzLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKGRlY2wubmFtZSk7XG4gICAgaWYgKCFzeW0uZGVjbGFyYXRpb25zIHx8IHN5bS5kZWNsYXJhdGlvbnMubGVuZ3RoIDwgMikgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGRlY2wgPT09IHN5bS5kZWNsYXJhdGlvbnNbMF07XG4gIH1cblxuICBwcml2YXRlIHdyaXRlRXh0ZXJuc1R5cGUoZGVjbDogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb258dHMuQ2xhc3NEZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IG5hbWUgPSBkZWNsLm5hbWU7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aGlzLmVycm9yKGRlY2wsICdhbm9ueW1vdXMgdHlwZSBpbiBleHRlcm5zJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHR5cGVOYW1lID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZS5nZXRUZXh0KCldKS5qb2luKCcuJyk7XG4gICAgaWYgKGNsb3N1cmVFeHRlcm5zQmxhY2tsaXN0LmluZGV4T2YodHlwZU5hbWUpID49IDApIHJldHVybjtcblxuICAgIGlmICh0aGlzLmlzRmlyc3REZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgbGV0IHBhcmFtTmFtZXM6IHN0cmluZ1tdID0gW107XG4gICAgICBjb25zdCBqc2RvY1RhZ3M6IGpzZG9jLlRhZ1tdID0gW107XG4gICAgICBsZXQgd3JpdGVKc0RvYyA9IHRydWU7XG4gICAgICB0aGlzLm1heWJlQWRkSGVyaXRhZ2VDbGF1c2VzKGpzZG9jVGFncywgZGVjbCk7XG4gICAgICBpZiAoZGVjbC5raW5kID09PSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24pIHtcbiAgICAgICAganNkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdjb25zdHJ1Y3Rvcid9KTtcbiAgICAgICAganNkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdzdHJ1Y3QnfSk7XG4gICAgICAgIGNvbnN0IGN0b3JzID0gKGRlY2wgYXMgdHMuQ2xhc3NEZWNsYXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLm1lbWJlcnMuZmlsdGVyKChtKSA9PiBtLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgd3JpdGVKc0RvYyA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q3RvcjogdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbiA9IGN0b3JzWzBdIGFzIHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb247XG4gICAgICAgICAgY29uc3QgY3RvclRhZ3MgPSBbe3RhZ05hbWU6ICdjb25zdHJ1Y3Rvcid9LCB7dGFnTmFtZTogJ3N0cnVjdCd9XTtcbiAgICAgICAgICBpZiAoY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcGFyYW1OYW1lcyA9IHRoaXMuZW1pdEZ1bmN0aW9uVHlwZShjdG9ycyBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uW10sIGN0b3JUYWdzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1OYW1lcyA9IHRoaXMuZW1pdEZ1bmN0aW9uVHlwZShbZmlyc3RDdG9yXSwgY3RvclRhZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAganNkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdyZWNvcmQnfSk7XG4gICAgICAgIGpzZG9jVGFncy5wdXNoKHt0YWdOYW1lOiAnc3RydWN0J30pO1xuICAgICAgfVxuICAgICAgaWYgKHdyaXRlSnNEb2MpIHRoaXMuZW1pdChqc2RvYy50b1N0cmluZyhqc2RvY1RhZ3MpKTtcbiAgICAgIHRoaXMud3JpdGVFeHRlcm5zRnVuY3Rpb24obmFtZSwgcGFyYW1OYW1lcywgbmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGV2ZXJ5dGhpbmcgZXhjZXB0IChNZXRob2RTaWduYXR1cmV8TWV0aG9kRGVjbGFyYXRpb258Q29uc3RydWN0b3IpXG4gICAgY29uc3QgbWV0aG9kcyA9IG5ldyBNYXA8c3RyaW5nLCB0cy5NZXRob2REZWNsYXJhdGlvbltdPigpO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlY2wubWVtYmVycykge1xuICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlTaWduYXR1cmU6XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Qcm9wZXJ0eURlY2xhcmF0aW9uOlxuICAgICAgICAgIGNvbnN0IHByb3AgPSBtZW1iZXIgYXMgdHMuUHJvcGVydHlTaWduYXR1cmU7XG4gICAgICAgICAgaWYgKHByb3AubmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEpTRG9jVHlwZShwcm9wKTtcbiAgICAgICAgICAgIGlmIChoYXNNb2RpZmllckZsYWcocHJvcCwgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdChgXFxuJHt0eXBlTmFtZX0uJHtwcm9wLm5hbWUuZ2V0VGV4dCgpfTtcXG5gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdChgXFxuJHt0eXBlTmFtZX0ucHJvdG90eXBlLiR7cHJvcC5uYW1lLmdldFRleHQoKX07XFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETzogRm9yIG5vdyBwcm9wZXJ0eSBuYW1lcyBvdGhlciB0aGFuIElkZW50aWZpZXJzIGFyZSBub3QgaGFuZGxlZDsgZS5nLlxuICAgICAgICAgIC8vICAgIGludGVyZmFjZSBGb28geyBcIjEyM2JhclwiOiBudW1iZXIgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTWV0aG9kU2lnbmF0dXJlOlxuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTWV0aG9kRGVjbGFyYXRpb246XG4gICAgICAgICAgY29uc3QgbWV0aG9kID0gbWVtYmVyIGFzIHRzLk1ldGhvZERlY2xhcmF0aW9uO1xuICAgICAgICAgIGNvbnN0IGlzU3RhdGljID0gaGFzTW9kaWZpZXJGbGFnKG1ldGhvZCwgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpO1xuICAgICAgICAgIGNvbnN0IG1ldGhvZFNpZ25hdHVyZSA9IGAke21ldGhvZC5uYW1lLmdldFRleHQoKX0kJCQke2lzU3RhdGljID8gJ3N0YXRpYycgOiAnaW5zdGFuY2UnfWA7XG5cbiAgICAgICAgICBpZiAobWV0aG9kcy5oYXMobWV0aG9kU2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgbWV0aG9kcy5nZXQobWV0aG9kU2lnbmF0dXJlKSEucHVzaChtZXRob2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXRob2RzLnNldChtZXRob2RTaWduYXR1cmUsIFttZXRob2RdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Db25zdHJ1Y3RvcjpcbiAgICAgICAgICBjb250aW51ZTsgIC8vIEhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gTWVtYmVycyBjYW4gaW5jbHVkZSB0aGluZ3MgbGlrZSBpbmRleCBzaWduYXR1cmVzLCBmb3IgZS5nLlxuICAgICAgICAgIC8vICAgaW50ZXJmYWNlIEZvbyB7IFtrZXk6IHN0cmluZ106IG51bWJlcjsgfVxuICAgICAgICAgIC8vIEZvciBub3csIGp1c3Qgc2tpcCBpdC5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0aGUgbWVtYmVyIHdhc24ndCBoYW5kbGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50LlxuICAgICAgbGV0IG1lbWJlck5hbWUgPSBuYW1lc3BhY2U7XG4gICAgICBpZiAobWVtYmVyLm5hbWUpIHtcbiAgICAgICAgbWVtYmVyTmFtZSA9IG1lbWJlck5hbWUuY29uY2F0KFttZW1iZXIubmFtZS5nZXRUZXh0KCldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChgXFxuLyogVE9ETzogJHt0cy5TeW50YXhLaW5kW21lbWJlci5raW5kXX06ICR7bWVtYmVyTmFtZS5qb2luKCcuJyl9ICovXFxuYCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG1ldGhvZCBkZWNsYXJhdGlvbnMvc2lnbmF0dXJlcyBzZXBhcmF0ZWx5LCBzaW5jZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBvdmVybG9hZHMuXG4gICAgZm9yIChjb25zdCBtZXRob2RWYXJpYW50cyBvZiBBcnJheS5mcm9tKG1ldGhvZHMudmFsdWVzKCkpKSB7XG4gICAgICBjb25zdCBmaXJzdE1ldGhvZFZhcmlhbnQgPSBtZXRob2RWYXJpYW50c1swXTtcbiAgICAgIGxldCBwYXJhbWV0ZXJOYW1lczogc3RyaW5nW107XG4gICAgICBpZiAobWV0aG9kVmFyaWFudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBwYXJhbWV0ZXJOYW1lcyA9IHRoaXMuZW1pdEZ1bmN0aW9uVHlwZShtZXRob2RWYXJpYW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbWV0ZXJOYW1lcyA9IHRoaXMuZW1pdEZ1bmN0aW9uVHlwZShbZmlyc3RNZXRob2RWYXJpYW50XSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRob2ROYW1lc3BhY2UgPSBuYW1lc3BhY2UuY29uY2F0KFtuYW1lLmdldFRleHQoKV0pO1xuICAgICAgLy8gSWYgdGhlIG1ldGhvZCBpcyBzdGF0aWMsIGRvbid0IGFkZCB0aGUgcHJvdG90eXBlLlxuICAgICAgaWYgKCFoYXNNb2RpZmllckZsYWcoZmlyc3RNZXRob2RWYXJpYW50LCB0cy5Nb2RpZmllckZsYWdzLlN0YXRpYykpIHtcbiAgICAgICAgbWV0aG9kTmFtZXNwYWNlLnB1c2goJ3Byb3RvdHlwZScpO1xuICAgICAgfVxuICAgICAgdGhpcy53cml0ZUV4dGVybnNGdW5jdGlvbihmaXJzdE1ldGhvZFZhcmlhbnQubmFtZSwgcGFyYW1ldGVyTmFtZXMsIG1ldGhvZE5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUV4dGVybnNWYXJpYWJsZURlY2woZGVjbDogdHMuVmFyaWFibGVEZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBzdHJpbmdbXSkge1xuICAgIGlmIChkZWNsLm5hbWUua2luZCA9PT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQoZGVjbC5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgaWYgKGNsb3N1cmVFeHRlcm5zQmxhY2tsaXN0LmluZGV4T2YobmFtZSkgPj0gMCkgcmV0dXJuO1xuICAgICAgdGhpcy5lbWl0SlNEb2NUeXBlKGRlY2wpO1xuICAgICAgdGhpcy5lbWl0KCdcXG4nKTtcbiAgICAgIHRoaXMud3JpdGVFeHRlcm5zVmFyaWFibGUobmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJvclVuaW1wbGVtZW50ZWRLaW5kKGRlY2wubmFtZSwgJ2V4dGVybnMgZm9yIHZhcmlhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUV4dGVybnNWYXJpYWJsZShuYW1lOiBzdHJpbmcsIG5hbWVzcGFjZTogc3RyaW5nW10sIHZhbHVlPzogc3RyaW5nKSB7XG4gICAgY29uc3QgcXVhbGlmaWVkTmFtZSA9IG5hbWVzcGFjZS5jb25jYXQoW25hbWVdKS5qb2luKCcuJyk7XG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggPT09IDApIHRoaXMuZW1pdChgdmFyIGApO1xuICAgIHRoaXMuZW1pdChxdWFsaWZpZWROYW1lKTtcbiAgICBpZiAodmFsdWUpIHRoaXMuZW1pdChgID0gJHt2YWx1ZX1gKTtcbiAgICB0aGlzLmVtaXQoJztcXG4nKTtcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVFeHRlcm5zRnVuY3Rpb24obmFtZTogdHMuTm9kZSwgcGFyYW1zOiBzdHJpbmdbXSwgbmFtZXNwYWNlOiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IHBhcmFtc1N0ciA9IHBhcmFtcy5qb2luKCcsICcpO1xuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGZxbiA9IG5hbWVzcGFjZS5qb2luKCcuJyk7XG4gICAgICBpZiAobmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgZnFuICs9ICcuJzsgIC8vIGNvbXB1dGVkIG5hbWVzIGluY2x1ZGUgWyBdIGluIHRoZWlyIGdldFRleHQoKSByZXByZXNlbnRhdGlvbi5cbiAgICAgIH1cbiAgICAgIGZxbiArPSBuYW1lLmdldFRleHQoKTtcbiAgICAgIHRoaXMuZW1pdChgJHtmcW59ID0gZnVuY3Rpb24oJHtwYXJhbXNTdHJ9KSB7fTtcXG5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5hbWUua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMuZXJyb3IobmFtZSwgJ05vbi1uYW1lc3BhY2VkIGNvbXB1dGVkIG5hbWUgaW4gZXh0ZXJucycpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KGBmdW5jdGlvbiAke25hbWUuZ2V0VGV4dCgpfSgke3BhcmFtc1N0cn0pIHt9XFxuYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUV4dGVybnNFbnVtKGRlY2w6IHRzLkVudW1EZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUpO1xuICAgIHRoaXMuZW1pdCgnXFxuLyoqIEBjb25zdCAqL1xcbicpO1xuICAgIHRoaXMud3JpdGVFeHRlcm5zVmFyaWFibGUobmFtZSwgbmFtZXNwYWNlLCAne30nKTtcbiAgICBuYW1lc3BhY2UgPSBuYW1lc3BhY2UuY29uY2F0KFtuYW1lXSk7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgZGVjbC5tZW1iZXJzKSB7XG4gICAgICBsZXQgbWVtYmVyTmFtZTogc3RyaW5nfHVuZGVmaW5lZDtcbiAgICAgIHN3aXRjaCAobWVtYmVyLm5hbWUua2luZCkge1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgICAgICBtZW1iZXJOYW1lID0gZ2V0SWRlbnRpZmllclRleHQobWVtYmVyLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsOlxuICAgICAgICAgIGNvbnN0IHRleHQgPSAobWVtYmVyLm5hbWUgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICAgICAgICBpZiAoaXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWUodGV4dCkpIG1lbWJlck5hbWUgPSB0ZXh0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFtZW1iZXJOYW1lKSB7XG4gICAgICAgIHRoaXMuZW1pdChgXFxuLyogVE9ETzogJHt0cy5TeW50YXhLaW5kW21lbWJlci5uYW1lLmtpbmRdfTogJHttZW1iZXIubmFtZS5nZXRUZXh0KCl9ICovXFxuYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCcvKiogQGNvbnN0IHtudW1iZXJ9ICovXFxuJyk7XG4gICAgICB0aGlzLndyaXRlRXh0ZXJuc1ZhcmlhYmxlKG1lbWJlck5hbWUsIG5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUV4dGVybnNUeXBlQWxpYXMoZGVjbDogdHMuVHlwZUFsaWFzRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogc3RyaW5nW10pIHtcbiAgICBjb25zdCB0eXBlU3RyID0gdGhpcy50eXBlVG9DbG9zdXJlKGRlY2wsIHVuZGVmaW5lZCwgdHJ1ZSAvKiByZXNvbHZlQWxpYXMgKi8pO1xuICAgIHRoaXMuZW1pdChgXFxuLyoqIEB0eXBlZGVmIHske3R5cGVTdHJ9fSAqL1xcbmApO1xuICAgIHRoaXMud3JpdGVFeHRlcm5zVmFyaWFibGUoZ2V0SWRlbnRpZmllclRleHQoZGVjbC5uYW1lKSwgbmFtZXNwYWNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1BvbHltZXJCZWhhdmlvclByb3BlcnR5SW5DYWxsRXhwcmVzc2lvbihwYTogdHMuUHJvcGVydHlBc3NpZ25tZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IHBhcmVudFBhcmVudCA9IHBhLnBhcmVudCAmJiBwYS5wYXJlbnQucGFyZW50O1xuICBpZiAocGEubmFtZS5raW5kICE9PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIgfHxcbiAgICAgIChwYS5uYW1lIGFzIHRzLklkZW50aWZpZXIpLnRleHQgIT09ICdiZWhhdmlvcnMnIHx8ICFwYS5wYXJlbnQgfHwgIXBhLnBhcmVudC5wYXJlbnQgfHxcbiAgICAgIHBhLnBhcmVudC5wYXJlbnQua2luZCAhPT0gdHMuU3ludGF4S2luZC5DYWxsRXhwcmVzc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGV4cHIgPSAocGFyZW50UGFyZW50IGFzIHRzLkNhbGxFeHByZXNzaW9uKS5leHByZXNzaW9uO1xuICByZXR1cm4gZXhwci5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIgJiYgKGV4cHIgYXMgdHMuSWRlbnRpZmllcikudGV4dCA9PT0gJ1BvbHltZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5ub3RhdGUoXG4gICAgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBmaWxlOiB0cy5Tb3VyY2VGaWxlLCBob3N0OiBBbm5vdGF0b3JIb3N0LFxuICAgIHRzSG9zdD86IHRzLk1vZHVsZVJlc29sdXRpb25Ib3N0LCB0c09wdHM/OiB0cy5Db21waWxlck9wdGlvbnMsXG4gICAgc291cmNlTWFwcGVyPzogU291cmNlTWFwcGVyKToge291dHB1dDogc3RyaW5nLCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdfSB7XG4gIHJldHVybiBuZXcgQW5ub3RhdG9yKHR5cGVDaGVja2VyLCBmaWxlLCBob3N0LCB0c0hvc3QsIHRzT3B0cywgc291cmNlTWFwcGVyKS5hbm5vdGF0ZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVFeHRlcm5zKHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgZmlsZTogdHMuU291cmNlRmlsZSwgaG9zdDogQW5ub3RhdG9ySG9zdCk6XG4gICAge291dHB1dDogc3RyaW5nLCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdfSB7XG4gIHJldHVybiBuZXcgRXh0ZXJuc1dyaXRlcih0eXBlQ2hlY2tlciwgZmlsZSwgaG9zdCkucHJvY2VzcygpO1xufVxuXG4vKiogQ29uY2F0ZW5hdGUgYWxsIGdlbmVyYXRlZCBleHRlcm5zIGRlZmluaXRpb25zIHRvZ2V0aGVyIGludG8gYSBzdHJpbmcuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2VuZXJhdGVkRXh0ZXJucyhleHRlcm5zOiB7W2ZpbGVOYW1lOiBzdHJpbmddOiBzdHJpbmd9KTogc3RyaW5nIHtcbiAgbGV0IGFsbEV4dGVybnMgPSBFWFRFUk5TX0hFQURFUjtcbiAgZm9yIChjb25zdCBmaWxlTmFtZSBvZiBPYmplY3Qua2V5cyhleHRlcm5zKSkge1xuICAgIGFsbEV4dGVybnMgKz0gYC8vIGV4dGVybnMgZnJvbSAke2ZpbGVOYW1lfTpcXG5gO1xuICAgIGFsbEV4dGVybnMgKz0gZXh0ZXJuc1tmaWxlTmFtZV07XG4gIH1cbiAgcmV0dXJuIGFsbEV4dGVybnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHNpY2tsZUhvc3QgZXh0ZW5kcyBlczVwcm9jZXNzb3IuRXM1UHJvY2Vzc29ySG9zdCwgQW5ub3RhdG9ySG9zdCB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRvd25sZXZlbCBkZWNvcmF0b3JzXG4gICAqL1xuICB0cmFuc2Zvcm1EZWNvcmF0b3JzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gY29udmVycyB0eXBlcyB0byBjbG9zdXJlXG4gICAqL1xuICB0cmFuc2Zvcm1UeXBlc1RvQ2xvc3VyZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFkZCBhbGlhc2VzIHRvIHRoZSAuZC50cyBmaWxlcyB0byBhZGQgdGhlIGV4cG9ydHMgdG8gdGhlXG4gICAqIOCyoF/gsqAuY2x1dHogbmFtZXNwYWNlLlxuICAgKi9cbiAgYWRkRHRzQ2x1dHpBbGlhc2VzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElmIHRydWUsIHRzaWNrbGUgYW5kIGRlY29yYXRvciBkb3dubGV2ZWwgcHJvY2Vzc2luZyB3aWxsIGJlIHNraXBwZWQgZm9yXG4gICAqIHRoYXQgZmlsZS5cbiAgICovXG4gIHNob3VsZFNraXBUc2lja2xlUHJvY2Vzc2luZyhmaWxlTmFtZTogc3RyaW5nKTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRzaWNrbGUgdHJlYXRzIHdhcm5pbmdzIGFzIGVycm9ycywgaWYgdHJ1ZSwgaWdub3JlIHdhcm5pbmdzLiAgVGhpcyBtaWdodCBiZVxuICAgKiB1c2VmdWwgZm9yIGUuZy4gdGhpcmQgcGFydHkgY29kZS5cbiAgICovXG4gIHNob3VsZElnbm9yZVdhcm5pbmdzRm9yUGF0aChmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRW1pdFJlc3VsdHMoZW1pdFJlc3VsdHM6IEVtaXRSZXN1bHRbXSk6IEVtaXRSZXN1bHQge1xuICBjb25zdCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdID0gW107XG4gIGxldCBlbWl0U2tpcHBlZCA9IHRydWU7XG4gIGNvbnN0IGVtaXR0ZWRGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgZXh0ZXJuczoge1tmaWxlTmFtZTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICBjb25zdCBtb2R1bGVzTWFuaWZlc3QgPSBuZXcgTW9kdWxlc01hbmlmZXN0KCk7XG4gIGZvciAoY29uc3QgZXIgb2YgZW1pdFJlc3VsdHMpIHtcbiAgICBkaWFnbm9zdGljcy5wdXNoKC4uLmVyLmRpYWdub3N0aWNzKTtcbiAgICBlbWl0U2tpcHBlZCA9IGVtaXRTa2lwcGVkIHx8IGVyLmVtaXRTa2lwcGVkO1xuICAgIGVtaXR0ZWRGaWxlcy5wdXNoKC4uLmVyLmVtaXR0ZWRGaWxlcyk7XG4gICAgT2JqZWN0LmFzc2lnbihleHRlcm5zLCBlci5leHRlcm5zKTtcbiAgICBtb2R1bGVzTWFuaWZlc3QuYWRkTWFuaWZlc3QoZXIubW9kdWxlc01hbmlmZXN0KTtcbiAgfVxuICByZXR1cm4ge2RpYWdub3N0aWNzLCBlbWl0U2tpcHBlZCwgZW1pdHRlZEZpbGVzLCBleHRlcm5zLCBtb2R1bGVzTWFuaWZlc3R9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVtaXRSZXN1bHQgZXh0ZW5kcyB0cy5FbWl0UmVzdWx0IHtcbiAgLy8gVGhlIG1hbmlmZXN0IG9mIEpTIG1vZHVsZXMgb3V0cHV0IGJ5IHRoZSBjb21waWxlci5cbiAgbW9kdWxlc01hbmlmZXN0OiBNb2R1bGVzTWFuaWZlc3Q7XG4gIC8qKiBleHRlcm5zLmpzIGZpbGVzIHByb2R1Y2VkIGJ5IHRzaWNrbGUsIGlmIGFueS4gKi9cbiAgZXh0ZXJuczoge1tmaWxlTmFtZTogc3RyaW5nXTogc3RyaW5nfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbWl0VHJhbnNmb3JtZXJzIHtcbiAgYmVmb3JlVHNpY2tsZT86IEFycmF5PHRzLlRyYW5zZm9ybWVyRmFjdG9yeTx0cy5Tb3VyY2VGaWxlPj47XG4gIGJlZm9yZVRzPzogQXJyYXk8dHMuVHJhbnNmb3JtZXJGYWN0b3J5PHRzLlNvdXJjZUZpbGU+PjtcbiAgYWZ0ZXJUcz86IEFycmF5PHRzLlRyYW5zZm9ybWVyRmFjdG9yeTx0cy5Tb3VyY2VGaWxlPj47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbWl0V2l0aFRzaWNrbGUoXG4gICAgcHJvZ3JhbTogdHMuUHJvZ3JhbSwgaG9zdDogVHNpY2tsZUhvc3QsIHRzSG9zdDogdHMuQ29tcGlsZXJIb3N0LCB0c09wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyxcbiAgICB0YXJnZXRTb3VyY2VGaWxlPzogdHMuU291cmNlRmlsZSwgd3JpdGVGaWxlPzogdHMuV3JpdGVGaWxlQ2FsbGJhY2ssXG4gICAgY2FuY2VsbGF0aW9uVG9rZW4/OiB0cy5DYW5jZWxsYXRpb25Ub2tlbiwgZW1pdE9ubHlEdHNGaWxlcz86IGJvb2xlYW4sXG4gICAgY3VzdG9tVHJhbnNmb3JtZXJzOiBFbWl0VHJhbnNmb3JtZXJzID0ge30pOiBFbWl0UmVzdWx0IHtcbiAgbGV0IHRzaWNrbGVEaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdID0gW107XG4gIGNvbnN0IHR5cGVDaGVja2VyID0gcHJvZ3JhbS5nZXRUeXBlQ2hlY2tlcigpO1xuICBjb25zdCB0c2lja2xlU291cmNlVHJhbnNmb3JtZXJzOiBBcnJheTx0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4+ID0gW107XG4gIGlmIChob3N0LnRyYW5zZm9ybVR5cGVzVG9DbG9zdXJlKSB7XG4gICAgLy8gTm90ZTogdHNpY2tsZS5hbm5vdGF0ZSBjYW4gYWxzbyBsb3dlciBkZWNvcmF0b3JzIGluIHRoZSBzYW1lIHJ1bi5cbiAgICB0c2lja2xlU291cmNlVHJhbnNmb3JtZXJzLnB1c2goY3JlYXRlVHJhbnNmb3JtZXJGcm9tU291cmNlTWFwKChzb3VyY2VGaWxlLCBzb3VyY2VNYXBwZXIpID0+IHtcbiAgICAgIGNvbnN0IHtvdXRwdXQsIGRpYWdub3N0aWNzfSA9XG4gICAgICAgICAgYW5ub3RhdGUodHlwZUNoZWNrZXIsIHNvdXJjZUZpbGUsIGhvc3QsIHRzSG9zdCwgdHNPcHRpb25zLCBzb3VyY2VNYXBwZXIpO1xuICAgICAgdHNpY2tsZURpYWdub3N0aWNzLnB1c2goLi4uZGlhZ25vc3RpY3MpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KSk7XG4gICAgLy8gT25seSBhZGQgQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjb21tZW50cyB3aGVuIGFsc28gYWRkaW5nIHR5cGUgYW5ub3RhdGlvbnMuXG4gICAgdHNpY2tsZVNvdXJjZVRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybUZpbGVvdmVydmlld0NvbW1lbnQpO1xuICAgIHRzaWNrbGVTb3VyY2VUcmFuc2Zvcm1lcnMucHVzaChcbiAgICAgICAgY2xhc3NEZWNvcmF0b3JEb3dubGV2ZWxUcmFuc2Zvcm1lcih0eXBlQ2hlY2tlciwgdHNpY2tsZURpYWdub3N0aWNzKSk7XG4gIH0gZWxzZSBpZiAoaG9zdC50cmFuc2Zvcm1EZWNvcmF0b3JzKSB7XG4gICAgdHNpY2tsZVNvdXJjZVRyYW5zZm9ybWVycy5wdXNoKGNyZWF0ZVRyYW5zZm9ybWVyRnJvbVNvdXJjZU1hcCgoc291cmNlRmlsZSwgc291cmNlTWFwcGVyKSA9PiB7XG4gICAgICBjb25zdCB7b3V0cHV0LCBkaWFnbm9zdGljc30gPVxuICAgICAgICAgIGRlY29yYXRvci5jb252ZXJ0RGVjb3JhdG9ycyh0eXBlQ2hlY2tlciwgc291cmNlRmlsZSwgc291cmNlTWFwcGVyKTtcbiAgICAgIHRzaWNrbGVEaWFnbm9zdGljcy5wdXNoKC4uLmRpYWdub3N0aWNzKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkpO1xuICAgIHRzaWNrbGVTb3VyY2VUcmFuc2Zvcm1lcnMucHVzaChcbiAgICAgICAgY2xhc3NEZWNvcmF0b3JEb3dubGV2ZWxUcmFuc2Zvcm1lcih0eXBlQ2hlY2tlciwgdHNpY2tsZURpYWdub3N0aWNzKSk7XG4gIH1cbiAgLy8gLy8gRm9yIGRlYnVnZ2luZzogdHJhbnNmb3JtZXIgdGhhdCBqdXN0IGVtaXRzIHRoZSBzYW1lIHRleHQuXG4gIC8vIGJlZm9yZVRzVHJhbnNmb3JtZXJzLnB1c2goY3JlYXRlVHJhbnNmb3JtZXIoaG9zdCwgdHlwZUNoZWNrZXIsIChzb3VyY2VGaWxlLCBzb3VyY2VNYXBwZXIpID0+IHtcbiAgLy8gICBzb3VyY2VNYXBwZXIuYWRkTWFwcGluZyhzb3VyY2VGaWxlLCB7cG9zaXRpb246IDAsIGxpbmU6IDAsIGNvbHVtbjogMH0sIHtwb3NpdGlvbjogMCwgbGluZTogMCxcbiAgLy8gICBjb2x1bW46IDB9LCBzb3VyY2VGaWxlLnRleHQubGVuZ3RoKTsgcmV0dXJuIHNvdXJjZUZpbGUudGV4dDtcbiAgLy8gfSkpO1xuICBjb25zdCB0c2lja2xlVHJhbnNmb3JtZXJzID0gY3JlYXRlQ3VzdG9tVHJhbnNmb3JtZXJzKHtiZWZvcmU6IHRzaWNrbGVTb3VyY2VUcmFuc2Zvcm1lcnN9KTtcbiAgY29uc3QgdHNUcmFuc2Zvcm1lcnM6IHRzLkN1c3RvbVRyYW5zZm9ybWVycyA9IHtcbiAgICBiZWZvcmU6IFtcbiAgICAgIC4uLihjdXN0b21UcmFuc2Zvcm1lcnMuYmVmb3JlVHNpY2tsZSB8fCBbXSksXG4gICAgICAuLi4odHNpY2tsZVRyYW5zZm9ybWVycy5iZWZvcmUgfHwgW10pLm1hcCh0ZiA9PiBza2lwVHJhbnNmb3JtRm9yU291cmNlRmlsZUlmTmVlZGVkKGhvc3QsIHRmKSksXG4gICAgICAuLi4oY3VzdG9tVHJhbnNmb3JtZXJzLmJlZm9yZVRzIHx8IFtdKSxcbiAgICBdLFxuICAgIGFmdGVyOiBbXG4gICAgICAuLi4oY3VzdG9tVHJhbnNmb3JtZXJzLmFmdGVyVHMgfHwgW10pLFxuICAgICAgLi4uKHRzaWNrbGVUcmFuc2Zvcm1lcnMuYWZ0ZXIgfHwgW10pLm1hcCh0ZiA9PiBza2lwVHJhbnNmb3JtRm9yU291cmNlRmlsZUlmTmVlZGVkKGhvc3QsIHRmKSlcbiAgICBdXG4gIH07XG5cbiAgY29uc3Qgd3JpdGVGaWxlRGVsZWdhdGUgPSB3cml0ZUZpbGUgfHwgdHNIb3N0LndyaXRlRmlsZS5iaW5kKHRzSG9zdCk7XG4gIGNvbnN0IG1vZHVsZXNNYW5pZmVzdCA9IG5ldyBNb2R1bGVzTWFuaWZlc3QoKTtcbiAgY29uc3Qgd3JpdGVGaWxlSW1wbCA9XG4gICAgICAoZmlsZU5hbWU6IHN0cmluZywgY29udGVudDogc3RyaW5nLCB3cml0ZUJ5dGVPcmRlck1hcms6IGJvb2xlYW4sXG4gICAgICAgb25FcnJvcj86IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQsIHNvdXJjZUZpbGVzPzogdHMuU291cmNlRmlsZVtdKSA9PiB7XG4gICAgICAgIGlmIChwYXRoLmV4dG5hbWUoZmlsZU5hbWUpICE9PSAnLm1hcCcpIHtcbiAgICAgICAgICBpZiAodHNPcHRpb25zLmlubGluZVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgY29udGVudCA9IGNvbWJpbmVJbmxpbmVTb3VyY2VNYXBzKHByb2dyYW0sIGZpbGVOYW1lLCBjb250ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCA9IHJlbW92ZUlubGluZVNvdXJjZU1hcChjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGVudCA9IGVzNXByb2Nlc3Nvci5jb252ZXJ0Q29tbW9uSnNUb0dvb2dNb2R1bGVJZk5lZWRlZChcbiAgICAgICAgICAgICAgaG9zdCwgbW9kdWxlc01hbmlmZXN0LCBmaWxlTmFtZSwgY29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IGNvbWJpbmVTb3VyY2VNYXBzKHByb2dyYW0sIGZpbGVOYW1lLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdC5hZGREdHNDbHV0ekFsaWFzZXMgJiYgaXNEdHNGaWxlTmFtZShmaWxlTmFtZSkgJiYgc291cmNlRmlsZXMpIHtcbiAgICAgICAgICBjb250ZW50ID0gYWRkQ2x1dHpBbGlhc2VzKGZpbGVOYW1lLCBjb250ZW50LCBzb3VyY2VGaWxlcywgdHlwZUNoZWNrZXIsIGhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlRmlsZURlbGVnYXRlKGZpbGVOYW1lLCBjb250ZW50LCB3cml0ZUJ5dGVPcmRlck1hcmssIG9uRXJyb3IsIHNvdXJjZUZpbGVzKTtcbiAgICAgIH07XG5cbiAgY29uc3Qge2RpYWdub3N0aWNzOiB0c0RpYWdub3N0aWNzLCBlbWl0U2tpcHBlZCwgZW1pdHRlZEZpbGVzfSA9IHByb2dyYW0uZW1pdChcbiAgICAgIHRhcmdldFNvdXJjZUZpbGUsIHdyaXRlRmlsZUltcGwsIGNhbmNlbGxhdGlvblRva2VuLCBlbWl0T25seUR0c0ZpbGVzLCB0c1RyYW5zZm9ybWVycyk7XG5cbiAgY29uc3QgZXh0ZXJuczoge1tmaWxlTmFtZTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICBpZiAoaG9zdC50cmFuc2Zvcm1UeXBlc1RvQ2xvc3VyZSkge1xuICAgIGNvbnN0IHNvdXJjZUZpbGVzID0gdGFyZ2V0U291cmNlRmlsZSA/IFt0YXJnZXRTb3VyY2VGaWxlXSA6IHByb2dyYW0uZ2V0U291cmNlRmlsZXMoKTtcbiAgICBzb3VyY2VGaWxlcy5mb3JFYWNoKHNmID0+IHtcbiAgICAgIGlmIChpc0R0c0ZpbGVOYW1lKHNmLmZpbGVOYW1lKSAmJiBob3N0LnNob3VsZFNraXBUc2lja2xlUHJvY2Vzc2luZyhzZi5maWxlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge291dHB1dCwgZGlhZ25vc3RpY3N9ID0gd3JpdGVFeHRlcm5zKHR5cGVDaGVja2VyLCBzZiwgaG9zdCk7XG4gICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgIGV4dGVybnNbc2YuZmlsZU5hbWVdID0gb3V0cHV0O1xuICAgICAgfVxuICAgICAgaWYgKGRpYWdub3N0aWNzKSB7XG4gICAgICAgIHRzaWNrbGVEaWFnbm9zdGljcy5wdXNoKC4uLmRpYWdub3N0aWNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyBBbGwgZGlhZ25vc3RpY3MgKGluY2x1ZGluZyB3YXJuaW5ncykgYXJlIHRyZWF0ZWQgYXMgZXJyb3JzLlxuICAvLyBJZiB0aGUgaG9zdCBkZWNpZGVzIHRvIGlnbm9yZSB3YXJuaW5ncywganVzdCBkaXNjYXJkIHRoZW0uXG4gIC8vIFdhcm5pbmdzIGluY2x1ZGUgc3R1ZmYgbGlrZSBcImRvbid0IHVzZSBAdHlwZSBpbiB5b3VyIGpzZG9jXCI7IHRzaWNrbGVcbiAgLy8gd2FybnMgYW5kIHRoZW4gZml4ZXMgdXAgdGhlIGNvZGUgdG8gYmUgQ2xvc3VyZS1jb21wYXRpYmxlIGFueXdheS5cbiAgdHNpY2tsZURpYWdub3N0aWNzID0gdHNpY2tsZURpYWdub3N0aWNzLmZpbHRlcihcbiAgICAgIGQgPT4gZC5jYXRlZ29yeSA9PT0gdHMuRGlhZ25vc3RpY0NhdGVnb3J5LkVycm9yIHx8XG4gICAgICAgICAgIWhvc3Quc2hvdWxkSWdub3JlV2FybmluZ3NGb3JQYXRoKGQuZmlsZSEuZmlsZU5hbWUpKTtcblxuICByZXR1cm4ge1xuICAgIG1vZHVsZXNNYW5pZmVzdCxcbiAgICBlbWl0U2tpcHBlZCxcbiAgICBlbWl0dGVkRmlsZXM6IGVtaXR0ZWRGaWxlcyB8fCBbXSxcbiAgICBkaWFnbm9zdGljczogWy4uLnRzRGlhZ25vc3RpY3MsIC4uLnRzaWNrbGVEaWFnbm9zdGljc10sXG4gICAgZXh0ZXJuc1xuICB9O1xufVxuXG5mdW5jdGlvbiBhcmVBbnlEZWNsYXJhdGlvbnNGcm9tU291cmNlRmlsZShcbiAgICBkZWNsYXJhdGlvbnM6IHRzLkRlY2xhcmF0aW9uW10sIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpIHtcbiAgZm9yIChjb25zdCBkZWNsIG9mIGRlY2xhcmF0aW9ucykge1xuICAgIGlmIChkZWNsLmdldFNvdXJjZUZpbGUoKSA9PT0gc291cmNlRmlsZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRUb011bHRpTWFwPFQsIFU+KG1hcDogTWFwPFQsIFVbXT4sIGtleTogVCwgdmFsdWU6IFUpIHtcbiAgY29uc3QgYXJyYXkgPSBtYXAuZ2V0KGtleSk7XG4gIGlmIChhcnJheSkge1xuICAgIGFycmF5LnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIG1hcC5zZXQoa2V5LCBbdmFsdWVdKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgdHNpY2tsZSBwcm9kdWNlZCBkZWNsYXJhdGlvbiBmaWxlIG1pZ2h0IGJlIGNvbnN1bWVkIGJlIHJlZmVyZW5jZWQgYnkgQ2x1dHpcbiAqIHByb2R1Y2VkIC5kLnRzIGZpbGVzLCB3aGljaCB1c2Ugc3ltYm9sIG5hbWVzIGJhc2VkIG9uIENsb3N1cmUncyBpbnRlcm5hbFxuICogbmFtaW5nIGNvbnZlbnRpb25zLCBzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgYWxpYXNlcyBmb3IgYWxsIHRoZSBleHBvcnRlZCBzeW1ib2xzXG4gKiBpbiB0aGUgQ2x1dHogbmFtaW5nIGNvbnZlbnRpb24uXG4gKi9cbmZ1bmN0aW9uIGFkZENsdXR6QWxpYXNlcyhcbiAgICBmaWxlTmFtZTogc3RyaW5nLCBkdHNGaWxlQ29udGVudDogc3RyaW5nLCBzb3VyY2VGaWxlczogdHMuU291cmNlRmlsZVtdLFxuICAgIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgaG9zdDogVHNpY2tsZUhvc3QpOiBzdHJpbmcge1xuICBjb25zdCByZWV4cG9ydHNCeU5hbWVzcGFjZTogTWFwPHN0cmluZywgc3RyaW5nW10+ID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IHNmIG9mIHNvdXJjZUZpbGVzKSB7XG4gICAgY29uc3QgbW9kdWxlU3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihzZik7XG4gICAgY29uc3QgbW9kdWxlRXhwb3J0cyA9IG1vZHVsZVN5bWJvbCAmJiB0eXBlQ2hlY2tlci5nZXRFeHBvcnRzT2ZNb2R1bGUobW9kdWxlU3ltYm9sKTtcblxuICAgIGlmICghbW9kdWxlRXhwb3J0cykge1xuICAgICAgcmV0dXJuIGR0c0ZpbGVDb250ZW50O1xuICAgIH1cblxuICAgIC8vIHBhdGhUb01vZHVsZU5hbWUgZXhwZWN0cyB0aGUgZmlsZSBuYW1lIHRvIGVuZCBpbiAuanNcbiAgICBjb25zdCBqc0ZpbGVOYW1lID0gZmlsZU5hbWUucmVwbGFjZSgnLmQudHMnLCAnLmpzJyk7XG4gICAgY29uc3QgbW9kdWxlTmFtZSA9IGhvc3QucGF0aFRvTW9kdWxlTmFtZSgnJywganNGaWxlTmFtZSk7XG4gICAgY29uc3QgY2x1dHpNb2R1bGVOYW1lID0gbW9kdWxlTmFtZS5yZXBsYWNlKC9cXC4vZywgJyQnKTtcblxuICAgIC8vIG1vZHVsZUV4cG9ydHMgaXMgYSB0cy5NYXA8dHMuU3ltYm9sPiB3aGljaCBpcyBhbiBlczYgTWFwLCBidXQgaGFzIGFcbiAgICAvLyBkaWZmZXJlbnQgdHlwZSBmb3Igbm8gcmVhc29uXG4gICAgZm9yIChjb25zdCBzeW1ib2wgb2YgbW9kdWxlRXhwb3J0cykge1xuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGFkZCBjbHV0eiBhbGlhc2VzIGluIHRoZSBmaWxlIHRoZSBzeW1ib2wgd2FzIG9yaWdpbmFsbHlcbiAgICAgIC8vIGV4cG9ydGVkIGZyb20sIG5vdCBpbiBhbnkgZmlsZXMgd2hlcmUgdGhlIHN5bWJvbCB3YXMgcmVleHBvcnRlZCwgc2luY2VcbiAgICAgIC8vIHRoZSBhbGlhcyB3aWxsIHJlZmVyIHRvIGEgc3ltYm9sIHRoYXQgbWlnaHQgbm90IGJlIHByZXNlbnQgaW4gdGhlIHJlZXhwb3J0aW5nXG4gICAgICAvLyBmaWxlLiAgSWYgdGhlcmUgYXJlIG5vIGRlY2xhcmF0aW9ucywgYmUgY29uc2VydmF0aXZlIGFuZCBlbWl0IHRoZSBhbGlhc2VzLlxuICAgICAgY29uc3QgZGVjbGFyYXRpb25zID0gc3ltYm9sLmdldERlY2xhcmF0aW9ucygpO1xuICAgICAgaWYgKGRlY2xhcmF0aW9ucyAmJiAhYXJlQW55RGVjbGFyYXRpb25zRnJvbVNvdXJjZUZpbGUoZGVjbGFyYXRpb25zLCBzZikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBXYW50IHRvIGFsaWFzIHRoZSBzeW1ib2wgdG8gbWF0Y2ggd2hhdCBjbHV0eiB3b3VsZCBwcm9kdWNlLCBzbyBjbHV0eiAuZC50cydzXG4gICAgICAvLyBjYW4gcmVmZXJlbmNlIHN5bWJvbHMgZnJvbSB0eXBlc2NyaXB0IC5kLnRzJ3MuIFNlZSBleGFtcGxlcyBhdDpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NsdXR6L3RyZWUvbWFzdGVyL3NyYy90ZXN0L2phdmEvY29tL2dvb2dsZS9qYXZhc2NyaXB0L2NsdXR6XG4gICAgICAvLyBUaGUgZmlyc3Qgc3ltYm9sIG5hbWUgaXMgdGhhdCBjdXJyZW50bHkgcHJvZHVjZWQgYnkgY2x1dHosIGFuZCB0aGUgc2Vjb25kXG4gICAgICAvLyBpcyB3aGF0IGluY3JlbWVudGFsIGNsdXR6IHdpbGwgcHJvZHVjZS5cbiAgICAgIGNvbnN0IHJlZXhwb3J0cyA9IFtdO1xuICAgICAgcmVleHBvcnRzLnB1c2goe1xuICAgICAgICBuYW1lc3BhY2U6ICfgsqBf4LKgLmNsdXR6JyxcbiAgICAgICAgY2x1dHpTeW1ib2xOYW1lOiBgbW9kdWxlJGNvbnRlbnRzJCR7Y2x1dHpNb2R1bGVOYW1lfV8ke3N5bWJvbC5uYW1lfWAsXG4gICAgICAgIGFsaWFzZWRTeW1ib2xOYW1lOiBzeW1ib2wubmFtZVxuICAgICAgfSk7XG4gICAgICByZWV4cG9ydHMucHVzaCh7XG4gICAgICAgIG5hbWVzcGFjZTogJ+CyoF/gsqAuY2x1dHoubW9kdWxlJGV4cG9ydHMkJyArIGNsdXR6TW9kdWxlTmFtZSxcbiAgICAgICAgY2x1dHpTeW1ib2xOYW1lOiBzeW1ib2wubmFtZSxcbiAgICAgICAgYWxpYXNlZFN5bWJvbE5hbWU6IGBtb2R1bGUkY29udGVudHMkJHtjbHV0ek1vZHVsZU5hbWV9XyR7c3ltYm9sLm5hbWV9YFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7cGFyYW1zLCBwYXJhbXNXaXRoQ29udHJhaW50fSA9IGdldEdlbmVyaWNUeXBlUGFyYW1ldGVycyhzeW1ib2wpO1xuXG4gICAgICBpZiAoc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQ2xhc3MpIHtcbiAgICAgICAgLy8gY2xhc3NlcyBuZWVkIHNwZWNpYWwgY2FyZSB0byBtYXRjaCBjbHV0eiwgd2hpY2ggc2VwZXJhdGVzIGNsYXNzIHR5cGVzIGludG8gYVxuICAgICAgICAvLyB0eXBlIGZvciB0aGUgc3RhdGljIHByb3BlcnRpZXMgYW5kIGEgdHlwZSBmb3IgdGhlIGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICAgICAgcmVleHBvcnRzLnB1c2goe1xuICAgICAgICAgIG5hbWVzcGFjZTogJ+CyoF/gsqAuY2x1dHonLFxuICAgICAgICAgIGNsdXR6U3ltYm9sTmFtZTogYG1vZHVsZSRjb250ZW50cyQke2NsdXR6TW9kdWxlTmFtZX1fJHtzeW1ib2wubmFtZX1fSW5zdGFuY2VgLFxuICAgICAgICAgIGFsaWFzZWRTeW1ib2xOYW1lOiBzeW1ib2wubmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVleHBvcnRzLnB1c2goe1xuICAgICAgICAgIG5hbWVzcGFjZTogJ+CyoF/gsqAuY2x1dHoubW9kdWxlJGV4cG9ydHMkJyArIGNsdXR6TW9kdWxlTmFtZSxcbiAgICAgICAgICBjbHV0elN5bWJvbE5hbWU6IHN5bWJvbC5uYW1lICsgJ19JbnN0YW5jZScsXG4gICAgICAgICAgYWxpYXNlZFN5bWJvbE5hbWU6IGBtb2R1bGUkY29udGVudHMkJHtjbHV0ek1vZHVsZU5hbWV9XyR7c3ltYm9sLm5hbWV9YFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlR5cGUgfHwgc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQ2xhc3MpIHtcbiAgICAgICAgZm9yIChjb25zdCB7bmFtZXNwYWNlLCBjbHV0elN5bWJvbE5hbWUsIGFsaWFzZWRTeW1ib2xOYW1lfSBvZiByZWV4cG9ydHMpIHtcbiAgICAgICAgICBhZGRUb011bHRpTWFwKFxuICAgICAgICAgICAgICByZWV4cG9ydHNCeU5hbWVzcGFjZSwgbmFtZXNwYWNlLFxuICAgICAgICAgICAgICBgdHlwZSAke2NsdXR6U3ltYm9sTmFtZX0ke3BhcmFtc1dpdGhDb250cmFpbnR9ID0gJHthbGlhc2VkU3ltYm9sTmFtZX0ke3BhcmFtc307YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSB8fCBzeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5DbGFzcykge1xuICAgICAgICBmb3IgKGNvbnN0IHtuYW1lc3BhY2UsIGNsdXR6U3ltYm9sTmFtZSwgYWxpYXNlZFN5bWJvbE5hbWV9IG9mIHJlZXhwb3J0cykge1xuICAgICAgICAgIGFkZFRvTXVsdGlNYXAoXG4gICAgICAgICAgICAgIHJlZXhwb3J0c0J5TmFtZXNwYWNlLCBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgIGBjb25zdCAke2NsdXR6U3ltYm9sTmFtZX06IHR5cGVvZiAke2FsaWFzZWRTeW1ib2xOYW1lfTtgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChyZWV4cG9ydHNCeU5hbWVzcGFjZS5zaXplKSB7XG4gICAgZHRzRmlsZUNvbnRlbnQgKz0gJ2RlY2xhcmUgZ2xvYmFsIHtcXG4nO1xuICAgIGZvciAoY29uc3QgW25hbWVzcGFjZSwgcmV4cHNdIG9mIHJlZXhwb3J0c0J5TmFtZXNwYWNlKSB7XG4gICAgICBkdHNGaWxlQ29udGVudCArPSBgXFx0bmFtZXNwYWNlICR7bmFtZXNwYWNlfSB7XFxuYDtcbiAgICAgIGZvciAoY29uc3QgcmV4cCBvZiByZXhwcykge1xuICAgICAgICBkdHNGaWxlQ29udGVudCArPSBgXFx0XFx0JHtyZXhwfVxcbmA7XG4gICAgICB9XG4gICAgICBkdHNGaWxlQ29udGVudCArPSAnXFx0fVxcbic7XG4gICAgfVxuICAgIGR0c0ZpbGVDb250ZW50ICs9ICd9XFxuJztcbiAgfVxuXG4gIHJldHVybiBkdHNGaWxlQ29udGVudDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIDIgc3RyaW5ncyBzcGVjaWZ5aW5nIHRoZSBnZW5lcmljIHR5cGUgYXJndW1lbnRzIGZvciB0aGUgc3ltYm9sLiAgVGhlIGNvbnN0cmFpbmVkIHBhcmFtc1xuICogaW5jbHVkZSBhbnkgYFQgZXh0ZW5kcyBmb29gIGFyZ3VtZW50cywgdGhlIHJlZ3VsYXIgcGFyYW1zIGFyZSBqdXN0IGEgbGlzdCBvZiB0aGUgdHlwZSBzeW1ib2xzLFxuICogc2luY2Ugd2UgbmVlZCB0aGUgY29uc3RyYWludHMgb24gdGhlIExIUyBvZiB0aGUgYWxpYXMgZGVjbGFyYXRpb24sIGJ1dCBjYW4ndCBoYXZlIHRoZW0gb24gdGhlXG4gKiBSSFMuXG4gKi9cbmZ1bmN0aW9uIGdldEdlbmVyaWNUeXBlUGFyYW1ldGVycyhzeW1ib2w6IHRzLlN5bWJvbCk6XG4gICAge3BhcmFtczogc3RyaW5nLCBwYXJhbXNXaXRoQ29udHJhaW50OiBzdHJpbmd9IHtcbiAgaWYgKCFzeW1ib2wuZGVjbGFyYXRpb25zKSB7XG4gICAgcmV0dXJuIHtwYXJhbXM6ICcnLCBwYXJhbXNXaXRoQ29udHJhaW50OiAnJ307XG4gIH1cblxuICAvLyBBbGwgZGVjbGFyYXRpb25zIGhhdmUgdG8gaGF2ZSBtYXRjaGluZyBnZW5lcmljIHR5cGVzLCBzbyB3ZSdyZSBzYWZlIGp1c3QgbG9va2luZyBhdFxuICAvLyB0aGUgZmlyc3Qgb25lLlxuICBpZiAoIXN5bWJvbC5kZWNsYXJhdGlvbnNbMF0pIHtcbiAgICByZXR1cm4ge3BhcmFtczogJycsIHBhcmFtc1dpdGhDb250cmFpbnQ6ICcnfTtcbiAgfVxuXG4gIGNvbnN0IGRlY2xhcmF0aW9uID0gc3ltYm9sLmRlY2xhcmF0aW9uc1swXTtcblxuICBpZiAoW1xuICAgICAgICB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb24sIHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3JLZXl3b3JkLFxuICAgICAgICB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24sIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgICAgIHRzLlN5bnRheEtpbmQuVHlwZUFsaWFzRGVjbGFyYXRpb25cbiAgICAgIF0uaW5kZXhPZihkZWNsYXJhdGlvbi5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4ge3BhcmFtczogJycsIHBhcmFtc1dpdGhDb250cmFpbnQ6ICcnfTtcbiAgfVxuXG4gIGNvbnN0IGRlY2xhcmF0aW9uV2l0aFR5cGVQYXJhbWV0ZXJzOiB0cy5EZWNsYXJhdGlvbldpdGhUeXBlUGFyYW1ldGVycyA9XG4gICAgICBkZWNsYXJhdGlvbiBhcyB0cy5EZWNsYXJhdGlvbldpdGhUeXBlUGFyYW1ldGVycztcblxuICBpZiAoIWRlY2xhcmF0aW9uV2l0aFR5cGVQYXJhbWV0ZXJzLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHtwYXJhbXM6ICcnLCBwYXJhbXNXaXRoQ29udHJhaW50OiAnJ307XG4gIH1cblxuICBjb25zdCBwYXJhbUxpc3Q6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IGNvbnN0cmFpbmVkUGFyYW1MaXN0OiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcmFtIG9mIGRlY2xhcmF0aW9uV2l0aFR5cGVQYXJhbWV0ZXJzLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgbGV0IGNvbnN0cmFpbmVkUGFyYW0gPSBwYXJhbS5uYW1lLmdldFRleHQoKTtcbiAgICBpZiAocGFyYW0uY29uc3RyYWludCkge1xuICAgICAgY29uc3RyYWluZWRQYXJhbSArPSBgIGV4dGVuZHMgJHtwYXJhbS5jb25zdHJhaW50LmdldFRleHQoKX1gO1xuICAgIH1cbiAgICBpZiAocGFyYW0uZGVmYXVsdCkge1xuICAgICAgY29uc3RyYWluZWRQYXJhbSArPSBgID0gJHtwYXJhbS5kZWZhdWx0LmdldFRleHQoKX1gO1xuICAgIH1cbiAgICBjb25zdHJhaW5lZFBhcmFtTGlzdC5wdXNoKGNvbnN0cmFpbmVkUGFyYW0pO1xuICAgIHBhcmFtTGlzdC5wdXNoKHBhcmFtLm5hbWUuZ2V0VGV4dCgpKTtcbiAgfVxuXG4gIGNvbnN0IHBhcmFtcyA9IGA8JHtwYXJhbUxpc3Quam9pbignLCcpfT5gO1xuICBjb25zdCBwYXJhbXNXaXRoQ29udHJhaW50ID0gYDwke2NvbnN0cmFpbmVkUGFyYW1MaXN0LmpvaW4oJywnKX0+YDtcblxuICByZXR1cm4ge3BhcmFtcywgcGFyYW1zV2l0aENvbnRyYWludH07XG59XG5cbmZ1bmN0aW9uIHNraXBUcmFuc2Zvcm1Gb3JTb3VyY2VGaWxlSWZOZWVkZWQoXG4gICAgaG9zdDogVHNpY2tsZUhvc3QsXG4gICAgZGVsZWdhdGVGYWN0b3J5OiB0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4pOiB0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4ge1xuICByZXR1cm4gKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGRlbGVnYXRlID0gZGVsZWdhdGVGYWN0b3J5KGNvbnRleHQpO1xuICAgIHJldHVybiAoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSkgPT4ge1xuICAgICAgaWYgKGhvc3Quc2hvdWxkU2tpcFRzaWNrbGVQcm9jZXNzaW5nKHNvdXJjZUZpbGUuZmlsZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VGaWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGVnYXRlKHNvdXJjZUZpbGUpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVJbmxpbmVTb3VyY2VNYXBzKFxuICAgIHByb2dyYW06IHRzLlByb2dyYW0sIGZpbGVQYXRoOiBzdHJpbmcsIGNvbXBpbGVkSnNXaXRoSW5saW5lU291cmNlTWFwOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoaXNEdHNGaWxlTmFtZShmaWxlUGF0aCkpIHtcbiAgICByZXR1cm4gY29tcGlsZWRKc1dpdGhJbmxpbmVTb3VyY2VNYXA7XG4gIH1cbiAgY29uc3Qgc291cmNlTWFwSnNvbiA9IGV4dHJhY3RJbmxpbmVTb3VyY2VNYXAoY29tcGlsZWRKc1dpdGhJbmxpbmVTb3VyY2VNYXApO1xuICBjb21waWxlZEpzV2l0aElubGluZVNvdXJjZU1hcCA9IHJlbW92ZUlubGluZVNvdXJjZU1hcChjb21waWxlZEpzV2l0aElubGluZVNvdXJjZU1hcCk7XG4gIGNvbnN0IGNvbXBvc2VkU291cmNlTWFwID0gY29tYmluZVNvdXJjZU1hcHMocHJvZ3JhbSwgZmlsZVBhdGgsIHNvdXJjZU1hcEpzb24pO1xuICByZXR1cm4gc2V0SW5saW5lU291cmNlTWFwKGNvbXBpbGVkSnNXaXRoSW5saW5lU291cmNlTWFwLCBjb21wb3NlZFNvdXJjZU1hcCk7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVTb3VyY2VNYXBzKFxuICAgIHByb2dyYW06IHRzLlByb2dyYW0sIGZpbGVQYXRoOiBzdHJpbmcsIHRzY1NvdXJjZU1hcFRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHRzY1NvdXJjZU1hcCA9IHBhcnNlU291cmNlTWFwKHRzY1NvdXJjZU1hcFRleHQpO1xuICBpZiAodHNjU291cmNlTWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgLy8gc3RyaXAgaW5jb21pbmcgc291cmNlbWFwcyBmcm9tIHRoZSBzb3VyY2VzIGluIHRoZSBzb3VyY2VtYXBcbiAgICAvLyB0byByZWR1Y2UgdGhlIHNpemUgb2YgdGhlIHNvdXJjZW1hcC5cbiAgICB0c2NTb3VyY2VNYXAuc291cmNlc0NvbnRlbnQgPSB0c2NTb3VyY2VNYXAuc291cmNlc0NvbnRlbnQubWFwKGNvbnRlbnQgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5zSW5saW5lU291cmNlTWFwKGNvbnRlbnQpKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZW1vdmVJbmxpbmVTb3VyY2VNYXAoY29udGVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBmaWxlRGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgbGV0IHRzY1NvdXJjZU1hcEdlbmVyYXRvcjogU291cmNlTWFwR2VuZXJhdG9yfHVuZGVmaW5lZDtcbiAgZm9yIChjb25zdCBzb3VyY2VGaWxlTmFtZSBvZiB0c2NTb3VyY2VNYXAuc291cmNlcykge1xuICAgIGNvbnN0IHNvdXJjZUZpbGUgPSBwcm9ncmFtLmdldFNvdXJjZUZpbGUocGF0aC5yZXNvbHZlKGZpbGVEaXIsIHNvdXJjZUZpbGVOYW1lKSk7XG4gICAgaWYgKCFzb3VyY2VGaWxlIHx8ICFjb250YWluc0lubGluZVNvdXJjZU1hcChzb3VyY2VGaWxlLnRleHQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcHJlZXhpc3RpbmdTb3VyY2VNYXBUZXh0ID0gZXh0cmFjdElubGluZVNvdXJjZU1hcChzb3VyY2VGaWxlLnRleHQpO1xuICAgIGlmICghdHNjU291cmNlTWFwR2VuZXJhdG9yKSB7XG4gICAgICB0c2NTb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcChuZXcgU291cmNlTWFwQ29uc3VtZXIodHNjU291cmNlTWFwKSk7XG4gICAgfVxuICAgIHRzY1NvdXJjZU1hcEdlbmVyYXRvci5hcHBseVNvdXJjZU1hcChcbiAgICAgICAgbmV3IFNvdXJjZU1hcENvbnN1bWVyKHBhcnNlU291cmNlTWFwKHByZWV4aXN0aW5nU291cmNlTWFwVGV4dCwgc291cmNlRmlsZU5hbWUpKSk7XG4gIH1cbiAgcmV0dXJuIHRzY1NvdXJjZU1hcEdlbmVyYXRvciA/IHRzY1NvdXJjZU1hcEdlbmVyYXRvci50b1N0cmluZygpIDogdHNjU291cmNlTWFwVGV4dDtcbn1cbiJdfQ==